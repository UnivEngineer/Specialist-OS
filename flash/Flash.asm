;----------------------------------------------------------------------------
; MXOS
; FLASH.COM - драйвер флеш-диска на AT29C040A
;
; Драйвер имеет три функции (номер передаётся в регистре b):
;   b == 1 - записать сектор (256 байт, номер сектора в de, адрес буфера в hl);
;   b == 2 - считать  сектор (256 байт, номер сектора в de, адрес буфера в hl);
;   b == 3 - выдать размер диска в секторах (резльтат в de, адрес DISK_INFO в hl).
;
; Поддерживается флеш-память AT29C040A
;
; 2022-01-25 Разработано SpaceEngineer
;----------------------------------------------------------------------------

    INCLUDE "../include/mxos.inc"

; Команды для дрыгания ножками ВВ55
LATCH_0 = 0Ah   ; пин защёлки ИР22 = 0
LATCH_1 = 0Bh   ; пин защёлки ИР22 = 1
WRITE_0 = 0Ch   ; пин записи = 0
WRITE_1 = 0Dh   ; пин записи = 1
READ_0  = 0Eh   ; пин чтения = 0
READ_1  = 0Fh   ; пин чтения = 1

; Маски управляющих пинов ВВ55
MASK_STADBY = 0C0h  ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 1
MASK_READ   = 040h  ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 0

; Накопитель, куда назначается драйвер
DRIVE       = 7     ; "H"

; Объем накопителя по умолчанию (2 Мб, 4 х AT29C040A)
DISK_SECTORS = 4 * 512 * 4

; Схема флеш-диска:
; Порт A - данные
; Порт B - адрес [A0-A7] или [A8-A15]
; Порт C0...C4 - адрес [A17-A20]
; Порт С5 - строб защёлки адреса [A8-A15] в ИР22 (лог. 1)
; Порт С6 - строб записи в  ПЗУ (лог. 0)
; Порт С7 - строб чтения из ПЗУ (лог. 0)

;----------------------------------------------------------------------------

    ORG     0DE00h

    ; Установить драйвер для накопителя 7 ("H")
    ld      a, DRIVE
    ld      hl, Driver
    call    bios_installDriver

    ; Запоминаем адрес структуры DISK_INFO и выходим
    ld      (v_diskInfo), hl
    ret

Driver:

    ; Анализ номера функции
    ld      a, b
    cp      3
    jp z,   FuncSize

    push    hl
    push    de
    push    bc

    dec     a
    jp z,   FuncWrite
    dec     a
    jp z,   FuncRead

Exit:
    push    af
    ld      a, MASK_STADBY    ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 1
    ld      (IO_PROG_C), a
    pop     af
    pop     bc
    pop     de
    pop     hl
    ret

;-----------------------------------------------------------------------------------
; Функция 3 - определение объема накопителя
; выход:
;  de = количество секторов (1 - диск не отформатирован)

FuncSize:
    ; Читаем поле isValid из структуры DISK_INFO
    ld      hl, (v_diskInfo)            ; hl = адрес структуры
    ld      de, DISK_INFO.isValid       ; de = смещение поля
    add     hl, de                      ; hl = адрес поля
    ld      a, (hl)                     ; a = isValid

    ; Если диск не отформатирован, возвращаем de = DISK_SECTORS
    ld      de, DISK_SECTORS
    cp      DISK_VALID
    jp nz,  fsExit

    ; Иначе возвращаем в de поле totalSectors из структуры DISK_INFO
    ld      hl, (v_diskInfo)            ; hl = адрес структуры
    ld      de, DISK_INFO.totalSectors  ; de = смещение поля
    add     hl, de                      ; hl = адрес поля
    ld      e, (hl)
    inc     hl
    ld      d, (hl)

fsExit:
    ; Возвращаем в hl адрес структуры DISK_INFO
    ld      hl, (v_diskInfo)
    ret

;----------------------------------------------------------------------------
; Функция 2 - чтение сектора
; вход:
;   de = номер сектора
;   hl = адрес буфера в памяти

FuncRead:
    ; Настройка портов ВВ55
    ld      a, 90h          ; порт A - ввод, порты B и C - вывод 
    ld      (IO_PROG_MODE), a

    ; Запись номера 64к страницы и управляющих битов в порт C
    ; Т.к. секторы по 256 байт, старший байт de это просто номер 64к страницы
    ld      a, d            ; номер 64к страницы, макс 1Fh
    and     01Fh            ; на всякий случай
    or      MASK_READ       ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 0
    ld      (IO_PROG_C), a  ; записываем номер 64к страницы и управляющие биты

    ; de = адрес начала сектора в 64к странице флеш-диска
    ld      d, e
    ld      e, 0
    call    LatchHiAddr     ; записываем d = старший байт адреса (номер сектора) в ИР22

ReadLoop:
    ld      a, e
    ld      (IO_PROG_B), a  ; порт B = младший байт адреса в странице
    ld      a, (IO_PROG_A)  ; читаем байт из порта A
    ld      (hl), a         ; сохраняем в память
    inc     hl
    inc     e
    jp nz,  ReadLoop

    jp      Exit

;----------------------------------------------------------------------------
; Функция 1 - запись сектора
; вход:
;   de = номер сектора
;   hl = адрес буфера в памяти

FuncWrite:
    ; Настройка портов ВВ55
    ld      a, 80h          ; порты A, B и C - вывод 
    ld      (IO_PROG_MODE), a

    ; Определяем номер чипа на флеш-диске
    ld      a, d            ; номер 64к страницы, макс 1Fh
    and     18h             ; обнуляем все биты кроме 3-го и 4-го
    ld      b, a            ; в B получаем номер чипа * 8 (0, 8, 16, 24)

    ; Отключение программной защиты от записи
    call    DisableWriteProtection

    ; Запись номера 64к страницы и управляющих битов в порт C
    ; Т.к. секторы по 256 байт, старший байт de это просто номер 64к страницы
    ld      a, d            ; номер 64к страницы, макс 1Fh
    and     01FH            ; на всякий случай
    or      MASK_STADBY     ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 1
    ld      (IO_PROG_C),a   ; записываем номер 64к страницы и управляющие биты

    ; de = адрес начала сектора в 64к странице флеш-диска
    ld      b, d            ; сохраняем номер 64к страницы (понадобится для ReadByteFromChip)
    ld      d, e
    ld      e, 0
    call    LatchHiAddr     ; записываем d = старший байт адреса (номер сектора) в ИР22

WriteLoop:
    ld      a, e
    ld      (IO_PROG_B), a      ; порт B = младший байт адреса в странице
    ld      a, (hl)             ; читаем байт из памяти
    ld      (IO_PROG_A), a      ; записываем в порт A
    ld      a, WRITE_0
    ld      (IO_PROG_MODE), a   ; устанавливаем пин записи (C6 = 0)
    ld      a, WRITE_1
    ld      (IO_PROG_MODE), a   ; снимаем пин записи (C6 = 1)
    inc     hl
    inc     e
    jp nz,  WriteLoop

    ; Ожидание окончания внутреннего цикла программирования флеш-памяти
    dec     hl              ; последний адрес в буфере
    ld      c, (hl)         ; читаем в C последний записанный байт из буфера
    dec     e               ; адрес последнего байта в секторе

    ; Настройка портов ВВ55
    ld   a, 90h             ; порт A - ввод, порты B и C - вывод 
    ld  (IO_PROG_MODE), a

    ; Максимум итераций цикла ожидания: надо 20 мс, 
    ; 1 цикл = 197 тактов = 98.5 мкс,
    ; 20 мс = 203 итерации
    ld   l, 204

    ; Цикл ожидания
Wait:
    dec     l
    jp z,   Exit

     ; читаем последний записанный байт из флеш памяти
    call    ReadByteFromChip ; b = номер 64к страницы

    ; Пока программирование не окончено, флеш память будет выдавать
    ; бит 7 последнего записанного байта в инверсном виде
    cp      c
    jp nz,  Wait

    jp      Exit

;    ; Задержка 840 циклов по 24 тактов = 10 мс
;    ld     h, 840
;Delay:
;    dec    h       ; 5 тактов
;    ld     a, h    ; 5 тактов
;    or     l       ; 4 такта
;    jp nz, Delay   ; 10 тактов
;    jp     Exit

;----------------------------------------------------------------------------
; Отключение программной защиты от записи
; вход:
;  b = номер чипа * 8 (0, 8, 16, 24)

DisableWriteProtection:
    ; Управляющие коды пишутся в нулевую 64к страницу чипа,
    ; поэтому номер страницы менять не надо
    push    de
    ; Записываем байт AAh по адресу 05555h в чип флеш-памяти
    ld      a,  0AAh
    ld      de, 5555h
    call    WriteByteToChip ; b = номер 64к страницы
    ; Записываем байт 55h по адресу 02AAAh в чип флеш-памяти
    ld      a,  55h
    ld      de, 2AAAh
    call    WriteByteToChip ; b = номер 64к страницы
    ; Записываем байт A0h по адресу 05555h в чип флеш-памяти
    ld      a,  0A0h
    ld      de, 5555h
    call    WriteByteToChip ; b = номер 64к страницы
    pop     de
    ret

;----------------------------------------------------------------------------
; Защёлкивание старшего байта адреса в ИР22 флеш-диска
; вход:
;   d = старший байт адреса (номер сектора)

LatchHiAddr:
    ld      a, LATCH_1
    ld      (IO_PROG_MODE), a   ; поднимаем защёлку ИР22 (C5 = 1)
    ld      a, d
    ld      (IO_PROG_B), a      ; порт B = старший байт адреса (номер сектора)
    ld      a, LATCH_0
    ld      (IO_PROG_MODE), a   ; опускаем защёлку ИР22 (C5 = 0), защёлкивая старший байт адреса
    ret

;----------------------------------------------------------------------------
; Чтение байта из чипа флеш памяти
; вход:
;   de = адрес в 64к странице
;   b  = номер 64к страницы
; выход:
;   a  = байт данных
;   пин чтения остаётся активным (C7 = 0)

ReadByteFromChip:
    call    LatchHiAddr     ; записываем d = старший байт адреса (номер сектора) в ИР22
    ld      a, e
    ld      (IO_PROG_B), a  ; порт B = младший байт адреса
    ld      a, b
    or      MASK_READ       ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 0
    ld      (IO_PROG_C), a  ; записываем номер 64к страницы и управляющие биты
    ld      a,(IO_PROG_A)   ; читаем байт из порта A
    ret

;----------------------------------------------------------------------------
; Запись байта в чип флеш памяти
; вход:
;   de = адрес в 64к странице
;   b  = номер 64к страницы
;   a  = байт данных

WriteByteToChip:
    ld      (IO_PROG_A), a      ; порт A = байт данных
    call    LatchHiAddr         ; записываем d = старший байт адреса (номер сектора) в ИР22
    ld      a, e
    ld      (IO_PROG_B), a      ; порт B = младший байт адреса
    ld      a, b
    or      MASK_STADBY         ; пин защёлки ИР22 = 0, пин записи = 1, пин чтения = 1
    ld      (IO_PROG_C), a      ; записываем номер 64к страницы и управляющие биты
    ld      a, WRITE_0
    ld      (IO_PROG_MODE), a   ; устанавливаем пин записи (C6 = 0)
    ld      a, WRITE_1
    ld      (IO_PROG_MODE), a   ; снимаем пин записи (C6 = 1)
    ret

;----------------------------------------------------------------------------
; Переменные

v_diskInfo: DW 0

;----------------------------------------------------------------------------

    ; Проверка - FLASH.COM не должен вылезать за эти пределы
    ASSERT_DONT_FIT 0E000h

    END
