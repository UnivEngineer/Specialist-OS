0001   0000             ;+---------------------------------------------------------------------------
0002   0000             ; MXOS
0003   0000             ;
0004   0000             ; 2013-12-12 Disassembled by vinxru
0005   0000             ;----------------------------------------------------------------------------
0006   0000             
0007   0000             ; Compilation options
0008   0000             BIG_MEM				 = 1		; Enable large additional memory (> 64 KB)
0009   0000             ARAM_MAX_PAGE		 = 0Fh		; Max number of RAM disk pages (up to 0Fh)
0010   0000             ARAM_PAGE_END		 = 0FFBBh	; End of RAM disk page (36 bytes of common RAM after this)
0011   0000             ROM_64K				 = 1		; Enable Specialist-MX2 ROM (64 KB)
0012   0000             DISABLE_COLOR_BUG	 = 1		; Enable color support
0013   0000             LOAD_FONT			 = 1		; Load font to RAM
0014   0000             FONT_ADDR			 = 0E900h	; Font address
0015   0000             RAMFOS_COMPATIBILITY = 1        ; Compatibility with RAMFOS (WIP)
0016   0000             
0017   0000             ; Memory map:
0018   0000             ;   8FDF-8FFF - [  32  B] Variables
0019   0000             ;   9000-BFFF - [12   KB] Screen
0020   0000             ;   C000-CFFF - [4    KB] DOS.SYS (+ some free space after)
0021   0000             ;   D000-E1FF - [4.5  KB] NC.COM (+ space for directory listing and some free space)
0022   0000             ;   E200-E7FF - [1.5  KB] === 1536 bytes free ===
0023   0000             ;   E900-F0FF - [2    KB] Font (can be disabled by running ROMFNT.COM or using option LOAD_FONT=0)
0024   0000             ;   F100-F837 - [2.25 KB] Monitor-2
0025   0000             ;   FA00-FAFF - [ 256  B] ROM disk Driver
0026   0000             ;   FB00-FDFF - [ 768  B] Disk buffer
0027   0000             ;   FF00-FF81 - [ 129  B] Command line, filled by fileExec
0028   0000             ;   FF82-FFBF - [ 130  B] Stack
0029   0000             ;   FFC0-FFEF - [  32  B] Part of the RAM disk driver
0030   0000             ;   FFD0-FFFF - [  32  B] Hardware ports
0031   0000             
0032   0000             fat				= 0FB00h
0033   0000             diskDirectory	= 0FC00h
0034   0000             diskDirectoryL	= 0FE00h
0035   0000             v_cmdLine		= 0FF00h
0036   0000             STACK_ADDR		= 0FFC0h
0037   0000             
0038   0000             INIT_COLOR		= 0F0h	; Must match COLOR_CMDSCREEN in NC.asm for consistency
0039   0000             
0040   0000             IO_KEYB_A		= 0FFE0h
0041   0000             IO_KEYB_B		= 0FFE1h
0042   0000             IO_KEYB_C		= 0FFE2h
0043   0000             IO_KEYB_MODE	= 0FFE3h
0044   0000             IO_PROG			= 0FFE4h
0045   0000             IO_TIMER		= 0FFECh
0046   0000             IO_COLOR		= 0FFF8h
0047   0000             IO_RAM			= 0FFFCh
0048   0000             IO_ARAM			= 0FFFDh
0049   0000             IO_ROM			= 0FFFEh
0050   0000             IO_PAGE_STD		= 0FFFFh
0051   0000             
0052   8FDF             .org 08FDFh
0053   8FDF             
0054   8FDF             vars:			.block 2
0055   8FE1             v_tapeError:	.block 2	; Tape load error jump address
0056   8FE3             v_tapeAddr:		.block 2	; Address of program loaded form tape
0057   8FE5             				.block 2
0058   8FE7             v_charGen:		.block 2	; Alternative font address / 8
0059   8FE9             v_cursorCfg:	.block 1	; Cursor shape (bits: 7 - visibility, 654 - position, 3210 - height)
0060   8FEA             v_koi8:			.block 1	; KOI mode: 0FFh (KOI-8), 0 (KOI-7)
0061   8FEB             v_escMode:		.block 1	; ESC sequence processing
0062   8FEC             v_keyLocks:		.block 1
0063   8FED             				.block 2
0064   8FEF             v_lastLastKey:	.block 1
0065   8FF0             v_lastKey:		.block 1
0066   8FF1             v_beep:			.block 2	; Sound duration and frequency
0067   8FF3             v_tapeInverse:	.block 1
0068   8FF4             v_cursorDelay:	.block 1
0069   8FF5             byte_8FF5:		.block 1
0070   8FF6             v_oldSP:		.block 2	; Used to save SP by some functions
0071   8FF8             v_maxRamPage:	.block 1    ; Max detected ARAM page
0072   8FF9             v_flashPage:	.block 1    ; Current flash disk page
0073   8FFA             v_inverse:		.block 2	; Inverse font (0=normal, 0FFFFh=inverse)
0074   8FFC             v_cursorY:		.block 1	; Cursor Y position in pixels
0075   8FFD             v_cursorX:		.block 1	; Cursor X position in double pixels
0076   8FFE             v_writeDelay:	.block 1	; Tape write speed
0077   8FFF             v_readDelay:	.block 1	; Tape read speed
0078   9000             
0079   C000             .org 0C000h
0080   C000             
0081   C000             .include "jmps_c000.inc"
0001+  C000 C3 09 C0    		jmp	reboot		; Теплая перезагрузка
0002+  C003 C3 C7 C1    j_keyScan:	jmp	keyScan2	; Получить код нажатой клавиши
0003+  C006 C3 4E C3    		jmp	drawCursor3	; Нарисовать/стереть курсор
0004+  C009             
0082   C009             .include "reboot0.inc"
0001+  C009             ;+---------------------------------------------------------------------------
0002+  C009             ; MXOS
0003+  C009             ; Перезагрузка
0004+  C009             ;
0005+  C009             ; 2013-12-12 Дизассемблировано vinxru
0006+  C009             ;----------------------------------------------------------------------------
0007+  C009             
0008+  C009 31 C0 FF    reboot:		lxi	sp, STACK_ADDR
0009+  C00C C3 5B C4    		jmp	reboot1
0010+  C00F             
0083   C00F 00          .db 0
0084   C010             .include "clearScreen.inc"
0001+  C010             ;+---------------------------------------------------------------------------
0002+  C010             ; MXOS
0003+  C010             ; Очистить экран
0004+  C010             ;
0005+  C010             ; На выходе
0006+  C010             ;  bc, de, hl - сохраняются
0007+  C010             ;
0008+  C010             ; 2013-12-12 Дизассемблировано vinxru
0009+  C010             ;----------------------------------------------------------------------------
0010+  C010             
0011+  C010             clearScreen:	; bc, hl - сохраняем. de - не используется
0012+  C010 E5          		push	h
0013+  C011 C5          		push	b
0014+  C012             
0015+  C012             		; Сохранение SP
0016+  C012 21 00 00    		lxi	h, 0
0017+  C015 39          		dad	sp
0018+  C016 22 F6 8F    		shld	v_oldSP
0019+  C019             
0020+  C019             		; Устанавливаем SP в конец видеопамяти
0021+  C019 31 00 C0    		lxi	sp, 0C000h
0022+  C01C             
0023+  C01C             		; Байт (слово) для заполнения памяти
0024+  C01C 2A FA 8F    		lhld	v_inverse
0025+  C01F             
0026+  C01F             		; Помещаем в стек 3000h байт
0027+  C01F 01 00 03    		lxi	b, 3000h / 16
0028+  C022 E5          clearScreen_0:	  push	h
0029+  C023 E5          		  push	h
0030+  C024 E5          		  push	h
0031+  C025 E5          		  push	h
0032+  C026 E5          		  push	h
0033+  C027 E5          		  push	h
0034+  C028 E5          		  push	h
0035+  C029 E5          		  push	h
0036+  C02A 0B          		  dcx	b
0037+  C02B 78          		  mov	a, b
0038+  C02C B1          		  ora	c
0039+  C02D C2 22 C0    		jnz	clearScreen_0
0040+  C030             
0041+  C030             		; Восстанавливаем SP
0042+  C030 2A F6 8F    		lhld	v_oldSP
0043+  C033 F9          		sphl
0044+  C034             
0045+  C034             		; bc, hl были сохранены. de - не используется
0046+  C034 C1          		pop	b
0047+  C035 E1          		pop	h
0048+  C036 C9          		ret
0049+  C037             
0085   C037             .include "printChar.inc"
0001+  C037             ;+---------------------------------------------------------------------------
0002+  C037             ; MXOS
0003+  C037             ; Вывод символа на экран (или принтер)
0004+  C037             ;
0005+  C037             ; На входе
0006+  C037             ;  с - символ
0007+  C037             ;
0008+  C037             ; На выходе
0009+  C037             ;  Все регистры сохраняются
0010+  C037             ;
0011+  C037             ; 2013-12-12 Дизассемблировано vinxru
0012+  C037             ;----------------------------------------------------------------------------
0013+  C037             
0014+  C037 F5          printChar:	push	psw
0015+  C038 D5          		push	d
0016+  C039 C5          		push	b
0017+  C03A E5          		push	h
0018+  C03B CD E9 C5    		call	printChar2
0019+  C03E E1          		pop	h
0020+  C03F C1          		pop	b
0021+  C040 D1          		pop	d
0022+  C041 F1          		pop	psw
0023+  C042 C9          		ret
0024+  C043             
0086   C043 2A FC       .db 2Ah, 0FCh
0087   C045             .include "printChar5.inc" ; Continued in drawChar
0001+  C045             ;+---------------------------------------------------------------------------
0002+  C045             ; MXOS
0003+  C045             ; Обработка служебных кодов при выводе символа (продолжение)
0004+  C045             ; Расчет адреса символа в знакогенераторе и адреса вывода на экран
0005+  C045             ;
0006+  C045             ; 2013-12-12 Дизассемблировано vinxru
0007+  C045             ;----------------------------------------------------------------------------
0008+  C045             
0009+  C045             ; ---------------------------------------------------------------------------
0010+  C045             ; Обработка ESC+(. Выключение KOI-7
0011+  C045             
0012+  C045 3E FF       printChar_e28:	mvi	a, 0FFh
0013+  C047 32 EA 8F    		sta	v_koi8
0014+  C04A C9          		ret
0015+  C04B             
0016+  C04B             ; ---------------------------------------------------------------------------
0017+  C04B             ; Обработка ESC+). Включение KOI-7
0018+  C04B             
0019+  C04B AF          printChar_e29:	xra	a
0020+  C04C 32 EA 8F    		sta	v_koi8
0021+  C04F C9          		ret
0022+  C050             
0023+  C050             ; ---------------------------------------------------------------------------
0024+  C050             ; Обработка кода 9. Табуляция
0025+  C050             
0026+  C050 3A FD 8F    printChar_c9:	lda	v_cursorX	
0027+  C053 C6 18       		adi	24
0028+  C055 32 FD 8F    		sta	v_cursorX
0029+  C058 C9          		ret
0030+  C059             
0031+  C059             ; ---------------------------------------------------------------------------
0032+  C059             ; Вывод символа С из знакогенартора по адресу HL*8 на экран в положение 
0033+  C059             ; курсора. Курсор при этом перемещается 
0034+  C059             
0035+  C059             printChar_alt:	; de = (hl+c)*8
0036+  C059 06 00       		mvi	b, 0
0037+  C05B 09          		dad	b
0038+  C05C 29          		dad	h
0039+  C05D 29          		dad	h
0040+  C05E 29          		dad	h
0041+  C05F EB          		xchg
0042+  C060             
0043+  C060             		; Продолжение в printChar_de
0044+  C060             
0045+  C060             ; ---------------------------------------------------------------------------
0046+  C060             ; Вывод символа DE на экран в положение курсора. Курсор при этом перемещается 
0047+  C060             ; вправо.
0048+  C060             
0049+  C060             printChar_de:	; Рассчитываем адрес вывода (hl=v_cursorPos, a*256+l=адрес)
0050+  C060 CD 29 C3    		call	calcCursorAddr
0051+  C063             
0052+  C063             		; Перемещаем курсор вправо
0053+  C063 24          		inr	h
0054+  C064 24          		inr	h
0055+  C065 24          		inr	h		
0056+  C066 22 FC 8F    		shld	v_cursorY
0057+  C069             
0058+  C069             		; Корректируем адрес вывода (bc = al - 7)
0059+  C069 47          		mov	b, a
0060+  C06A 7D          		mov	a, l
0061+  C06B D6 07       		sui	7
0062+  C06D 4F          		mov	c, a
0063+  C06E             
0064+  C06E             		; Продолжение в drawChar
0065+  C06E             
0088   C06E             .include "drawChar.inc"
0001+  C06E             ;+---------------------------------------------------------------------------
0002+  C06E             ; MXOS
0003+  C06E             ; Рисование символа на экране
0004+  C06E             ;
0005+  C06E             ; На входе 
0006+  C06E             ;  bc - адрес символа
0007+  C06E             ;  de - адрес в видеопамяти
0008+  C06E             ;  h  - координата X в пикселях / 2
0009+  C06E             ;
0010+  C06E             ; 2013-12-12 Дизассемблировано vinxru
0011+  C06E             ;----------------------------------------------------------------------------
0012+  C06E             
0013+  C06E             		; Высота символа
0014+  C06E 2E 08       		mvi	l, 8
0015+  C070             
0016+  C070             		; Переходим в одной из функций вывода
0017+  C070 7C          		mov	a, h
0018+  C071 E6 03       		ani	3
0019+  C073 CA B5 C0    		jz	drawChar0	; a==0
0020+  C076 3D          		dcr	a
0021+  C077 CA C5 C0    		jz	drawChar1	; a==1
0022+  C07A 3D          		dcr	a
0023+  C07B CA 82 C0    		jz	drawChar2	; a==2
0024+  C07E 3D          		dcr	a
0025+  C07F CA A3 C0    		jz	drawChar3	; a==3
0026+  C082             		; Продолжение на drawChar2
0027+  C082             
0028+  C082             ; ---------------------------------------------------------------------------
0029+  C082             
0030+  C082 0A          drawChar2:	ldax	b		
0031+  C083 E6 FC       		ani	0FCh
0032+  C085 67          		mov	h, a
0033+  C086 1A          		ldax	d		
0034+  C087 0F          		rrc
0035+  C088 0F          		rrc
0036+  C089 0F          		rrc
0037+  C08A 0F          		rrc
0038+  C08B 2F          drawChar2_cma:	cma
0039+  C08C F5          		push	psw
0040+  C08D E6 03       		ani	3
0041+  C08F AC          		xra	h
0042+  C090 02          		stax	b
0043+  C091 04          		inr	b
0044+  C092 0A          		ldax	b
0045+  C093 E6 0F       		ani	0Fh
0046+  C095 67          		mov	h, a
0047+  C096 F1          		pop	psw
0048+  C097 E6 F0       		ani	0F0h
0049+  C099 AC          		xra	h
0050+  C09A 02          		stax	b
0051+  C09B 05          		dcr	b
0052+  C09C             
0053+  C09C             		; Цикл
0054+  C09C 03          		inx	b
0055+  C09D 13          		inx	d
0056+  C09E 2D          		dcr	l
0057+  C09F C2 82 C0    		jnz	drawChar2
0058+  C0A2 C9          		ret
0059+  C0A3             
0060+  C0A3             ; ---------------------------------------------------------------------------
0061+  C0A3             
0062+  C0A3 0A          drawChar3:	ldax	b
0063+  C0A4 E6 03       		ani	3
0064+  C0A6 67          		mov	h, a
0065+  C0A7 1A          		ldax	d
0066+  C0A8 07          		rlc
0067+  C0A9 07          		rlc
0068+  C0AA EE FC       drawChar3_xri:	xri	0FCh
0069+  C0AC AC          		xra	h
0070+  C0AD 02          		stax	b
0071+  C0AE             
0072+  C0AE             		; Цикл
0073+  C0AE 13          		inx	d
0074+  C0AF 03          		inx	b
0075+  C0B0 2D          		dcr	l
0076+  C0B1 C2 A3 C0    		jnz	drawChar3
0077+  C0B4 C9          		ret
0078+  C0B5             
0079+  C0B5             ; ---------------------------------------------------------------------------
0080+  C0B5             
0081+  C0B5 0A          drawChar0:	ldax	b
0082+  C0B6 E6 C0       		ani	0C0h
0083+  C0B8 67          		mov	h, a
0084+  C0B9 1A          		ldax	d
0085+  C0BA EE 3F       drawChar0_xri:	xri	3Fh
0086+  C0BC AC          		xra	h
0087+  C0BD 02          		stax	b
0088+  C0BE             
0089+  C0BE             		; Цикл
0090+  C0BE 13          		inx	d
0091+  C0BF 03          		inx	b
0092+  C0C0 2D          		dcr	l
0093+  C0C1 C2 B5 C0    		jnz	drawChar0
0094+  C0C4 C9          		ret
0095+  C0C5             
0096+  C0C5             ; ---------------------------------------------------------------------------
0097+  C0C5             
0098+  C0C5 0A          drawChar1:	ldax	b
0099+  C0C6 E6 F0       		ani	0F0h
0100+  C0C8 67          		mov	h, a
0101+  C0C9 1A          		ldax	d
0102+  C0CA 0F          		rrc
0103+  C0CB 0F          		rrc
0104+  C0CC 2F          drawChar1_cma:	cma
0105+  C0CD E6 0F       		ani	0Fh
0106+  C0CF AC          		xra	h
0107+  C0D0 02          		stax	b
0108+  C0D1 04          		inr	b
0109+  C0D2 0A          		ldax	b
0110+  C0D3 E6 3F       		ani	3Fh
0111+  C0D5 67          		mov	h, a
0112+  C0D6 1A          		ldax	d
0113+  C0D7 0F          		rrc
0114+  C0D8 0F          		rrc
0115+  C0D9 2F          drawChar1_cma2:	cma
0116+  C0DA E6 C0       		ani	0C0h
0117+  C0DC AC          		xra	h
0118+  C0DD 02          		stax	b
0119+  C0DE 05          		dcr	b
0120+  C0DF             
0121+  C0DF             		; Цикл
0122+  C0DF 03          		inx	b
0123+  C0E0 13          		inx	d
0124+  C0E1 2D          		dcr	l
0125+  C0E2 C2 C5 C0    		jnz	drawChar1
0126+  C0E5 C9          		ret
0127+  C0E6             
0128+  C0E6             ; ---------------------------------------------------------------------------
0129+  C0E6             ; Вызывается из printChar_real2
0130+  C0E6             
0131+  C0E6             normalVideo:	; Меняем CZ normalVideo на CNZ inverseVideo
0132+  C0E6 21 02 C1    		lxi	h, inverseVideo
0133+  C0E9 22 26 C6    		shld	printChar_poly+1
0134+  C0EC 3E C4       		mvi	a, 0C4h
0135+  C0EE 32 25 C6    		sta	printChar_poly
0136+  C0F1             
0137+  C0F1             		; Аргумент XRI
0138+  C0F1 AF          		xra	a
0139+  C0F2 32 BB C0    		sta	drawChar0_xri+1
0140+  C0F5 32 AB C0    		sta	drawChar3_xri+1
0141+  C0F8             normalVideo_1:	; Меняем CMA на NOP
0142+  C0F8 32 8B C0    		sta	drawChar2_cma		
0143+  C0FB 32 CC C0    		sta	drawChar1_cma
0144+  C0FE 32 D9 C0    		sta	drawChar1_cma2
0145+  C101 C9          		ret
0146+  C102             
0147+  C102             ; ---------------------------------------------------------------------------
0148+  C102             ; Вызывается из printChar_real2
0149+  C102             
0150+  C102             inverseVideo:	; Меняем CNZ inverseVideo на CZ normalVideo
0151+  C102 21 E6 C0    		lxi	h, normalVideo
0152+  C105 22 26 C6    		shld	printChar_poly+1
0153+  C108 3E CC       		mvi	a, 0CCh		
0154+  C10A 32 25 C6    		sta	printChar_poly
0155+  C10D             
0156+  C10D             		; Меняем аргумент XRI
0157+  C10D 3E FC       		mvi	a, 0FCh
0158+  C10F 32 AB C0    		sta	drawChar3_xri+1
0159+  C112 3E 3F       		mvi	a, 3Fh
0160+  C114 32 BB C0    		sta	drawChar0_xri+1
0161+  C117             
0162+  C117             		; Меняем NOP на CMA
0163+  C117 3E 2F       		mvi	a, 2Fh
0164+  C119 C3 F8 C0    		jmp	normalVideo_1
0165+  C11C             
0089   C11C             .include "printChar3.inc"
0001+  C11C             ;+---------------------------------------------------------------------------
0002+  C11C             ; MXOS
0003+  C11C             ; Обработка служебных кодов при выводе символа
0004+  C11C             ;
0005+  C11C             ; На входе
0006+  C11C             ;  a - символ
0007+  C11C             ;
0008+  C11C             ; 2013-12-12 Дизассемблировано vinxru
0009+  C11C             ;----------------------------------------------------------------------------
0010+  C11C             
0011+  C11C             printChar3:	; Код 7
0012+  C11C D6 07       		sui	7
0013+  C11E CA 70 C1    		jz	beep
0014+  C121             		; Код 8
0015+  C121 3D          		dcr	a
0016+  C122 CA 4E C1    		jz	printChar_c08
0017+  C125             		; Код 10
0018+  C125 D6 02       		sui	2
0019+  C127 CA 96 C1    		jz	printChar_c0A
0020+  C12A             		; Код 12
0021+  C12A D6 02       		sui	2
0022+  C12C CA 46 C1    		jz	printChar_c0C
0023+  C12F             		; Код 13
0024+  C12F 3D          		dcr	a
0025+  C130 CA 48 C1    		jz	printChar_c0D
0026+  C133             		; Код 24
0027+  C133 D6 0B       		sui	11
0028+  C135 CA 64 C1    		jz	printChar_c18
0029+  C138             		; Код 25
0030+  C138 3D          		dcr	a
0031+  C139 CA 59 C1    		jz	printChar_c19
0032+  C13C             		; Код 26
0033+  C13C 3D          		dcr	a
0034+  C13D CA 98 C1    		jz	printChar_c1A
0035+  C140             		; Продолжение, если код 31
0036+  C140 D6 05       		sui	5
0037+  C142 C0          		rnz
0038+  C143             		; Код 31 очищает экран
0039+  C143 CD 10 C0    		call	clearScreen
0040+  C146             
0041+  C146             		; Продолжение в printChar_c0C
0042+  C146             
0043+  C146             ; ---------------------------------------------------------------------------
0044+  C146             ; Обработка кода 0Ch. Курсор в левый верхний угол экрана
0045+  C146             
0046+  C146             printChar_c0C:	; v_cursorY = 8
0047+  C146 2E 08       		mvi	l, 8
0048+  C148             
0049+  C148             		; Продолжение в printChar_c0D
0050+  C148             
0051+  C148             ; ---------------------------------------------------------------------------
0052+  C148             ; Обработка кода 0Dh. Курсор в начало строки
0053+  C148             
0054+  C148             printChar_c0D:	; v_cursorX = 0
0055+  C148 AF          		xra	a
0056+  C149 67          saveVCursorHA:	mov	h, a
0057+  C14A 22 FC 8F    saveVCursor:	shld	v_cursorY
0058+  C14D C9          		ret
0059+  C14E             
0060+  C14E             ; ---------------------------------------------------------------------------
0061+  C14E             ; Обработка кода 8h. Влево
0062+  C14E             
0063+  C14E             printChar_c08:	; cursorX -= 3
0064+  C14E 7C          		mov	a, h
0065+  C14F D6 03       		sui	3
0066+  C151             
0067+  C151             		; Если нет переноса, сохранить положение курсора и выйти
0068+  C151 D2 49 C1    		jnc	saveVCursorHA
0069+  C154             
0070+  C154             		; cursorX = 189
0071+  C154 26 BD       		mvi	h, 189
0072+  C156 22 FC 8F    		shld	v_cursorY
0073+  C159             
0074+  C159             		; Продолжение в printChar_c19
0075+  C159             
0076+  C159             ; ---------------------------------------------------------------------------
0077+  C159             ; Обработка кода 19h. Вверх
0078+  C159             
0079+  C159             printChar_c19:	; Если cursorY<18, то выйти. Иначе cursorY -= 10
0080+  C159 7D          		mov	a, l
0081+  C15A D6 0A       		sui	0Ah
0082+  C15C D8          		rc
0083+  C15D FE 08       		cpi	8
0084+  C15F D8          		rc
0085+  C160             
0086+  C160             saveVCursorLA:	; Сохранить положение курсора и выйти
0087+  C160 6F          		mov	l, a
0088+  C161 C3 4A C1    		jmp	saveVCursor
0089+  C164             
0090+  C164             ; ---------------------------------------------------------------------------
0091+  C164             ; Обработка кода 18h. Вправо
0092+  C164             
0093+  C164             printChar_c18:	; Если cursorX+3 >= 192, то перейти на printChar_c0A
0094+  C164             		; Иначе cursorX += 3
0095+  C164 7C          		mov	a, h
0096+  C165 C6 03       		adi	3
0097+  C167 FE C0       		cpi	0C0h
0098+  C169 DA 49 C1    		jc	saveVCursorHA
0099+  C16C C3 96 C1    		jmp	printChar_c0A
0100+  C16F             
0090   C16F FF          .db 0FFh
0091   C170             .include "beep.inc"
0001+  C170             ;+---------------------------------------------------------------------------
0002+  C170             ; MXOS
0003+  C170             ; Звуковой сигнал (вызывается при выводе кода 7)
0004+  C170             ;
0005+  C170             ; Все регистры сохраняются
0006+  C170             ;
0007+  C170             ; 2013-12-12 Дизассемблировано vinxru
0008+  C170             ;----------------------------------------------------------------------------
0009+  C170             
0010+  C170             beep:		; Сохраняем все регистры. DE не используется ниже
0011+  C170 F5          		push	psw
0012+  C171 C5          		push	b
0013+  C172 E5          		push	h
0014+  C173             
0015+  C173             		; Частота и длительность сигнала
0016+  C173 2A F1 8F    		lhld	v_beep
0017+  C176             
0018+  C176             beep_0:		; Единицу на динамик
0019+  C176 3E 0B       		mvi	a, 0Bh
0020+  C178 32 E3 FF    		sta	IO_KEYB_MODE
0021+  C17B             
0022+  C17B             		; Задержка L тактов
0023+  C17B CD 8F C1    		call	delay_l
0024+  C17E             
0025+  C17E             		; Ноль на динамик
0026+  C17E 3E 0A       		mvi	a, 0Ah
0027+  C180 32 E3 FF    		sta	IO_KEYB_MODE
0028+  C183             
0029+  C183             		; Задержка L тактов
0030+  C183 CD 8F C1    		call	delay_l
0031+  C186             
0032+  C186             		; Повторяем H раз
0033+  C186 25          		dcr	h
0034+  C187 C2 76 C1    		jnz	beep_0
0035+  C18A             
0036+  C18A             		; Ничего не делаем
0037+  C18A 00          		nop
0038+  C18B             
0039+  C18B             		; Восстаналиваем все регистры и выходим. DE не используется
0040+  C18B E1          		pop	h
0041+  C18C C1          		pop	b
0042+  C18D F1          		pop	psw
0043+  C18E C9          		ret
0044+  C18F             
0092   C18F             .include "delay_l.inc"
0001+  C18F             ;+---------------------------------------------------------------------------
0002+  C18F             ; MXOS
0003+  C18F             ; Задержка
0004+  C18F             ;
0005+  C18F             ; На входе
0006+  C18F             ;  l - задержка
0007+  C18F             ;
0008+  C18F             ; На выходе
0009+  C18F             ;  b - 0
0010+  C18F             ;
0011+  C18F             ; 2013-12-12 Дизассемблировано vinxru
0012+  C18F             ;----------------------------------------------------------------------------
0013+  C18F             
0014+  C18F 45          delay_l:	mov	b, l
0015+  C190 05          delay_l_0:	dcr	b
0016+  C191 C2 90 C1    		jnz	delay_l_0
0017+  C194 C9          		ret
0018+  C195             
0093   C195 C9          .db 0C9h
0094   C196             .include "printChar4.inc" ; Continued in scrollUp
0001+  C196             ;+---------------------------------------------------------------------------
0002+  C196             ; MXOS
0003+  C196             ; Обработка служебных кодов при выводе символа (продолжение)
0004+  C196             ;
0005+  C196             ; 2013-12-12 Дизассемблировано vinxru
0006+  C196             ;----------------------------------------------------------------------------
0007+  C196             
0008+  C196             ; ---------------------------------------------------------------------------
0009+  C196             ; Обработка кода 0Ah. Перевод строки
0010+  C196             
0011+  C196             printChar_c0A:	; cursorX = 0
0012+  C196 26 00       		mvi	h, 0
0013+  C198             
0014+  C198             		; Продолжение в printChar_c1A
0015+  C198             
0016+  C198             ; ---------------------------------------------------------------------------
0017+  C198             ; Обработка кода 1Ah. Вниз
0018+  C198             
0019+  C198             printChar_c1A:	; Если cursorY < 246, то cursorY += 10 и выход
0020+  C198 7D          		mov	a, l
0021+  C199 C6 0A       		adi	10
0022+  C19B D2 60 C1    		jnc	saveVCursorLA
0023+  C19E             
0024+  C19E             		; Сохраняем положение курсора (изменен только cursorX)
0025+  C19E 22 FC 8F    		shld	v_cursorY
0026+  C1A1             
0027+  C1A1             		; Далее прокрутка экрана вверх
0028+  C1A1             
0095   C1A1             .include "scrollUp.inc"
0001+  C1A1             ;+---------------------------------------------------------------------------
0002+  C1A1             ; MXOS
0003+  C1A1             ; Прокрутка экрана вверх
0004+  C1A1             ;
0005+  C1A1             ; На выходе
0006+  C1A1             ;   af, bc - сохраняются
0007+  C1A1             ;
0008+  C1A1             ; 2013-12-12 Дизассемблировано vinxru
0009+  C1A1             ;----------------------------------------------------------------------------
0010+  C1A1             
0011+  C1A1             		; Сохраняем регистры
0012+  C1A1 C5          		push	b
0013+  C1A2 F5          		push	psw
0014+  C1A3             
0015+  C1A3             		; Сохраняем SP
0016+  C1A3 21 00 00    		lxi	h, 0
0017+  C1A6 39          		dad	sp
0018+  C1A7 22 F6 8F    		shld	v_oldSP
0019+  C1AA             
0020+  C1AA             		; Прокрутка экрана вверх
0021+  C1AA 31 0A 90    		lxi	sp, 900Ah	; Откуда
0022+  C1AD 26 90       		mvi	h, 90h		; Куда
0023+  C1AF 06 30       		mvi	b, 48		; Столбцов
0024+  C1B1 C3 9E C7    		jmp	scrollUp2
0025+  C1B4             
0096   C1B4             
0097   C1B4             ; Buffer for character image from ROM
0098   C1B4 FF FF FF FF v_char:	.db 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh
0098   C1B8 FF FF FF FF 
0098   C1BC FF FF FF FF 
0098   C1C0 FF 
0099   C1C1             
0100   C1C1             .include "keyScan.inc"
0001+  C1C1             ;+---------------------------------------------------------------------------
0002+  C1C1             ; MXOS
0003+  C1C1             ; Получить код нажатой клавиши
0004+  C1C1             ;
0005+  C1C1             ; На выходе
0006+  C1C1             ;  a - код
0007+  C1C1             ;
0008+  C1C1             ; 2013-12-12 Дизассемблировано vinxru
0009+  C1C1             ;----------------------------------------------------------------------------
0010+  C1C1             
0011+  C1C1 3E 83       setKeybMode83:	mvi	a, 83h
0012+  C1C3 32 E3 FF    		sta	IO_KEYB_MODE
0013+  C1C6 C9          		ret
0014+  C1C7             
0015+  C1C7             ; ---------------------------------------------------------------------------
0016+  C1C7             
0017+  C1C7             keyScan2:	; Режим чтения ряда
0018+  C1C7 CD 54 C2    		call	setKeybMode82
0019+  C1CA             
0020+  C1CA             		; Одним чтением првоеряем все клавиши
0021+  C1CA 3A E1 FF    		lda	IO_KEYB_B	
0022+  C1CD             
0023+  C1CD             		; Эти биты не используются в сканировании
0024+  C1CD F6 03       		ori	3
0025+  C1CF             
0026+  C1CF             		; Ни одна клавиша не нажата
0027+  C1CF FE FF       		cpi	0FFh
0028+  C1D1 C8          		rz
0029+  C1D2             
0030+  C1D2             		; Сохраняем регистры
0031+  C1D2 E5          		push	h
0032+  C1D3 C5          		push	b
0033+  C1D4 D5          		push	d
0034+  C1D5             		
0035+  C1D5             		; Перебираем 12 столбцов кнопок
0036+  C1D5 21 FE 0F    		lxi	h, 0FFEh
0037+  C1D8 11 AB C4    		lxi	d, v_keybTbl + 11
0038+  C1DB 06 FF       		mvi	b, 0FFh
0039+  C1DD 7C          loc_C1DD:	mov	a, h
0040+  C1DE 32 E2 FF    		sta	IO_KEYB_C
0041+  C1E1 7D          		mov	a, l
0042+  C1E2 32 E0 FF    		sta	IO_KEYB_A
0043+  C1E5 0F          		rrc
0044+  C1E6 2F          		cma
0045+  C1E7 E6 04       		ani	4
0046+  C1E9 4F          		mov	c, a
0047+  C1EA 3A E1 FF    		lda	IO_KEYB_B
0048+  C1ED B1          		ora	c
0049+  C1EE             
0050+  C1EE             		; Перебираем 6 кнопок в столбце
0051+  C1EE 0E 06       		mvi	c, 6
0052+  C1F0 0F          		rrc
0053+  C1F1 0F          		rrc
0054+  C1F2 0F          loc_C1F2:	rrc
0055+  C1F3 D4 0C C2    		cnc	keybScan3
0056+  C1F6 0D          		dcr	c
0057+  C1F7 C2 F2 C1    		jnz	loc_C1F2
0058+  C1FA             
0059+  C1FA             		; Цикл
0060+  C1FA 1B          		dcx	d
0061+  C1FB 29          		dad	h
0062+  C1FC 23          		inx	h
0063+  C1FD 7C          		mov	a, h
0064+  C1FE C6 F0       		adi	0F0h
0065+  C200 67          		mov	h, a
0066+  C201 DA DD C1    		jc	loc_C1DD
0067+  C204             
0068+  C204             		; Режим ВВ55 по уполчанию
0069+  C204 CD 54 C2    		call	setKeybMode82
0070+  C207             
0071+  C207             		; Результат
0072+  C207 78          		mov	a, b
0073+  C208             
0074+  C208             		; Восстаналвиаем регистры
0075+  C208 D1          		pop	d
0076+  C209 C1          		pop	b
0077+  C20A E1          		pop	h
0078+  C20B C9          		ret
0079+  C20C             
0080+  C20C             ;----------------------------------------------------------------------------
0081+  C20C             
0082+  C20C D5          keybScan3:	push	d
0083+  C20D F5          		push	psw
0084+  C20E 3E 06       		mvi	a, 6		; e += (6 - c) * 16
0085+  C210 91          		sub	c
0086+  C211 87          		add	a
0087+  C212 87          		add	a
0088+  C213 87          		add	a
0089+  C214 87          		add	a
0090+  C215 83          		add	e
0091+  C216 5F          		mov	e, a
0092+  C217 1A          		ldax	d		; b = *de;
0093+  C218 47          		mov	b, a
0094+  C219 F1          		pop	psw
0095+  C21A D1          		pop	d
0096+  C21B C9          		ret
0097+  C21C             
0101   C21C             .include "getch2.inc"
0001+  C21C             ;----------------------------------------------------------------------------
0002+  C21C             ; MXOS
0003+  C21C             ; Ожидание ввода с клавиатуры
0004+  C21C             ;
0005+  C21C             ; На выходе
0006+  C21C             ;  ? - код
0007+  C21C             ;
0008+  C21C             ; 2013-12-12 Дизассемблировано vinxru
0009+  C21C             ;----------------------------------------------------------------------------
0010+  C21C             
0011+  C21C             getch2:		; Сохраняем регистры
0012+  C21C E5          		push	h
0013+  C21D C5          		push	b
0014+  C21E D5          		push	d
0015+  C21F             
0016+  C21F             		; Получаем код нажатой клавиши и сохраняем его в v_lastKey
0017+  C21F CD C7 C1    		call	keyScan2
0018+  C222 32 F0 8F    		sta	v_lastKey
0019+  C225             
0020+  C225             getch_retry:	; Тут будет признак, нарисован курсор или нет
0021+  C225 0E 01       		mvi	c, 1
0022+  C227             
0023+  C227             loc_C227:	; Рисуем курсор
0024+  C227 CD 4D C3    		call	drawCursor2
0025+  C22A             
0026+  C22A             		; Задержка
0027+  C22A 3A F4 8F    		lda	v_cursorDelay
0028+  C22D 06 40       loc_C22D:	mvi	b, 40h
0029+  C22F CD 90 C1    		call	delay_l_0
0030+  C232 3D          		dcr	a
0031+  C233 C2 2D C2    		jnz	loc_C22D
0032+  C236             
0033+  C236             loc_C236:	; Рисуем/стираем курсор
0034+  C236 CD 48 C3    		call	drawCursor
0035+  C239             		
0036+  C239             		; Задержка мерцания курсора
0037+  C239 11 00 05    		lxi	d, 500h
0038+  C23C             
0039+  C23C             loc_C23C:	; Получаем код нажатой клавиши
0040+  C23C CD C7 C1    		call	keyScan2
0041+  C23F FE 80       		cpi	80h		; х.з.
0042+  C241 FE FF       		cpi	0FFh
0043+  C243 C2 60 C2    		jnz	getch2_pressed
0044+  C246             
0045+  C246             		; Записываем v_lastKey=0FFh
0046+  C246 32 F0 8F    		sta	v_lastKey
0047+  C249             
0048+  C249             		; Повторяем 500h раз
0049+  C249 1B          		dcx	d
0050+  C24A 7A          		mov	a, d
0051+  C24B B3          		ora	e
0052+  C24C C2 3C C2    		jnz	loc_C23C
0053+  C24F             
0054+  C24F             		; Повтор всего
0055+  C24F C3 36 C2    		jmp	loc_C236
0056+  C252             
0057+  C252             ; ---------------------------------------------------------------------------
0058+  C252             
0059+  C252 FF FF       .db 0FFh, 0FFh
0060+  C254             
0061+  C254             ; ---------------------------------------------------------------------------
0062+  C254             
0063+  C254 3E 82       setKeybMode82:	mvi	a, 82h
0064+  C256 32 E3 FF    		sta	IO_KEYB_MODE
0065+  C259 C9          		ret
0066+  C25A             
0067+  C25A             ; ---------------------------------------------------------------------------
0068+  C25A             
0069+  C25A 3E 91       setKeybMode91:	mvi	a, 91h
0070+  C25C 32 E3 FF    		sta	IO_KEYB_MODE
0071+  C25F C9          		ret
0072+  C260             
0073+  C260             ; ---------------------------------------------------------------------------
0074+  C260             ; Была нажата клавиша
0075+  C260             
0076+  C260             getch2_pressed:	; Сохраняем код
0077+  C260 47          		mov	b, a
0078+  C261             
0079+  C261             		; Если нарисован курсор, стираем его
0080+  C261 79          		mov	a, c
0081+  C262 0F          		rrc
0082+  C263 DA 69 C2    		jc	loc_C269
0083+  C266 CD 4D C3    		call	drawCursor2
0084+  C269             loc_C269:	
0085+  C269 2A EF 8F    		lhld	v_lastLastKey	; h = v_lastKey, l = v_lastLastKey
0086+  C26C 78          		mov	a, b		; a = b = код нажатой клавиши
0087+  C26D BC          		cmp	h
0088+  C26E C2 8D C2    		jnz	loc_C28D	; Код нажатой клавиши изменился
0089+  C271 BD          		cmp	l
0090+  C272 CA 95 C2    		jz	loc_C295
0091+  C275             
0092+  C275             		; Рисуем курсор
0093+  C275 CD 48 C3    		call	drawCursor
0094+  C278             
0095+  C278             		; Ждем, пока отпустят клавишу
0096+  C278 3A F5 8F    		lda	byte_8FF5
0097+  C27B 57          		mov	d, a
0098+  C27C CD C7 C1    loc_C27C:	call	keyScan2
0099+  C27F BC          		cmp	h
0100+  C280 C2 27 C2    		jnz	loc_C227	; Быстро нажали другую клавишу
0101+  C283 15          		dcr	d
0102+  C284 C2 7C C2    		jnz	loc_C27C
0103+  C287             
0104+  C287             		; Долго держали
0105+  C287             
0106+  C287             		; Стираем курсор
0107+  C287 CD 48 C3    		call	drawCursor
0108+  C28A             
0109+  C28A C3 90 C2    		jmp	loc_C290
0110+  C28D             ; ---------------------------------------------------------------------------
0111+  C28D             
0112+  C28D             loc_C28D:	; Звуковой сигнал
0113+  C28D CD 70 C1    		call	beep
0114+  C290             
0115+  C290             loc_C290:	;
0116+  C290 6C          		mov	l, h
0117+  C291 60          		mov	h, b	; код нажатой и предыдущей клавиши сохраняем в v_lastKey
0118+  C292 22 EF 8F    		shld	v_lastLastKey
0119+  C295             
0120+  C295             loc_C295:	; Не служеюбные клавиши CAPS LOCK, SHIFT и РУС/LAT не влияют
0121+  C295 78          		mov	a, b
0122+  C296 FE 21       		cpi	21h
0123+  C298 DA 10 C3    		jc	getch_noShift   
0124+  C29B                             ; На клавиши c кодами 21h-3Fh влияет SHIFT
0125+  C29B FE 40       		cpi	40h
0126+  C29D DA FE C2    		jc	getch_shift 
0127+  C2A0                             ; На символьные клавиши (40h-7Eh) влияют CAPS LOCK, SHIFT и РУС/LAT
0128+  C2A0 FE 7F       		cpi	7Fh
0129+  C2A2 DA DE C2    		jc	getch_chars
0130+  C2A5                             ; Не служеюбные клавиши (7Fh+) CAPS LOCK, SHIFT и РУС/LAT не влияют
0131+  C2A5 CA 10 C3    		jz	getch_noShift
0132+  C2A8             
0133+  C2A8             		; ...
0134+  C2A8 00          		nop
0135+  C2A9 00          		nop
0136+  C2AA             
0137+  C2AA                             ; Переходим, если код клавиши не 81h
0138+  C2AA FE 81       		cpi	81h
0139+  C2AC C2 10 C3    		jnz	getch_noShift
0140+  C2AF             
0141+  C2AF                             ; Код клавиши 81h
0142+  C2AF             
0143+  C2AF             		; Если шифт не нажат
0144+  C2AF 3A E1 FF    		lda	IO_KEYB_B
0145+  C2B2 E6 02       		ani	2
0146+  C2B4 C2 8D C5    		jnz	loc_C55C
0147+  C2B7             
0148+  C2B7                             ; Код клавиши 81h с шифтом
0149+  C2B7             
0150+  C2B7             		; Звуковой сигнал
0151+  C2B7 CD 70 C1    		call	beep
0152+  C2BA             
0153+  C2BA             		; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
0154+  C2BA C3 CC C5    		jmp	getch_rc
0155+  C2BD             
0156+  C2BD             ; ---------------------------------------------------------------------------
0157+  C2BD             ; Нажата комбинация РУС/LAT
0158+  C2BD             
0159+  C2BD             getch_rusLat:	; на входе a = v_keyLocks
0160+  C2BD EE 81       		xri	81h
0161+  C2BF 32 EC 8F    		sta	v_keyLocks
0162+  C2C2             
0163+  C2C2             		; Особый звуковой сигнал
0164+  C2C2 3A F1 8F    		lda	v_beep
0165+  C2C5 F5          		push	psw
0166+  C2C6 3E 4F       		mvi	a, 4Fh
0167+  C2C8 32 F1 8F    		sta	v_beep
0168+  C2CB CD 70 C1    		call	beep
0169+  C2CE 3E 5F       		mvi	a, 5Fh
0170+  C2D0 32 F1 8F    		sta	v_beep
0171+  C2D3 CD 70 C1    		call	beep
0172+  C2D6 F1          		pop	psw
0173+  C2D7 32 F1 8F    		sta	v_beep
0174+  C2DA             
0175+  C2DA             		; ...
0176+  C2DA 00          		nop
0177+  C2DB             
0178+  C2DB C3 25 C2    		jmp	getch_retry
0179+  C2DE             
0180+  C2DE             ; ---------------------------------------------------------------------------
0181+  C2DE             ; Включаем кирилицу или строчные буквы
0182+  C2DE             
0183+  C2DE             getch_chars:	; Если не нажат CAPS LOCK, пропускаем код ниже
0184+  C2DE 3A EC 8F    		lda	v_keyLocks
0185+  C2E1 4F          		mov	c, a
0186+  C2E2 A7          		ana	a
0187+  C2E3 FA EA C2    		jm	loc_C2EA	; CAPS LOCK
0188+  C2E6             
0189+  C2E6             		; Превращаем заглавные в строчные
0190+  C2E6 78          		mov	a, b
0191+  C2E7 EE 20       		xri	20h
0192+  C2E9 47          		mov	b, a
0193+  C2EA             
0194+  C2EA             loc_C2EA:	; Если зафиксирвоан ли РУС/ЛАТ, помещаем в C=1
0195+  C2EA 79          		mov	a, c
0196+  C2EB E6 01       		ani	1
0197+  C2ED 4F          		mov	c, a
0198+  C2EE             
0199+  C2EE             		; Если шифт нажат, помещаем в A=0
0200+  C2EE 3A E1 FF    		lda	IO_KEYB_B
0201+  C2F1 E6 02       		ani	2
0202+  C2F3 0F          		rrc				;! Как на счет флага C ?
0203+  C2F4             
0204+  C2F4             		; Превращаем английские символы в русские если A^C==0
0205+  C2F4 A9          		xra	c
0206+  C2F5 78          		mov	a, b
0207+  C2F6 C2 D9 C5    		jnz	loc_C5A8
0208+  C2F9 C6 80       		adi	80h
0209+  C2FB C3 D9 C5    		jmp	loc_C5A8
0210+  C2FE             
0211+  C2FE             ; ---------------------------------------------------------------------------
0212+  C2FE             ; Меняем цифры на символы
0213+  C2FE             
0214+  C2FE             getch_shift:	; Если не нажат шифт, пропускаем код ниже
0215+  C2FE 3A E1 FF    		lda	IO_KEYB_B
0216+  C301 E6 02       		ani	2
0217+  C303 78          		mov	a, b
0218+  C304 C2 D9 C5    		jnz	loc_C5A8
0219+  C307             
0220+  C307             		; Меняем цифры на символы
0221+  C307 EE 10       		xri	10h
0222+  C309             
0223+  C309             		; Одно исключение 30h должен меняться на 5Fh
0224+  C309 FE 20       		cpi	20h
0225+  C30B C2 10 C3    		jnz	getch_noShift
0226+  C30E 3E 5F       		mvi	a, 5Fh
0227+  C310             
0228+  C310             		; Прододжение getch_noShift
0229+  C310             
0230+  C310             ; ---------------------------------------------------------------------------
0231+  C310             ; Символы без изменений
0232+  C310             
0233+  C310             getch_noShift:  ; Сохраняем код нажатой клавиши в B     
0234+  C310 47          		mov	b, a
0235+  C311             
0236+  C311 CD C1 C1    loc_C311:	call	setKeybMode83
0237+  C314 3E F7       		mvi	a, 0F7h
0238+  C316 32 E0 FF    		sta	IO_KEYB_A
0239+  C319 3A E1 FF    		lda	IO_KEYB_B
0240+  C31C 2F          		cma
0241+  C31D 0F          		rrc
0242+  C31E 0F          		rrc
0243+  C31F 0F          		rrc
0244+  C320 CD 54 C2    		call	setKeybMode82
0245+  C323 00          		nop
0246+  C324             
0247+  C324             		; Восстаналиваем код нажатой клавиши
0248+  C324 78          		mov	a, b
0249+  C325             
0250+  C325             popa_ret_2:	; Восстаналиваем регистры и выходим
0251+  C325 D1          		pop	d
0252+  C326 C1          		pop	b
0253+  C327 E1          		pop	h
0254+  C328 C9          		ret
0255+  C329             
0102   C329             .include "calcCursorAddr.inc"
0001+  C329             ;+---------------------------------------------------------------------------
0002+  C329             ; MXOS
0003+  C329             ; Расчет адреса курсора в видеопамяти. И перевод строки, если курсор был
0004+  C329             ; за правым краем экрана.
0005+  C329             ;
0006+  C329             ; На выходе
0007+  C329             ;  hl - координаты курсора
0008+  C329             ;  a * 256 + l - адрес в видеопамяти
0009+  C329             ;
0010+  C329             ; 2013-12-12 Дизассемблировано vinxru
0011+  C329             ;----------------------------------------------------------------------------
0012+  C329             
0013+  C329             calcCursorAddr:	; В HL положение курсора
0014+  C329 2A FC 8F    		lhld	v_cursorY
0015+  C32C             
0016+  C32C             		; Если cursorX >= 190, то перевод строки (вывод кода 10)
0017+  C32C             		; Иначе рассчитываем адрес старшего байта a = cursorX / 4 + 90h
0018+  C32C 7C          		mov	a, h
0019+  C32D FE BE       		cpi	190
0020+  C32F DA 41 C3    		jc	calcCursorAd_1
0021+  C332 0E 0A       		mvi	c, 10
0022+  C334 C3 3A C3    		jmp	calcCursorAd_0
0023+  C337             
0103   C337             .include "getch.inc"
0001+  C337             ;----------------------------------------------------------------------------
0002+  C337             ; MXOS
0003+  C337             ; Ожидание ввода с клавиатуры
0004+  C337             ;
0005+  C337             ; На выходе
0006+  C337             ;  ? - код
0007+  C337             ;
0008+  C337             ; 2013-12-12 Дизассемблировано vinxru
0009+  C337             ;----------------------------------------------------------------------------
0010+  C337             
0011+  C337 C3 1C C2    getch:		jmp	getch2
0012+  C33A             
0104   C33A             .include "calcCursorAddr2.inc"
0001+  C33A             ;+---------------------------------------------------------------------------
0002+  C33A             ; MXOS
0003+  C33A             ; Расчет адреса курсора в видеопамяти (продолжение);
0004+  C33A             ;
0005+  C33A             ; 2013-12-12 Дизассемблировано vinxru
0006+  C33A             ;----------------------------------------------------------------------------
0007+  C33A             
0008+  C33A             calcCursorAd_0:	; Перевод строки (на входе C=10)
0009+  C33A CD 37 C0    		call	printChar
0010+  C33D             
0011+  C33D             		; Восстановление регистров после printChar (хотя он не портит регистры)
0012+  C33D 2A FC 8F    		lhld	v_cursorY
0013+  C340 7C          		mov	a, h
0014+  C341             
0015+  C341             calcCursorAd_1:	; Расчет старшего байта адреса
0016+  C341             		; a = cursorX / 4 + 90h		
0017+  C341 0F          		rrc
0018+  C342 0F          		rrc
0019+  C343 E6 3F       		ani	3Fh
0020+  C345 C6 90       		adi	90h
0021+  C347 C9          		ret
0022+  C348             
0105   C348             .include "drawCursor.inc"
0001+  C348             ;+---------------------------------------------------------------------------
0002+  C348             ; MXOS
0003+  C348             ; Рисование курсора на экране
0004+  C348             ;
0005+  C348             ; На выходе
0006+  C348             ;  bc,de,hl - сохраняются
0007+  C348             ;
0008+  C348             ; 2013-12-12 Дизассемблировано vinxru
0009+  C348             ;----------------------------------------------------------------------------
0010+  C348             
0011+  C348             drawCursor:	; Если установлен 7-ой бит v_cursorCfg & 0x80, выходим
0012+  C348 3A E9 8F    		lda	v_cursorCfg
0013+  C34B A7          		ana	a
0014+  C34C F8          		rm
0015+  C34D             
0016+  C34D             drawCursor2:	; Курсор нарисован/стерт
0017+  C34D 0C          		inr	c
0018+  C34E             		
0019+  C34E             drawCursor3:	; Сохраняем регистры
0020+  C34E E5          		push	h
0021+  C34F C5          		push	b
0022+  C350 D5          		push	d
0023+  C351             
0024+  C351             		; Рассчитываем адрес на экране
0025+  C351 CD 29 C3    		call	calcCursorAddr
0026+  C354 57          		mov	d, a
0027+  C355             
0028+  C355             		; Положение курсора от +2 до -5 (при битах 654 от 0 до 7)
0029+  C355             		; b = v_cursorCfg
0030+  C355             		; e = ~((v_cursorCfg / 16) % 8 - 3) + l
0031+  C355 3A E9 8F    		lda	v_cursorCfg
0032+  C358 47          		mov	b, a
0033+  C359 0F          		rrc
0034+  C35A 0F          		rrc
0035+  C35B 0F          		rrc
0036+  C35C 0F          		rrc
0037+  C35D E6 07       		ani	7
0038+  C35F D6 03       		sui	3
0039+  C361 2F          		cma
0040+  C362 85          		add	l
0041+  C363 5F          		mov	e, a
0042+  C364             
0043+  C364             		; Рассчитыаем маску курсора
0044+  C364             		;  hl = 011111100b << (((~h) % 4 +1)*2)
0045+  C364 7C          		mov	a, h
0046+  C365 2F          		cma
0047+  C366 E6 03       		ani	3
0048+  C368 21 FC 00    		lxi	h, 011111100b ; FCh
0049+  C36B 3C          		inr	a
0050+  C36C 29          drawCursor_0:	dad	h
0051+  C36D 29          		dad	h
0052+  C36E C3 43 C4    		jmp	drawCursor_1
0053+  C371             
0106   C371             .include "tapeWriteDelay.inc"
0001+  C371             ;+---------------------------------------------------------------------------
0002+  C371             ; MXOS
0003+  C371             ; Задержка при записи на ленту 
0004+  C371             ;
0005+  C371             ; 2013-12-12 Дизассемблировано vinxru
0006+  C371             ;----------------------------------------------------------------------------
0007+  C371             
0008+  C371 3A FE 8F    writeDelay:	lda	v_writeDelay
0009+  C374 C3 CC C3    		jmp	delay_a
0010+  C377             
0107   C377             .include "tapeRead.inc"
0001+  C377             ;+---------------------------------------------------------------------------
0002+  C377             ; MXOS
0003+  C377             ; Чтение байта с ленты
0004+  C377             ;
0005+  C377             ; На входе
0006+  C377             ;  a=255 загрузка первого байта 
0007+  C377             ;  a=8   загрузка
0008+  C377             ;
0009+  C377             ; На выходе
0010+  C377             ;  c - байт
0011+  C377             ;  de,hl - сохраняются
0012+  C377             ;
0013+  C377             ; 2013-12-12 Дизассемблировано vinxru
0014+  C377             ;----------------------------------------------------------------------------
0015+  C377             
0016+  C377             tapeRead:	; Сохраняем регистры
0017+  C377 C5          		push	b
0018+  C378 D5          		push	d
0019+  C379             
0020+  C379             		; Тут будет принятый байт
0021+  C379 0E 00       		mvi	c, 0
0022+  C37B             
0023+  C37B             		; d=8 если загрузка (счетчик бит) или 0FFh если ожидание
0024+  C37B 57          		mov	d, a
0025+  C37C             
0026+  C37C             tapeRead_0:	; Получаем состояние
0027+  C37C 3A E1 FF    		lda	IO_KEYB_B
0028+  C37F E6 01       		ani	1
0029+  C381 5F          		mov	e, a
0030+  C382             
0031+  C382             		; Сдвигаем C
0032+  C382 79          		mov	a, c
0033+  C383 E6 7F       		ani	7Fh
0034+  C385 07          		rlc
0035+  C386 4F          		mov	c, a
0036+  C387             
0037+  C387             tapeRead_1:	; Получаем состояние
0038+  C387 3A E1 FF    		lda	IO_KEYB_B
0039+  C38A             
0040+  C38A             		; Если нажата клавиша, выходим
0041+  C38A FE 80       		cpi	80h
0042+  C38C DA 78 C4    		jc	tapeReadError
0043+  C38F             
0044+  C38F             		; Ждем изменения сигнала
0045+  C38F E6 01       		ani	1
0046+  C391 BB          		cmp	e
0047+  C392 CA 87 C3    		jz	tapeRead_1
0048+  C395             
0049+  C395             		; Сохраняем бит
0050+  C395 B1          		ora	c
0051+  C396 4F          		mov	c, a
0052+  C397             
0053+  C397             		; Задержка
0054+  C397 CD C9 C3    		call	readDelay
0055+  C39A             
0056+  C39A 3A E1 FF    		lda	IO_KEYB_B
0057+  C39D E6 01       		ani	1
0058+  C39F 5F          		mov	e, a
0059+  C3A0             
0060+  C3A0             		; Если происходит загрузка данных, переходим на tapeRead_4
0061+  C3A0 7A          		mov	a, d
0062+  C3A1 B7          		ora	a
0063+  C3A2 F2 BE C3    		jp	tapeRead_4
0064+  C3A5             
0065+  C3A5             		; Если происходит ожидание
0066+  C3A5             		; Если не найден 0E6h, переходим tapeRead_2
0067+  C3A5 79          		mov	a, c		
0068+  C3A6 FE E6       		cpi	0E6h
0069+  C3A8 C2 B2 C3    		jnz	tapeRead_2
0070+  C3AB             
0071+  C3AB             		; Начинаем загрузку без инверсии
0072+  C3AB AF          		xra	a
0073+  C3AC 32 F3 8F    		sta	v_tapeInverse
0074+  C3AF C3 BC C3    		jmp	tapeRead_3
0075+  C3B2             
0076+  C3B2             tapeRead_2:	; Если не найден 19h, переходим на tapeRead_0
0077+  C3B2 FE 19       		cpi	19h
0078+  C3B4 C2 7C C3    		jnz	tapeRead_0
0079+  C3B7             
0080+  C3B7             		; Начинаем загрузку с инверсией
0081+  C3B7 3E FF       		mvi	a, 0FFh
0082+  C3B9 32 F3 8F    		sta	v_tapeInverse
0083+  C3BC             
0084+  C3BC             		; Загружаем 8 бит
0085+  C3BC 16 09       tapeRead_3:	mvi	d, 9
0086+  C3BE             
0087+  C3BE             		; Повторяем 8 байт
0088+  C3BE 15          tapeRead_4:	dcr	d
0089+  C3BF C2 7C C3    		jnz	tapeRead_0
0090+  C3C2             
0091+  C3C2             		; Инверсия байта
0092+  C3C2 3A F3 8F    		lda	v_tapeInverse
0093+  C3C5 A9          		xra	c
0094+  C3C6             
0095+  C3C6             		; Восстаналиваем регистры
0096+  C3C6 D1          		pop	d
0097+  C3C7 C1          		pop	b
0098+  C3C8 C9          		ret
0099+  C3C9             
0108   C3C9             .include "tapeReadDelay.inc"
0001+  C3C9             ;+---------------------------------------------------------------------------
0002+  C3C9             ; MXOS
0003+  C3C9             ; Задержка при чтении с ленты
0004+  C3C9             ;
0005+  C3C9             ; 2013-12-12 Дизассемблировано vinxru
0006+  C3C9             ;----------------------------------------------------------------------------
0007+  C3C9             
0008+  C3C9 3A FF 8F    readDelay:	lda	v_readDelay
0009+  C3CC 47          delay_a:	mov	b, a
0010+  C3CD C3 90 C1    		jmp	delay_l_0
0011+  C3D0             
0109   C3D0             .include "tapeWrite.inc"
0001+  C3D0             ;+---------------------------------------------------------------------------
0002+  C3D0             ; MXOS
0003+  C3D0             ; Запись байта на ленту
0004+  C3D0             ;
0005+  C3D0             ; На входе 
0006+  C3D0             ;   a - байт
0007+  C3D0             ;
0008+  C3D0             ; На выходе
0009+  C3D0             ;   все регистры сохраняются
0010+  C3D0             ;
0011+  C3D0             ; 2013-12-12 Дизассемблировано vinxru
0012+  C3D0             ;----------------------------------------------------------------------------
0013+  C3D0             
0014+  C3D0             tapeWrite:	; Сохранение регистров
0015+  C3D0 C5          		push	b
0016+  C3D1 D5          		push	d
0017+  C3D2 F5          		push	psw
0018+  C3D3             
0019+  C3D3 57          		mov	d, a
0020+  C3D4             
0021+  C3D4             		; Надо записть 8 бит
0022+  C3D4 0E 08       		mvi	c, 8		
0023+  C3D6             
0024+  C3D6             tapeWrite_1:	; Сдвинуть D
0025+  C3D6 7A          		mov	a, d
0026+  C3D7 07          		rlc
0027+  C3D8 57          		mov	d, a
0028+  C3D9             
0029+  C3D9             		; Вывести бит на ленту
0030+  C3D9 E6 01       		ani	1
0031+  C3DB F6 0E       		ori	0Eh
0032+  C3DD 32 E3 FF    		sta	IO_KEYB_MODE
0033+  C3E0 5F          		mov	e, a
0034+  C3E1             
0035+  C3E1             		; Задержка
0036+  C3E1 CD 71 C3    		call	writeDelay
0037+  C3E4             
0038+  C3E4             		; Вывести инверсный бит на магнитофон
0039+  C3E4 7B          		mov	a, e
0040+  C3E5 EE 01       		xri	1
0041+  C3E7 32 E3 FF    		sta	IO_KEYB_MODE
0042+  C3EA             
0043+  C3EA             		; Задержка
0044+  C3EA CD 71 C3    		call	writeDelay
0045+  C3ED             
0046+  C3ED             		; Повторить 8 раз
0047+  C3ED 0D          		dcr	c
0048+  C3EE C2 D6 C3    		jnz	tapeWrite_1
0049+  C3F1             
0050+  C3F1             		; Восстановление регистров и выход
0051+  C3F1 F1          		pop	psw
0052+  C3F2 D1          		pop	d
0053+  C3F3 C1          		pop	b
0054+  C3F4 C9          		ret
0055+  C3F5             
0110   C3F5 00 00 00 00 .db 0, 0, 0, 0
0111   C3F9             .include "tapeLoadInt.inc"
0001+  C3F9             ;+---------------------------------------------------------------------------
0002+  C3F9             ; MXOS
0003+  C3F9             ; Загрузка программы с ленты. КС не загружается.
0004+  C3F9             ;
0005+  C3F9             ; В случае ошибки управление передается по адресу в v_tapeError
0006+  C3F9             ;
0007+  C3F9             ; На выходе 
0008+  C3F9             ;  v_tapeAddr - адрес загруженной программы
0009+  C3F9             ;
0010+  C3F9             ; 2013-12-12 Дизассемблировано vinxru
0011+  C3F9             ;----------------------------------------------------------------------------
0012+  C3F9             
0013+  C3F9             tapeLoadInt:	; Ждем пилот-тон и читаем слово - это адрес загрузки программы
0014+  C3F9 3E FF       		mvi	a, 0FFh
0015+  C3FB CD 77 C3    		call	tapeRead		
0016+  C3FE 6F          		mov	l, a
0017+  C3FF 3E 08       		mvi	a, 8
0018+  C401 CD 77 C3    		call	tapeRead
0019+  C404 67          		mov	h, a
0020+  C405 22 E3 8F    		shld	v_tapeAddr
0021+  C408             
0022+  C408             		; Читаем следующее слово - это конец программы
0023+  C408 3E 08       		mvi	a, 8
0024+  C40A CD 77 C3    		call	tapeRead
0025+  C40D 5F          		mov	e, a
0026+  C40E 3E 08       		mvi	a, 8
0027+  C410 CD 77 C3    		call	tapeRead
0028+  C413 57          		mov	d, a
0029+  C414             
0030+  C414             		; Читаем тело программы
0031+  C414 3E 08       loc_C414:	mvi	a, 8		
0032+  C416 CD 77 C3    loc_C416:	call	tapeRead
0033+  C419 77          		mov	m, a
0034+  C41A CD 27 C4    		call	cmp_hl_de
0035+  C41D 23          		inx	h
0036+  C41E C2 14 C4    		jnz	loc_C414
0037+  C421             
0038+  C421             		; Выходим не запуская
0039+  C421 C9          		ret
0040+  C422             
0041+  C422             ; ---------------------------------------------------------------------------
0042+  C422             ; Не используется
0043+  C422             
0044+  C422 3E FF       tapeLoadAny:	mvi	a, 0FFh
0045+  C424 C3 16 C4    		jmp	loc_C416
0046+  C427             
0112   C427             .include "cmp_hl_de.inc"
0001+  C427             ;+---------------------------------------------------------------------------
0002+  C427             ; MXOS
0003+  C427             ; Сравнить HL и DE
0004+  C427             ;
0005+  C427             ; 2013-12-12 Дизассемблировано vinxru
0006+  C427             ;----------------------------------------------------------------------------
0007+  C427             
0008+  C427 7C          cmp_hl_de:	mov	a, h
0009+  C428 BA          		cmp	d
0010+  C429 C0          		rnz
0011+  C42A 7D          		mov	a, l
0012+  C42B BB          		cmp	e
0013+  C42C C9          		ret
0014+  C42D             
0113   C42D             .include "memcpy_bc_hl.inc"
0001+  C42D             ;+---------------------------------------------------------------------------
0002+  C42D             ; MXOS
0003+  C42D             ; Скопировать блок памяти
0004+  C42D             ;
0005+  C42D             ; На входе
0006+  C42D             ;  hl - откуда начало
0007+  C42D             ;  de - откуда конец + 1
0008+  C42D             ;  (de-hl) - длина
0009+  C42D             ;  bc - куда
0010+  C42D             ;
0011+  C42D             ; На выходе
0012+  C42D             ;  de - сохраняется
0013+  C42D             ;
0014+  C42D             ; 2013-12-12 Дизассемблировано vinxru
0015+  C42D             ;----------------------------------------------------------------------------
0016+  C42D             
0017+  C42D 7E          memcpy_bc_hl:	mov	a, m
0018+  C42E 02          		stax	b
0019+  C42F 23          		inx	h
0020+  C430 03          		inx	b
0021+  C431 CD 27 C4    		call	cmp_hl_de
0022+  C434 C2 2D C4    		jnz	memcpy_bc_hl
0023+  C437 C9          		ret
0024+  C438             
0114   C438             .include "printString1.inc"
0001+  C438             ;+---------------------------------------------------------------------------
0002+  C438             ; MXOS
0003+  C438             ; Вывод строки на экран
0004+  C438             ;
0005+  C438             ; На входе
0006+  C438             ;  hl - строка
0007+  C438             ;
0008+  C438             ; На выходе
0009+  C438             ;  af, bc, de - сохраняются
0010+  C438             ;
0011+  C438             ; 2013-12-12 Дизассемблировано vinxru
0012+  C438             ;----------------------------------------------------------------------------
0013+  C438             
0014+  C438 C3 26 C5    printString1:	jmp	printString
0015+  C43B             
0115   C43B             .include "printChar6.inc"
0001+  C43B             ;+---------------------------------------------------------------------------
0002+  C43B             ; MXOS
0003+  C43B             ; Обработка служебных кодов при выводе символа (продолжение)
0004+  C43B             ;
0005+  C43B             ; 2013-12-12 Дизассемблировано vinxru
0006+  C43B             ;----------------------------------------------------------------------------
0007+  C43B             
0008+  C43B             ; ---------------------------------------------------------------------------
0009+  C43B             ; Обработка ESC+F
0010+  C43B             
0011+  C43B 3E 80       printChar_eF:	mvi	a, 80h
0012+  C43D 32 EB 8F    		sta	v_escMode
0013+  C440 C9          		ret
0014+  C441             
0116   C441 00 00       .db 0, 0
0117   C443             .include "drawCursor2.inc"
0001+  C443             ;+---------------------------------------------------------------------------
0002+  C443             ; MXOS
0003+  C443             ; Рисование курсора на экране (продолжение)
0004+  C443             ;
0005+  C443             ; 2013-12-12 Дизассемблировано vinxru
0006+  C443             ;----------------------------------------------------------------------------
0007+  C443             
0008+  C443             drawCursor_1:	; Цикл
0009+  C443 3D          		dcr	a
0010+  C444 C2 6C C3    		jnz	drawCursor_0
0011+  C447             
0012+  C447             		; b = v_cursorCfg & 0xF
0013+  C447 78          		mov	a, b
0014+  C448 E6 0F       		ani	0Fh
0015+  C44A 47          		mov	b, a
0016+  C44B             
0017+  C44B             		; Вывод курсора (b - высота, de - адрес на экране, hl - курсор)
0018+  C44B             
0019+  C44B             drawCursor_2:	; Повторить код ниже B раз
0020+  C44B 05          		dcr	b
0021+  C44C FA 25 C3    		jm	popa_ret_2
0022+  C44F             
0023+  C44F             		; *de--	^= hl;
0024+  C44F 1A          		ldax	d
0025+  C450 AC          		xra	h
0026+  C451 12          		stax	d
0027+  C452 14          		inr	d
0028+  C453 1A          		ldax	d
0029+  C454 AD          		xra	l
0030+  C455 12          		stax	d
0031+  C456 15          		dcr	d
0032+  C457 1D          		dcr	e
0033+  C458 C3 4B C4    		jmp	drawCursor_2
0034+  C45B             
0118   C45B             .include "reboot1.inc"
0001+  C45B             ;+---------------------------------------------------------------------------
0002+  C45B             ; MXOS
0003+  C45B             ; Перезагрузка (продолжение)
0004+  C45B             ;
0005+  C45B             ; 2013-12-12 Дизассемблировано vinxru
0006+  C45B             ;----------------------------------------------------------------------------
0007+  C45B             
0008+  C45B             reboot1:	; Для выключения звука
0009+  C45B 3E 36       		mvi	a, 36h
0010+  C45D             
0011+  C45D             		; Включаем ОЗУ
0012+  C45D 32 FC FF    		sta	IO_RAM
0013+  C460             
0014+  C460             		; Выключаем звук		
0015+  C460 32 EF FF    		sta	IO_TIMER+3
0016+  C463             
0017+  C463             		; Инициализация переменных
0018+  C463 21 7E C4    		lxi	h, initVars	; Откуда
0019+  C466 11 9F C4    		lxi	d, initVarsEnd	; Конец
0020+  C469 01 DF 8F    		lxi	b, vars		; Куда
0021+  C46C CD 2D C4    		call	memcpy_bc_hl
0022+  C46F             
0023+  C46F             		; Установка цвета
0024+  C46F             #if DISABLE_COLOR_BUG
0025+  C46F 3E F0       		mvi	a, INIT_COLOR
0026+  C471 32 F8 FF    		sta	IO_COLOR
0027+  C474~            #else
0028+  C474~            		mvi	a, 0Fh  
0029+  C474~            		sta	IO_KEYB_MODE 
0030+  C474             #endif
0031+  C474             
0032+  C474             #if LOAD_FONT
0033+  C474             onceInitFont:
0034+  C474 C3 06 CF    		jmp	initFont
0035+  C477~            #else
0036+  C477~            		jmp	reboot2
0037+  C477             #endif
0038+  C477             
0119   C477 00          .db 0
0120   C478             .include "tapeReadError.inc"
0001+  C478             ;+---------------------------------------------------------------------------
0002+  C478             ; MXOS
0003+  C478             ; Вызывается при ошибке чтения с ленты
0004+  C478             ;
0005+  C478             ; 2013-12-12 Дизассемблировано vinxru
0006+  C478             ;----------------------------------------------------------------------------
0007+  C478             
0008+  C478 D1          tapeReadError:	pop	d
0009+  C479 C1          		pop	b
0010+  C47A 2A E1 8F    		lhld	v_tapeError
0011+  C47D E9          		pchl
0012+  C47E             
0121   C47E             
0122   C47E             ; ---------------------------------------------------------------------------
0123   C47E             
0124   C47E FF FF       initVars:	.dw -1
0125   C480 00 C8       		.dw 0C800h		; v_tapeError
0126   C482 FF FF       		.dw -1			; v_tapeAddr
0127   C484 FF FF       		.dw -1
0128   C486             #if LOAD_FONT
0129   C486 20 1D       		.dw FONT_ADDR/8	; v_charGen
0130   C488~            #else
0131   C488~            		.dw -1			; v_charGen
0132   C488             #endif
0133   C488 A9          		.db 0A9h		; v_cursorCfg
0134   C489 FF          		.db -1			; v_koi8
0135   C48A FF          		.db -1			; v_escMode
0136   C48B 3A          		.db 03Ah		; v_keyLocks
0137   C48C FF FF       		.dw -1
0138   C48E FF          		.db -1			; v_lastLastKey
0139   C48F FF          		.db -1			; v_lastKey
0140   C490 5F 20       		.db 05Fh, 20h	; v_beep
0141   C492 FF          		.db 0FFh		; v_tapeInverse
0142   C493 20          		.db 020h		; v_cursorDelay
0143   C494 E0          		.db 0E0h		; byte_8FF5
0144   C495 FF FF       		.dw -1			; v_oldSP
0145   C497 0F          		.db ARAM_MAX_PAGE; v_maxRamPage
0146   C498 00          		.db 0           ; v_flashPage
0147   C499 00 00       		.dw 0			; v_inverse
0148   C49B FF          		.db -1			; v_cursorY
0149   C49C FF          		.db -1			; v_cursorX
0150   C49D 28          		.db 28h			; v_writeDelay
0151   C49E 3C          		.db 3Ch			; v_readDelay
0152   C49F 00          initVarsEnd:	.db 00h
0153   C4A0             
0154   C4A0             ; Keyboard
0155   C4A0             
0156   C4A0             v_keybTbl:
0157   C4A0 81 0C 19 1A 		.db 81h, 0Ch, 19h, 1Ah, 09h, 1Bh, 20h,  8,  80h, 18h, 0Ah, 0Dh, 0, 0, 0, 0
0157   C4A4 09 1B 20 08 
0157   C4A8 80 18 0A 0D 
0157   C4AC 00 00 00 00 
0158   C4B0 71 7E 73 6D 		.db 71h, 7Eh, 73h, 6Dh, 69h, 74h, 78h, 62h, 60h, 2Ch, 2Fh, 7Fh, 0, 0, 0, 0
0158   C4B4 69 74 78 62 
0158   C4B8 60 2C 2F 7F 
0158   C4BC 00 00 00 00 
0159   C4C0 66 79 77 61 		.db 66h, 79h, 77h, 61h, 70h, 72h, 6Fh, 6Ch, 64h, 76h, 7Ch, 2Eh, 0, 0, 0, 0
0159   C4C4 70 72 6F 6C 
0159   C4C8 64 76 7C 2E 
0159   C4CC 00 00 00 00 
0160   C4D0 6A 63 75 6B 		.db 6Ah, 63h, 75h, 6Bh, 65h, 6Eh, 67h, 7Bh, 7Dh, 7Ah, 68h, 3Ah, 0, 0, 0, 0
0160   C4D4 65 6E 67 7B 
0160   C4D8 7D 7A 68 3A 
0160   C4DC 00 00 00 00 
0161   C4E0 3B 31 32 33 		.db 3Bh, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh, 0, 0, 0, 0
0161   C4E4 34 35 36 37 
0161   C4E8 38 39 30 2D 
0161   C4EC 00 00 00 00 
0162   C4F0 00 01 02 03 		.db 00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 8Ah, 8Bh, 8Ch, 1Fh, 0, 0, 0, 0
0162   C4F4 04 05 06 07 
0162   C4F8 8A 8B 8C 1F 
0162   C4FC 00 00 00 00 
0163   C500             
0164   C500             .include "printer.inc"
0001+  C500             ;+---------------------------------------------------------------------------
0002+  C500             ; MXOS
0003+  C500             ; Вывод байта на принтер
0004+  C500             ;
0005+  C500             ; На входе 
0006+  C500             ;   c - байт
0007+  C500             ;
0008+  C500             ; На выходе 
0009+  C500             ;   af, bc, de, hl - cохраняются
0010+  C500             ;
0011+  C500             ; 2013-12-12 Дизассемблировано vinxru
0012+  C500             ;----------------------------------------------------------------------------
0013+  C500             
0014+  C500             printer:	; Сохраняем регистры
0015+  C500 F5          		push	psw
0016+  C501             
0017+  C501             		; Режим порта расширения
0018+  C501 3E 90       		mvi	a, 90h
0019+  C503 32 E7 FF    		sta	IO_PROG+3
0020+  C506             
0021+  C506             		; Выводим байт на принтер
0022+  C506 79          		mov	a, c		
0023+  C507 2F          		cma
0024+  C508 32 E5 FF    		sta	IO_PROG+1
0025+  C50B             
0026+  C50B             printer_loop:	; Выход	при нажатии любой клавиши
0027+  C50B 3A E1 FF    		lda	IO_KEYB_B	
0028+  C50E E6 02       		ani	2
0029+  C510 CA 24 C5    		jz	printer_ret
0030+  C513             
0031+  C513             		; Ждем пока принтер не будет готов
0032+  C513 3A E4 FF    		lda	IO_PROG		
0033+  C516 E6 40       		ani	40h
0034+  C518 C2 0B C5    		jnz	printer_loop
0035+  C51B             		
0036+  C51B             		; Строб
0037+  C51B 3E 03       		mvi	a, 3		
0038+  C51D 32 E6 FF    		sta	IO_PROG+2
0039+  C520 AF          		xra	a
0040+  C521 32 E6 FF    		sta	IO_PROG+2
0041+  C524             
0042+  C524             printer_ret:	; Восстаналвиаем регистры
0043+  C524 F1          		pop	psw
0044+  C525 C9          		ret
0045+  C526             
0165   C526             .include "printString.inc"
0001+  C526             ;+---------------------------------------------------------------------------
0002+  C526             ; MXOS
0003+  C526             ; Вывод строки на экран
0004+  C526             ;
0005+  C526             ; На входе
0006+  C526             ;  hl - строка
0007+  C526             ;
0008+  C526             ; На выходе
0009+  C526             ;  af, bc, de - сохраняются
0010+  C526             ;
0011+  C526             ; 2013-12-12 Дизассемблировано vinxru
0012+  C526             ;----------------------------------------------------------------------------
0013+  C526             
0014+  C526             printString:	; Сохраняем регистры
0015+  C526 C5          		push	b
0016+  C527 F5          		push	psw
0017+  C528             
0018+  C528             printString_1:	; Читаем очередной байт
0019+  C528 7E          		mov	a, m
0020+  C529             		
0021+  C529             		; Если прочитан 0, выходим
0022+  C529 B7          		ora	a
0023+  C52A CA 35 C5    		jz	printString_2
0024+  C52D             
0025+  C52D             		; Выводим байт на экран
0026+  C52D 4F          		mov	c, a
0027+  C52E CD 37 C0    		call	printChar
0028+  C531             
0029+  C531             		; Следующий байт
0030+  C531 23          		inx	h
0031+  C532 C3 28 C5    		jmp	printString_1
0032+  C535             
0033+  C535             ; ---------------------------------------------------------------------------
0034+  C535             
0035+  C535             printString_2:	; Восстанавливаем регистры
0036+  C535 F1          		pop	psw
0037+  C536 C1          		pop	b
0038+  C537 C9          		ret
0039+  C538             
0166   C538             .include "reboot2.inc"
0001+  C538             ;+---------------------------------------------------------------------------
0002+  C538             ; MXOS
0003+  C538             ; Перезагрузка (продолжение)
0004+  C538             ;
0005+  C538             ; 2013-12-12 Дизассемблировано vinxru
0006+  C538             ;----------------------------------------------------------------------------
0007+  C538             
0008+  C538             reboot2:
0009+  C538             		; Очищаем экран
0010+  C538 CD 10 C0    		call	clearScreen
0011+  C53B             
0012+  C53B             		; Проверяем, нажата ли какая нибудь клавиша
0013+  C53B CD 03 C0    		call	j_keyScan
0014+  C53E             
0015+  C53E F5          		push	psw
0016+  C53F             
0017+  C53F             		; Выводим версию ОС на экран
0018+  C53F 21 6C C5    		lxi h, txtBiosVer
0019+  C542 CD 38 C4    		call printString1
0020+  C545             
0021+  C545             		; Определяем размер ДОЗУ и печатаем процесс на экран
0022+  C545 21 BB FF    		lxi	 h, ARAM_PAGE_END
0023+  C548 3A F8 8F    		lda	 v_maxRamPage
0024+  C54B CD D0 C7    		call checkARAM
0025+  C54E             
0026+  C54E             		; Выводим объем памяти на экран
0027+  C54E 21 7D C5    		lxi  h, txtRAM
0028+  C551 CD 38 C4    		call printString1
0029+  C554             
0030+  C554 3A F8 8F    		lda	 v_maxRamPage
0031+  C557 CD 8E C8            call printHexByte
0032+  C55A             
0033+  C55A 21 83 C5    		lxi  h, txtKB
0034+  C55D CD 38 C4    		call printString1
0035+  C560             
0036+  C560                     ;call getch
0037+  C560             
0038+  C560 F1          		pop	psw
0039+  C561             
0040+  C561             		; Если не нажата ни одна клавиша, запускаем файл с RAM-диска
0041+  C561 3C          		inr	a
0042+  C562 CA 00 C8    		jz	j_reboot3
0043+  C565             
0044+  C565             		; Загружаем программу с ленты (без контроля КС) и запускаем
0045+  C565 CD F9 C3    		call	tapeLoadInt
0046+  C568 2A E3 8F    		lhld	v_tapeAddr
0047+  C56B E9          		pchl
0048+  C56C             
0049+  C56C             ; ---------------------------------------------------------------------------
0050+  C56C             
0051+  C56C             txtBiosVer:
0052+  C56C 0C          		.db 0Ch	; '\f'
0053+  C56D 4D 58 4F 53 		.text "MXOS BIOS 4.50"
0053+  C571 20 42 49 4F 
0053+  C575 53 20 34 2E 
0053+  C579 35 30 
0054+  C57B 0A          		.db 0Ah	; '\n'
0055+  C57C 00          		.db 0
0056+  C57D             
0057+  C57D             txtRAM:
0058+  C57D 0A          		.db 0Ah	; '\n'
0059+  C57E 52 41 4D 20 		.text "RAM "
0060+  C582 00          		.db 0
0061+  C583             
0062+  C583             txtKB:
0063+  C583 20 2A 20 36 		.text " * 64 KB"
0063+  C587 34 20 4B 42 
0064+  C58B 0A          		.db 0Ah	; '\n'
0065+  C58C 00          		.db 0
0167   C58D             .include "getch3.inc"
0001+  C58D             ;----------------------------------------------------------------------------
0002+  C58D             ; MXOS
0003+  C58D             ; Ожидание ввода с клавиатуры (продолжение)
0004+  C58D             ;
0005+  C58D             ; На выходе
0006+  C58D             ;  ? - код
0007+  C58D             ;
0008+  C58D             ; 2013-12-12 Дизассемблировано vinxru
0009+  C58D             ;----------------------------------------------------------------------------
0010+  C58D             
0011+  C58D             loc_C55C:	; Если нажат лишь РУС/LAT - то обрабатываем его как CAPS/LOCK
0012+  C58D CD 5A C2    		call	setKeybMode91
0013+  C590 3E F8       		mvi	a, 0F8h
0014+  C592 32 E1 FF    		sta	IO_KEYB_B
0015+  C595 3A E0 FF    		lda	IO_KEYB_A		
0016+  C598 F5          		push	psw
0017+  C599 CD 54 C2    		call	setKeybMode82
0018+  C59C F1          		pop	psw
0019+  C59D E6 08       		ani	8
0020+  C59F C2 B9 C5    		jnz	getch_capsLock
0021+  C5A2             
0022+  C5A2             		; Меняем KOI-7 / KOI-8
0023+  C5A2 3A EA 8F    		lda	v_koi8
0024+  C5A5 2F          		cma
0025+  C5A6 32 EA 8F    		sta	v_koi8
0026+  C5A9             
0027+  C5A9             		; Звуковой сигнал
0028+  C5A9 CD 70 C1    		call	beep
0029+  C5AC             
0030+  C5AC 3E 3A       		mvi	a, 3Ah
0031+  C5AE 32 EC 8F    		sta	v_keyLocks
0032+  C5B1             
0033+  C5B1             		; Меняем частоту
0034+  C5B1 3E 5F       		mvi	a, 5Fh
0035+  C5B3 32 F1 8F    		sta	v_beep
0036+  C5B6             
0037+  C5B6 C3 25 C2    		jmp	getch_retry
0038+  C5B9             
0039+  C5B9             ; ---------------------------------------------------------------------------
0040+  C5B9             ; CAPS LOCK для KOI-7
0041+  C5B9             
0042+  C5B9             getch_capsLock:	; Переключаем capsLock
0043+  C5B9 3A EC 8F    		lda	v_keyLocks
0044+  C5BC EE 80       		xri	80h
0045+  C5BE 32 EC 8F    		sta	v_keyLocks
0046+  C5C1             
0047+  C5C1             		; Изменяем высоту звуковго сигнала		
0048+  C5C1 3A F1 8F    		lda	v_beep
0049+  C5C4 EE 10       		xri	10h
0050+  C5C6 32 F1 8F    		sta	v_beep
0051+  C5C9             
0052+  C5C9             		; Ждем следующую клавишу
0053+  C5C9 C3 25 C2    		jmp	getch_retry
0054+  C5CC             
0055+  C5CC             ; ---------------------------------------------------------------------------
0056+  C5CC             ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
0057+  C5CC             
0058+  C5CC             getch_rc:	; В режиме KOI-8 мы переключаем кодировку
0059+  C5CC 3A EA 8F    		lda	v_koi8
0060+  C5CF 3C          		inr	a
0061+  C5D0             
0062+  C5D0 3A EC 8F    		lda	v_keyLocks	; Требуется в getch_rusLat
0063+  C5D3 C2 BD C2    		jnz	getch_rusLat
0064+  C5D6             
0065+  C5D6             		; В режиме KOI-7 мы перключаем регистр
0066+  C5D6 C3 B9 C5    		jmp	getch_capsLock	
0067+  C5D9             
0068+  C5D9             ; ---------------------------------------------------------------------------
0069+  C5D9             
0070+  C5D9             loc_C5A8:	; Включен KOI-7
0071+  C5D9 47          		mov	b, a
0072+  C5DA             
0073+  C5DA 3A E1 FF    		lda	IO_KEYB_B
0074+  C5DD E6 02       		ani	2
0075+  C5DF C2 11 C3    		jnz	loc_C311
0076+  C5E2             
0077+  C5E2 3E A0       		mvi	a, 0A0h
0078+  C5E4 A8          		xra	b
0079+  C5E5 47          		mov	b, a
0080+  C5E6             
0081+  C5E6 C3 11 C3    		jmp	loc_C311
0082+  C5E9             
0168   C5E9             .include "printChar2.inc"	; Continued in scrollDown
0001+  C5E9             ;+---------------------------------------------------------------------------
0002+  C5E9             ; MXOS
0003+  C5E9             ; Вывод символа на экран (или принтер)
0004+  C5E9             ;
0005+  C5E9             ; На входе
0006+  C5E9             ;  с - символ
0007+  C5E9             ;
0008+  C5E9             ; На выходе
0009+  C5E9             ;  регистры не сохраняются
0010+  C5E9             ;
0011+  C5E9             ; 2013-12-12 Дизассемблировано vinxru
0012+  C5E9             ;----------------------------------------------------------------------------
0013+  C5E9             
0014+  C5E9             printChar2:	; Помещаем в HL координаты курсора
0015+  C5E9 2A FC 8F    		lhld	v_cursorY
0016+  C5EC             
0017+  C5EC             		; Продолжаем, если не включен режим обработки ESC последовательности (v_escMode==0FFh)
0018+  C5EC 3A EB 8F    		lda	v_escMode
0019+  C5EF 3C          		inr	a
0020+  C5F0 C2 8E C6    		jnz	printChar_esc
0021+  C5F3             
0022+  C5F3             		; Тут v_escMode==0FFh
0023+  C5F3             
0024+  C5F3             		; Если это печатные символы (>=20h), переходим к печати
0025+  C5F3 79          		mov	a, c
0026+  C5F4 FE 20       		cpi	' '
0027+  C5F6 D2 08 C6    		jnc	printChar_real
0028+  C5F9             
0029+  C5F9             		; Это табуляция
0030+  C5F9 FE 09       		cpi	9
0031+  C5FB CA 50 C0    		jz	printChar_c9	; там v_cursorX+=24 и ret
0032+  C5FE             
0033+  C5FE             		; Любой символ кроме ESC
0034+  C5FE FE 1B       		cpi	1Bh
0035+  C600 C2 1C C1    		jnz	printChar3
0036+  C603             
0037+  C603             		; Далее ESC. Включаем режим обработки ESC последовательности (v_escMode=0)
0038+  C603 AF          		xra	a
0039+  C604 32 EB 8F    		sta	v_escMode
0040+  C607 C9          		ret
0041+  C608             
0042+  C608             ; ---------------------------------------------------------------------------
0043+  C608             ; Преобразование символа из KOI-7 в KOI-8 и вывод на экран (служебные коды 
0044+  C608             ; так же будут выводится)
0045+  C608             
0046+  C608             printChar_real:	; Символ для печати
0047+  C608 4F          		mov	c, a
0048+  C609             
0049+  C609             		; Продолжаем, если включен режим KOI-7 
0050+  C609 3A EA 8F    		lda	v_koi8
0051+  C60C 3C          		inr	a
0052+  C60D C2 21 C6    		jnz	printChar_real2
0053+  C610             
0054+  C610             		; Если символ больше или равен 0C0h просто выходим
0055+  C610 79          		mov	a, c
0056+  C611 FE C0       		cpi	0C0h
0057+  C613 D0          		rnc
0058+  C614             
0059+  C614             		; Если символ находится в пределах 60h ... 7Fh, увеличиваем его код на 80h
0060+  C614 FE 60       		cpi	60h
0061+  C616 DA 21 C6    		jc	printChar_real2
0062+  C619 FE 80       		cpi	80h
0063+  C61B D2 21 C6    		jnc	printChar_real2
0064+  C61E C6 80       		adi	80h
0065+  C620 4F          		mov	c, a
0066+  C621             
0067+  C621             ; ---------------------------------------------------------------------------
0068+  C621             ; Вывод символа на экран в KOI-8 (служебные коды так же будут выводится)
0069+  C621             
0070+  C621             printChar_real2:	
0071+  C621             		; Тут полиморфизм
0072+  C621 3A FA 8F    		lda	v_inverse
0073+  C624 A7          		ana	a
0074+  C625 CC E6 C0    printChar_poly:	cz	normalVideo
0075+  C628             
0076+  C628             		; Если v_charGen не равен 0FFFFh, то используется знакогнератор по адресу v_charGen*8
0077+  C628 2A E7 8F    		lhld	v_charGen
0078+  C62B 7C          		mov	a, h
0079+  C62C 3C          		inr	a
0080+  C62D C2 59 C0    		jnz	printChar_alt
0081+  C630 7D          		mov	a, l
0082+  C631 3C          		inr	a
0083+  C632 C2 59 C0    		jnz	printChar_alt
0084+  C635             
0085+  C635             		; Иначе используем символы из ПЗУ. 
0086+  C635             		; Адрес символа в ПЗУ (de = 0x800 + c*8)
0087+  C635 21 00 01    		lxi	h, 100h		
0088+  C638 06 00       		mvi	b, 0
0089+  C63A 09          		dad	b
0090+  C63B 29          		dad	h
0091+  C63C 29          		dad	h
0092+  C63D 29          		dad	h
0093+  C63E EB          		xchg
0094+  C63F             
0095+  C63F             		; Промежуточное место для символа
0096+  C63F 21 B4 C1    		lxi	h, v_char
0097+  C642 E5          		push	h
0098+  C643             
0099+  C643             		; Копируем 8 байт из ПЗУ
0100+  C643 32 FE FF    		sta	IO_ROM
0101+  C646 1A          		ldax	d
0102+  C647 77          		mov	m, a
0103+  C648 23          		inx	h
0104+  C649 13          		inx	d
0105+  C64A 1A          		ldax	d
0106+  C64B 77          		mov	m, a
0107+  C64C 23          		inx	h
0108+  C64D 13          		inx	d
0109+  C64E 1A          		ldax	d
0110+  C64F 77          		mov	m, a
0111+  C650 23          		inx	h
0112+  C651 13          		inx	d
0113+  C652 1A          		ldax	d
0114+  C653 77          		mov	m, a
0115+  C654 23          		inx	h
0116+  C655 13          		inx	d
0117+  C656 1A          		ldax	d
0118+  C657 77          		mov	m, a
0119+  C658 23          		inx	h
0120+  C659 13          		inx	d
0121+  C65A 1A          		ldax	d
0122+  C65B 77          		mov	m, a
0123+  C65C 23          		inx	h
0124+  C65D 13          		inx	d
0125+  C65E 1A          		ldax	d
0126+  C65F 77          		mov	m, a
0127+  C660 23          		inx	h
0128+  C661 13          		inx	d
0129+  C662 1A          		ldax	d
0130+  C663 77          		mov	m, a
0131+  C664 32 FC FF    		sta	IO_RAM
0132+  C667             
0133+  C667             		; Вывод символа
0134+  C667 D1          		pop	d
0135+  C668 C3 60 C0    		jmp	printChar_de
0136+  C66B             
0137+  C66B             ; ---------------------------------------------------------------------------
0138+  C66B             ; Обработка режима ESC+F
0139+  C66B             
0140+  C66B             printChar_esc80:; Если символ с кодом 0, выключаем режим обработки ESC
0141+  C66B 79          		mov	a, c
0142+  C66C B7          		ora	a
0143+  C66D CA 89 C6    		jz	printChar_esc80_exit
0144+  C670             
0145+  C670             		; Обработка кодов <20h
0146+  C670 FE 20       		cpi	20h
0147+  C672 DA 1C C1    		jc	printChar3
0148+  C675             
0149+  C675             		; Если код >= 80h, выйти
0150+  C675 FE 80       		cpi	80h
0151+  C677 D0          		rnc
0152+  C678             
0153+  C678             		; Если c >= 40h, вывести на экран c+40h
0154+  C678 FE 40       		cpi	40h
0155+  C67A D2 83 C6    		jnc	printChar_esc80_2
0156+  C67D             
0157+  C67D             		; Иначе вывести c - 20h
0158+  C67D D6 20       		sui	20h ; ' '
0159+  C67F 4F          		mov	c, a
0160+  C680 C3 21 C6    		jmp	printChar_real2
0161+  C683             
0162+  C683             ; ---------------------------------------------------------------------------
0163+  C683             
0164+  C683             printChar_esc80_2:
0165+  C683             		; Если c >= 40h, вывести на экран c+40h
0166+  C683 C6 40       		adi	40h
0167+  C685 4F          		mov	c, a
0168+  C686 C3 21 C6    		jmp	printChar_real2
0169+  C689             
0170+  C689             ; ---------------------------------------------------------------------------
0171+  C689             
0172+  C689             printChar_esc80_exit:
0173+  C689 3D          		dcr	a
0174+  C68A 32 EB 8F    		sta	v_escMode
0175+  C68D C9          		ret
0176+  C68E             
0177+  C68E             ; ---------------------------------------------------------------------------
0178+  C68E             ; Печать символа в ESC-режиме
0179+  C68E             
0180+  C68E             printChar_esc:	; Перейти если v_escMode=80h
0181+  C68E 3A EB 8F    		lda	v_escMode
0182+  C691 FE 80       		cpi	80h
0183+  C693 CA 6B C6    		jz	printChar_esc80
0184+  C696             
0185+  C696             		; Выключить режим обработки ESC последовательности
0186+  C696 F5          		push	psw
0187+  C697 3E FF       		mvi	a, 0FFh
0188+  C699 32 EB 8F    		sta	v_escMode
0189+  C69C F1          		pop	psw
0190+  C69D             
0191+  C69D             		; Перейти если v_escMode==0
0192+  C69D B7          		ora	a
0193+  C69E CA D8 C6    		jz	printChar_esc0
0194+  C6A1             
0195+  C6A1             		; Перейти если обработка ESC+Y (v_escMode==1)
0196+  C6A1 3D          		dcr	a
0197+  C6A2 CA AE C6    		jz	printChar_esc1
0198+  C6A5             
0199+  C6A5             		; Перейти если v_escMode==2
0200+  C6A5 3D          		dcr	a
0201+  C6A6 CA CA C6    		jz	printChar_esc2
0202+  C6A9             
0203+  C6A9             		; Перейти если v_escMode==3
0204+  C6A9 3D          		dcr	a
0205+  C6AA CA 3E C7    		jz	printChar_esc3
0206+  C6AD             
0207+  C6AD             		; Выйти
0208+  C6AD C9          		ret
0209+  C6AE             
0210+  C6AE             ; ---------------------------------------------------------------------------
0211+  C6AE             ; Обработка ESC+Y
0212+  C6AE             
0213+  C6AE             printChar_esc1:	; Если код меньше 20h или больше 20h + 24, то пропускаем установку Y
0214+  C6AE 79          		mov	a, c
0215+  C6AF FE 39       		cpi	20h + 25
0216+  C6B1 D2 C4 C6    		jnc	loc_C693
0217+  C6B4 D6 20       		sui	20h
0218+  C6B6 DA C4 C6    		jc	loc_C693
0219+  C6B9             
0220+  C6B9             		; cursorY = 8 + a*10
0221+  C6B9 87          		add	a
0222+  C6BA 4F          		mov	c, a
0223+  C6BB 81          		add	c
0224+  C6BC 81          		add	c
0225+  C6BD 81          		add	c
0226+  C6BE 81          		add	c
0227+  C6BF C6 08       		adi	8
0228+  C6C1 32 FC 8F    		sta	v_cursorY
0229+  C6C4             
0230+  C6C4             loc_C693:	; Следующий символ будет обработан в printChar_esc2
0231+  C6C4 3E 02       		mvi	a, 2
0232+  C6C6 32 EB 8F    		sta	v_escMode
0233+  C6C9 C9          		ret
0234+  C6CA             
0235+  C6CA             ; ---------------------------------------------------------------------------
0236+  C6CA             ; Обработка ESC+Y
0237+  C6CA             
0238+  C6CA             printChar_esc2:	; Если код меньше 20h или больше 20h + 63, то пропускаем установку X
0239+  C6CA 79          		mov	a, c
0240+  C6CB FE 60       		cpi	60h
0241+  C6CD D0          		rnc
0242+  C6CE D6 20       		sui	20h
0243+  C6D0 D8          		rc
0244+  C6D1             
0245+  C6D1             		; cursorX = c*3;
0246+  C6D1 4F          		mov	c, a
0247+  C6D2 87          		add	a
0248+  C6D3 81          		add	c
0249+  C6D4 32 FD 8F    		sta	v_cursorX
0250+  C6D7 C9          		ret
0251+  C6D8             
0252+  C6D8             ; ---------------------------------------------------------------------------
0253+  C6D8             ; Обработка первого символа ESC последовательности
0254+  C6D8             
0255+  C6D8             printChar_esc0:	; Если код больше 20h
0256+  C6D8 79          		mov	a, c
0257+  C6D9 FE 28       		cpi	'(' ; 28h
0258+  C6DB CA 45 C0    		jz	printChar_e28
0259+  C6DE FE 29       		cpi	')' ; 29h
0260+  C6E0 CA 4B C0    		jz	printChar_e29
0261+  C6E3 FE 50       		cpi	'P' ; 50h
0262+  C6E5 CA 2E C7    		jz	printChar_eP
0263+  C6E8 D6 41       		sui	'A' ; 41h
0264+  C6EA CA 34 C7    		jz	printChar19
0265+  C6ED 3D          		dcr	a ; 'B' 42h
0266+  C6EE CA 39 C7    		jz	printChar1A
0267+  C6F1 3D          		dcr	a ; 'C' 43h
0268+  C6F2 CA 1A C7    		jz	printChar18
0269+  C6F5 3D          		dcr	a ; 'D' 44h
0270+  C6F6 CA 1F C7    		jz	printChar08
0271+  C6F9 3D          		dcr	a ; 'E' 45h
0272+  C6FA CA 24 C7    		jz	printChar1F
0273+  C6FD 3D          		dcr	a ; 'F' 46h
0274+  C6FE CA 3B C4    		jz	printChar_eF
0275+  C701 3D          		dcr	a
0276+  C702 3D          		dcr	a ; 'H' 48h
0277+  C703 CA 29 C7    		jz	printChar0C
0278+  C706 3D          		dcr	a ; 'I' 49h
0279+  C707 CA 58 C7    		jz	printChar_eI
0280+  C70A 3D          		dcr	a
0281+  C70B 3D          		dcr	a
0282+  C70C D6 0E       		sui	14 ; 'Y' 59h
0283+  C70E CA 14 C7    		jz	setEscMode_eY
0284+  C711             
0285+  C711             		; Вывод символа
0286+  C711 C3 E9 C5    		jmp	printChar2
0287+  C714             
0288+  C714             ; ---------------------------------------------------------------------------
0289+  C714             ; Обработка ESC+Y.
0290+  C714             
0291+  C714             setEscMode_eY:	; Следующий символ будет обработан в printChar_esc1 
0292+  C714 3E 01       		mvi	a, 1
0293+  C716 32 EB 8F    		sta	v_escMode
0294+  C719 C9          		ret
0295+  C71A             
0296+  C71A             ; ---------------------------------------------------------------------------
0297+  C71A             
0298+  C71A 0E 18       printChar18:	mvi	c, 18h
0299+  C71C C3 E9 C5    		jmp	printChar2
0300+  C71F             
0301+  C71F             ; ---------------------------------------------------------------------------
0302+  C71F             
0303+  C71F 0E 08       printChar08:	mvi	c, 8
0304+  C721 C3 E9 C5    		jmp	printChar2
0305+  C724             
0306+  C724             ; ---------------------------------------------------------------------------
0307+  C724             
0308+  C724 0E 1F       printChar1F:	mvi	c, 1Fh
0309+  C726 C3 E9 C5    		jmp	printChar2
0310+  C729             
0311+  C729             ; ---------------------------------------------------------------------------
0312+  C729             
0313+  C729 0E 0C       printChar0C:	mvi	c, 0Ch
0314+  C72B C3 E9 C5    		jmp	printChar2
0315+  C72E             
0316+  C72E             ; ---------------------------------------------------------------------------
0317+  C72E             ; Обработка ESP+P. Вклчюение режима эхопечати на принтере
0318+  C72E             
0319+  C72E 3E 03       printChar_eP:	mvi	a, 3
0320+  C730 32 EB 8F    		sta	v_escMode
0321+  C733 C9          		ret
0322+  C734             
0323+  C734             ; ---------------------------------------------------------------------------
0324+  C734             
0325+  C734 0E 19       printChar19:	mvi	c, 19h
0326+  C736 C3 E9 C5    		jmp	printChar2
0327+  C739             
0328+  C739             ; ---------------------------------------------------------------------------
0329+  C739             
0330+  C739 0E 1A       printChar1A:	mvi	c, 1Ah
0331+  C73B C3 E9 C5    		jmp	printChar2
0332+  C73E             
0333+  C73E             ; ---------------------------------------------------------------------------
0334+  C73E             ; Режим эхопечати на принтере. Включается ESC+P
0335+  C73E             
0336+  C73E             printChar_esc3:	; Выходим, из режима, если код нулевой
0337+  C73E 79          		mov	a, c
0338+  C73F B7          		ora	a
0339+  C740 C8          		rz
0340+  C741             
0341+  C741             		; Печать на принтере
0342+  C741 CD 00 C5    		call	printer
0343+  C744             
0344+  C744             		; Печать на экране
0345+  C744 CD E9 C5    		call	printChar2
0346+  C747             
0347+  C747             		; Находимся в этом режиме до кода 0 или ESC
0348+  C747 3E 03       		mvi	a, 3
0349+  C749 32 EB 8F    		sta	v_escMode
0350+  C74C C9          		ret
0351+  C74D             
0352+  C74D             ; ---------------------------------------------------------------------------
0353+  C74D             ; Продолжение обработки ESC+I. Перемещение курсора вверх с прокруткой экрана
0354+  C74D             
0355+  C74D             printChar_eI_2:	; Если cursorY > 18, перемещаем курсор вверх и выходим
0356+  C74D FE 13       		cpi	19
0357+  C74F D2 E9 C5    		jnc	printChar2
0358+  C752             
0359+  C752             		; Устанаваливаем v_cursorY=8
0360+  C752 3E 08       		mvi	a, 8
0361+  C754 32 FC 8F    		sta	v_cursorY
0362+  C757 C9          		ret
0363+  C758             
0364+  C758             ; ---------------------------------------------------------------------------
0365+  C758             ; Обработка ESC+I. Перемещение курсора вверх с прокруткой экрана
0366+  C758             
0367+  C758             printChar_eI:	; Используется дальше функцией printChar2
0368+  C758 0E 19       		mvi	c, 19h
0369+  C75A             
0370+  C75A             		; Прокручиваем экран вних, только если v_cursorY == 8.
0371+  C75A             		; иначе переходим на printChar_eI_2
0372+  C75A 3A FC 8F    		lda	v_cursorY
0373+  C75D FE 08       		cpi	8
0374+  C75F C2 4D C7    		jnz	printChar_eI_2
0375+  C762             
0169   C762             .include "scrollDown.inc"
0001+  C762             ;+---------------------------------------------------------------------------
0002+  C762             ; MXOS
0003+  C762             ; Прокрутка экрана вниз
0004+  C762             ;
0005+  C762             ; На выходе
0006+  C762             ;   af, bc - сохраняются
0007+  C762             ;
0008+  C762             ; 2013-12-12 Дизассемблировано vinxru
0009+  C762             ;----------------------------------------------------------------------------
0010+  C762             
0011+  C762             		; Сохраняем регистры
0012+  C762 C5          		push	b
0013+  C763 F5          		push	psw
0014+  C764 21 00 00    		lxi	h, 0
0015+  C767 39          		dad	sp
0016+  C768 22 F6 8F    		shld	v_oldSP
0017+  C76B             
0018+  C76B             		; Подготовка переменных
0019+  C76B 31 00 C0    		lxi	sp, 0C000h ; Куда
0020+  C76E 26 BF       		mvi	h, 0BFh	   ; Откуда
0021+  C770 06 30       		mvi	b, 48      ; Столбцов
0022+  C772 0E 29       loc_C741:	mvi	c, 246 / 6 ; 246 строк
0023+  C774 2E F5       		mvi	l, 245	   ; Начинаем с 245 строки
0024+  C776             
0025+  C776             loc_C745:	; Копируем 6 байт из HL в SP
0026+  C776 56          		mov	d, m
0027+  C777 2B          		dcx	h
0028+  C778 5E          		mov	e, m
0029+  C779 2B          		dcx	h
0030+  C77A D5          		push	d		
0031+  C77B 56          		mov	d, m
0032+  C77C 2B          		dcx	h
0033+  C77D 5E          		mov	e, m
0034+  C77E 2B          		dcx	h
0035+  C77F D5          		push	d
0036+  C780 56          		mov	d, m
0037+  C781 2B          		dcx	h
0038+  C782 5E          		mov	e, m
0039+  C783 2B          		dcx	h
0040+  C784 D5          		push	d
0041+  C785             
0042+  C785             		; Цикл
0043+  C785 0D          		dcr	c
0044+  C786 C2 76 C7    		jnz	loc_C745
0045+  C789             
0046+  C789             		; Сохраняем H
0047+  C789 7C          		mov	a, h
0048+  C78A             		
0049+  C78A             		; Очищаем верхние 10 строк
0050+  C78A 2A FA 8F    		lhld	v_inverse
0051+  C78D E5          		push	h
0052+  C78E E5          		push	h
0053+  C78F E5          		push	h
0054+  C790 E5          		push	h
0055+  C791 E5          		push	h
0056+  C792             
0057+  C792             		; Восстанавливаем H
0058+  C792 67          		mov	h, a
0059+  C793             
0060+  C793             		; Следующий столбец
0061+  C793 05          		dcr	b
0062+  C794 C2 72 C7    		jnz	loc_C741
0063+  C797             
0064+  C797             		; Восстанавлиаем регистры и выходим
0065+  C797 2A F6 8F    		lhld	v_oldSP
0066+  C79A F9          		sphl
0067+  C79B F1          		pop	psw
0068+  C79C C1          		pop	b
0069+  C79D C9          		ret
0070+  C79E             
0170   C79E             .include "scrollUp2.inc"
0001+  C79E             ;+---------------------------------------------------------------------------
0002+  C79E             ; MXOS
0003+  C79E             ; Прокрутка экрана вверх (продолжение)
0004+  C79E             ;
0005+  C79E             ; 2013-12-12 Дизассемблировано vinxru
0006+  C79E             ;----------------------------------------------------------------------------
0007+  C79E             
0008+  C79E             scrollUp2:	; Копируем 246 байт из SP в H0 
0009+  C79E 0E 29       		mvi	c, 246 / 6
0010+  C7A0 2E 00       		mvi	l, 0
0011+  C7A2             
0012+  C7A2             scrollUp2_0:	; Копирование 6 байт из SP в HL
0013+  C7A2 D1          		pop	d
0014+  C7A3 73          		mov	m, e
0015+  C7A4 23          		inx	h
0016+  C7A5 72          		mov	m, d
0017+  C7A6 23          		inx	h
0018+  C7A7 D1          		pop	d
0019+  C7A8 73          		mov	m, e
0020+  C7A9 23          		inx	h
0021+  C7AA 72          		mov	m, d
0022+  C7AB 23          		inx	h
0023+  C7AC D1          		pop	d
0024+  C7AD 73          		mov	m, e
0025+  C7AE 23          		inx	h
0026+  C7AF 72          		mov	m, d
0027+  C7B0 23          		inx	h
0028+  C7B1             
0029+  C7B1             		; Цикл
0030+  C7B1 0D          		dcr	c
0031+  C7B2 C2 A2 C7    		jnz	scrollUp2_0
0032+  C7B5             
0033+  C7B5             		; Сохраняем H
0034+  C7B5 7C          		mov	a, h
0035+  C7B6             		
0036+  C7B6             		; Заполняем 10 байт 
0037+  C7B6 2A FA 8F    		lhld	v_inverse
0038+  C7B9 E5          		push	h
0039+  C7BA E5          		push	h
0040+  C7BB E5          		push	h
0041+  C7BC E5          		push	h
0042+  C7BD E5          		push	h
0043+  C7BE             
0044+  C7BE             		; Следующий столбец (SP += 20)
0045+  C7BE 21 14 00    		lxi	h, 14h
0046+  C7C1 39          		dad	sp
0047+  C7C2 F9          		sphl
0048+  C7C3             
0049+  C7C3             		; Восстанавливаем H
0050+  C7C3 67          		mov	h, a
0051+  C7C4             
0052+  C7C4             		; Следующий столбец
0053+  C7C4 24          		inr	h
0054+  C7C5             
0055+  C7C5             		; Цикл
0056+  C7C5 05          		dcr	b
0057+  C7C6 C2 9E C7    		jnz	scrollUp2
0058+  C7C9             
0059+  C7C9             		; Восстановление регистров и выход
0060+  C7C9 2A F6 8F    		lhld	v_oldSP
0061+  C7CC F9          		sphl
0062+  C7CD F1          		pop	psw
0063+  C7CE C1          		pop	b
0064+  C7CF C9          		ret
0065+  C7D0             
0171   C7D0             .include "checkARAM.inc"
0001+  C7D0             ;+---------------------------------------------------------------------------
0002+  C7D0             ; MXOS
0003+  C7D0             ; Исправленная функция определения размера ДОЗУ
0004+  C7D0             ; Заимствовано из RAMFOS
0005+  C7D0             ;
0006+  C7D0             ; На входе
0007+  C7D0             ;  а - максимальный номер страницы, константа MAX_ARAM_PAGE
0008+  C7D0             ;  hl - адрес в странице ДОЗУ для записи тестового байта
0009+  C7D0             ;
0010+  C7D0             ; На выходе
0011+  C7D0             ;  NZ - ДОЗУ найдено (наоборот относительно стандратной функции)
0012+  C7D0             ;   Z - ДОЗУ не найдено
0013+  C7D0             ;
0014+  C7D0             ; 2013-11-01 Разработано vinxru
0015+  C7D0             ;----------------------------------------------------------------------------
0016+  C7D0             
0017+  C7D0             checkARAM:	 ; Записываем во все страницы порядковые номера от большей к меньшей
0018+  C7D0 4F          		mov	c, a		
0019+  C7D1 0C          		inr	c
0020+  C7D2             		;call	j_pageWriteAny
0021+  C7D2 3D          		dcr	a
0022+  C7D3 F2 D0 C7    		jp	checkARAM
0023+  C7D6             
0024+  C7D6             		; Читаем номера. Если номер прочитан корректно, значит есть такая страница
0025+  C7D6             		; a = -1
0026+  C7D6             
0027+  C7D6             checkARAM_1:	 ; Читаем следующую страницу
0028+  C7D6 3C          		inr	a
0029+  C7D7             		;call	j_pageReadAny		
0030+  C7D7             
0031+  C7D7             		 ; Должен быть записан номер страницы+1, если нет, то выходим
0032+  C7D7 0D          		dcr	c
0033+  C7D8 B9          		cmp	c		 
0034+  C7D9 C2 E4 C7    		jnz	checkARAM_2
0035+  C7DC             
0036+  C7DC                     ; Сохраняем номер последней страницы RAM-диска
0037+  C7DC 32 F8 8F    		sta	 v_maxRamPage
0038+  C7DF             
0039+  C7DF             		; Это максимум, выходим
0040+  C7DF FE 0F       		cpi	 ARAM_MAX_PAGE		; ARAM_MAX_PAGE не может быть нулем!
0041+  C7E1 C2 D6 C7    		jnz	 checkARAM_1
0042+  C7E4             		 
0043+  C7E4             checkARAM_2:	; Если ДОЗУ найдено, выходим c флагом NZ
0044+  C7E4 B7          		ora	a
0045+  C7E5 C0          		rnz		
0046+  C7E6             
0047+  C7E6             		; В случае ошибки заносим в v_aramPages=0 и выходим с флагом Z
0048+  C7E6 32 F8 8F    		sta	v_maxRamPage
0049+  C7E9 C9          		ret
0050+  C7EA             
0172   C7EA             
0173   C7EA             ; Not used (free space?)
0174   C7EA             
0175   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0176   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0177   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0178   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0179   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0180   C7EA             ;		.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0181   C7EA             ;		.db 0FFh
0182   C7EA             
0183   C800             .org 0C800h
0184   C800             
0185   C800             .include "jmps_c800.inc"
0001+  C800 C3 EA C9    j_reboot3:		jmp	reboot3			; C800: Запустить NC.COM
0002+  C803 C3 37 C3    j_getch:		jmp	getch			; C803: Ожидание ввода с клавиатуры
0003+  C806 C3 77 C3    j_tapeRead:		jmp	tapeRead		; C806: Чтение байта с магнитофона
0004+  C809 C3 37 C0    j_printChar:	jmp	printChar		; C809: Вывод символа на экран
0005+  C80C C3 D0 C3    j_tapeWrite:	jmp	tapeWrite		; C80C: Запись байта на магнитофон
0006+  C80F C3 AE C8    				jmp	input			; C80F: Ввод строки с клавиатуры
0007+  C812 C3 03 C0    				jmp	j_keyScan		; C812: Получить код нажатой клавиши
0008+  C815 C3 8E C8    				jmp	printHexByte	; C815: Вывести 16-ричное число (байт)
0009+  C818 C3 38 C4    j_printString:	jmp	printString1	; C818: Вывести строку на экран
0010+  C81B C3 03 C0    				jmp	j_keyScan		; C81B: Получить код нажатой клавиши
0011+  C81E C3 6F C8    				jmp	getCursorPos	; C81E: Получить координаты курсора в HL (координаты в пикселях)
0012+  C821 C3 6C C8    				jmp	setCursorPos	; C821: Установить координаты курсора из HL (координаты в пикселях)
0013+  C824 C3 D7 C9    				jmp	tapeLoad		; C824: Загрузить программу с магнитофона
0014+  C827 C3 9E C9    				jmp	tapeSave		; C827: Сохранить программу на магнитофон
0015+  C82A C3 87 C9    				jmp	calcCS			; C81A: Расчет контрольной суммы
0016+  C82D C3 83 C8    				jmp	printHexWord	; C82D: Вывести 16-ричное число (слово)
0017+  C830 C3 7F C8    				jmp	getMemTop		; C830: Получить объем доступной памяти
0018+  C833 C3 73 C8    				jmp	setMemTop		; C833: Установить объем доступной памяти
0019+  C836 C3 00 C5    				jmp	printer			; C836: Напечатать байт на принтере
0020+  C839             #if RAMFOS_COMPATIBILITY
0021+  C839 C3 4F CE    				jmp	strToHex        ; C839: Преобразвоние строки в HEX формате в число
0022+  C83C~            #else
0023+  C83C~            				jmp	j_reboot3		; C839: Запустить NC.COM
0024+  C83C             #endif
0025+  C83C C3 EA C9    				jmp	reboot3			; C83C: Запустить NC.COM
0026+  C83F C3 A8 CD    				jmp	fileList		; C83F: Получить список файлов
0027+  C842 C3 81 CB    				jmp	fileGetSetDrive	; C842: Получить/установить активное устройство
0028+  C845 C3 F3 CB    				jmp	fileCreate		; C845: Создать файл
0029+  C848 C3 D3 CC    				jmp	fileLoad		; C848: Загрузить файл по адресу из заголовка этого файла
0030+  C84B C3 1F CD    				jmp	fileDelete		; C84B: Удалить файл
0031+  C84E C3 45 CD    				jmp	fileRename		; C84E: Переименовать файл
0032+  C851 C3 01 CD    				jmp	fileLoadInfo	; C851: Загрузить информацию о файле
0033+  C854 C3 81 CD    				jmp	fileGetSetAddr	; C854: Получить/установить адрес загрузки файла
0034+  C857 C3 67 CD    				jmp	fileGetSetAttr	; C857: Получить/установить атрибуты файла
0035+  C85A C3 D5 CD    				jmp	fileNamePrepare	; C85A: Преобразовать имя файла во внутренний формат
0036+  C85D C3 73 CA    				jmp	fileExec		; C85D: Запустить файл
0037+  C860 C3 6D CB    				jmp	installDriver	; C860: Установить драйвер накопителя
0038+  C863 C3 17 CB    j_diskDriver:	jmp	diskDriver		; C863: Драйвер выбранного диска
0039+  C866 C3 C2 CC    				jmp	fileLoad2		; C866: Загрузить файл по адресу DE
0040+  C869 C3 08 C6    				jmp	printChar_real	; C869: Вывод символа на экран (только реальные символы)
0041+  C86C             
0186   C86C             .include "setGetCursorPos.inc"
0001+  C86C             ;+---------------------------------------------------------------------------
0002+  C86C             ; MXOS
0003+  C86C             ; Установить положение курсора
0004+  C86C             ;
0005+  C86C             ; На входе 
0006+  C86C             ;  h - координата X в пикселях / 2
0007+  C86C             ;  l - координата Y в пикселях
0008+  C86C             ;
0009+  C86C             ; На выходе 
0010+  C86C             ;  af, bc, de, hl - Сохраняются
0011+  C86C             ;
0012+  C86C             ; 2013-12-12 Дизассемблировано vinxru
0013+  C86C             ;----------------------------------------------------------------------------
0014+  C86C             
0015+  C86C 22 FC 8F    setCursorPos:	shld	v_cursorY
0016+  C86F             
0017+  C86F             ;----------------------------------------------------------------------------
0018+  C86F             ; Получить положение курсора
0019+  C86F             ;
0020+  C86F             ; На выходе 
0021+  C86F             ;  af, bc, de - Сохраняются
0022+  C86F             ;  h - координата X в пикселях / 2
0023+  C86F             ;  l - координата Y в пикселях
0024+  C86F             ;----------------------------------------------------------------------------
0025+  C86F             
0026+  C86F 2A FC 8F    getCursorPos:	lhld	v_cursorY
0027+  C872 C9          		ret
0028+  C873             
0187   C873             .include "setGetMemTop.inc"
0001+  C873             ;+---------------------------------------------------------------------------
0002+  C873             ; MXOS
0003+  C873             ; Установить объем доступной памяти
0004+  C873             ;
0005+  C873             ; На входе
0006+  C873             ;  hl - доступная память. Если меньше 0D000h, то значение не изменяется.
0007+  C873             ;
0008+  C873             ; На выходе
0009+  C873             ;  все регистры сохраняются
0010+  C873             ;
0011+  C873             ; 2013-12-12 Дизассемблировано vinxru
0012+  C873             ;----------------------------------------------------------------------------
0013+  C873             
0014+  C873 F5          setMemTop:	push	psw
0015+  C874 7C          		mov	a, h
0016+  C875 FE D0       		cpi	0D0h
0017+  C877 DA 7D C8    		jc	setMemTop_0
0018+  C87A 22 CB CE    		  shld	v_memTop
0019+  C87D F1          setMemTop_0:	pop	psw
0020+  C87E C9          		ret
0021+  C87F             
0022+  C87F             ;----------------------------------------------------------------------------
0023+  C87F             ; Получить объем доступной памяти
0024+  C87F             ;
0025+  C87F             ; На выходе
0026+  C87F             ;  hl - доступная память
0027+  C87F             ;
0028+  C87F             ; На выходе
0029+  C87F             ;  все регистры сохраняются
0030+  C87F             ;----------------------------------------------------------------------------
0031+  C87F             		
0032+  C87F 2A CB CE    getMemTop:	lhld	v_memTop
0033+  C882 C9          		ret
0034+  C883             
0188   C883             .include "printHex.inc"
0001+  C883             ;+---------------------------------------------------------------------------
0002+  C883             ; MXOS
0003+  C883             ; Вывод 16-ричного числа на экран (слово)
0004+  C883             ;
0005+  C883             ; На входе
0006+  C883             ;  hl - число
0007+  C883             ;
0008+  C883             ; На выходе
0009+  C883             ;  все регистры сохраняются
0010+  C883             ;
0011+  C883             ; 2013-12-12 Дизассемблировано vinxru
0012+  C883             ;----------------------------------------------------------------------------
0013+  C883             
0014+  C883             printHexWord:	; Сохраняем регистры
0015+  C883 F5          		push	psw		
0016+  C884             
0017+  C884             		; Старший байт
0018+  C884 7C          		mov	a, h
0019+  C885 CD 8E C8    		call	printHexByte
0020+  C888             
0021+  C888             		; Младшйи байт
0022+  C888 7D          		mov	a, l
0023+  C889 CD 8E C8    		call	printHexByte
0024+  C88C             
0025+  C88C             		; Восстаналиваем регистры
0026+  C88C F1          		pop	psw
0027+  C88D C9          		ret
0028+  C88E             
0029+  C88E             ;----------------------------------------------------------------------------
0030+  C88E             ; Вывод 16-ричного числа на экран (байт)
0031+  C88E             ;
0032+  C88E             ; На входе
0033+  C88E             ;  a - число
0034+  C88E             ;
0035+  C88E             ; На выходе
0036+  C88E             ;  все регистры сохраняются
0037+  C88E             ;----------------------------------------------------------------------------
0038+  C88E             
0039+  C88E             printHexByte:	; Сохраняем регистры
0040+  C88E C5          		push	b
0041+  C88F F5          		push	psw
0042+  C890             
0043+  C890             		; Сохраняем A для вывода второй цифры
0044+  C890 47          		mov	b, a
0045+  C891             
0046+  C891             		; Первая цифра - старшие 4 бита
0047+  C891 07          		rlc
0048+  C892 07          		rlc
0049+  C893 07          		rlc
0050+  C894 07          		rlc
0051+  C895 CD 9F C8    		call	printHexNibble
0052+  C898             
0053+  C898             		; Вторая цифра - младщие 4 бита
0054+  C898 78          		mov	a, b
0055+  C899 CD 9F C8    		call	printHexNibble
0056+  C89C             
0057+  C89C             		; Восстаналиваем регистры
0058+  C89C F1          		pop	psw
0059+  C89D C1          		pop	b
0060+  C89E C9          		ret
0061+  C89F             
0062+  C89F             ;----------------------------------------------------------------------------
0063+  C89F             ; Вывод 16-ричного числа на экран (цифра)
0064+  C89F             ;
0065+  C89F             ; На входе
0066+  C89F             ;  a - число, используются младшие 4 бита
0067+  C89F             ;
0068+  C89F             ; На выходе
0069+  C89F             ;  c, a - изменяются, остальные регистры сохраняются
0070+  C89F             ;----------------------------------------------------------------------------
0071+  C89F             
0072+  C89F E6 0F       printHexNibble:	ani	0Fh
0073+  C8A1 C6 30       		adi	'0'
0074+  C8A3 FE 3A       		cpi	'9'+1
0075+  C8A5 DA AA C8    		jc	printHexNib_0
0076+  C8A8 C6 07       		  adi	'A'-'0'-10
0077+  C8AA 4F          printHexNib_0:	mov	c, a
0078+  C8AB C3 09 C8    		jmp	j_printChar
0079+  C8AE             
0189   C8AE             .include "input.inc"
0001+  C8AE             ;+---------------------------------------------------------------------------
0002+  C8AE             ; MXOS
0003+  C8AE             ; Ввод строки
0004+  C8AE             ;
0005+  C8AE             ; На входе
0006+  C8AE             ;  hl - начало буфера
0007+  C8AE             ;  de - конец буфера
0008+  C8AE             ;
0009+  C8AE             ; На выходе
0010+  C8AE             ;  bc, de, hl - сохраняются
0011+  C8AE             ;
0012+  C8AE             ; 2013-12-12 Дизассемблировано vinxru
0013+  C8AE             ;----------------------------------------------------------------------------
0014+  C8AE             
0015+  C8AE             input:		; Сохраняем регистры
0016+  C8AE E5          		push	h
0017+  C8AF C5          		push	b
0018+  C8B0 F5          		push	psw
0019+  C8B1             
0020+  C8B1             		; Сохраняем значения
0021+  C8B1 22 C1 CE    		shld	v_input_start
0022+  C8B4 EB          		xchg
0023+  C8B5 22 C7 CE    		shld	v_input_end
0024+  C8B8             
0025+  C8B8             		; Помещаем в конец буфера 0
0026+  C8B8 62          		mov	h, d
0027+  C8B9 6B          		mov	l, e
0028+  C8BA 36 00       		mvi	m, 0
0029+  C8BC             
0030+  C8BC             input_loop:	; Ждем клавиашу
0031+  C8BC CD 03 C8    		call	j_getch
0032+  C8BF 4F          		mov	c, a
0033+  C8C0             
0034+  C8C0             		; Нажата служебная клавиша
0035+  C8C0 FE 20       		cpi	20h
0036+  C8C2 DA 17 C9    		jc	input_spec
0037+  C8C5             
0038+  C8C5             		; Нажата клавиша Back space
0039+  C8C5 FE 7F       		cpi	7Fh
0040+  C8C7 CA 06 C9    		jz	input_bkspc
0041+  C8CA             
0042+  C8CA             		; ...
0043+  C8CA 00          		nop
0044+  C8CB 00          		nop
0045+  C8CC 00          		nop
0046+  C8CD             
0047+  C8CD             		; Это конец буфера
0048+  C8CD E5          		push	h
0049+  C8CE 2A C7 CE    		lhld	v_input_end
0050+  C8D1 CD 49 C9    		call	cmp_hl_de_2
0051+  C8D4 E1          		pop	h
0052+  C8D5 C2 E1 C8    		jnz	loc_C8DE		
0053+  C8D8 CD 49 C9    		call	cmp_hl_de_2
0054+  C8DB CA BC C8    		jz	input_loop
0055+  C8DE 1A          		ldax	d
0056+  C8DF 1B          		dcx	d
0057+  C8E0 12          		stax	d
0058+  C8E1 C5          loc_C8DE:	push	b
0059+  C8E2 44          		mov	b, h
0060+  C8E3 4D          		mov	c, l
0061+  C8E4 03          		inx	b
0062+  C8E5 CD 57 C9    		call	memmove_bc_hl
0063+  C8E8 C1          		pop	b
0064+  C8E9 71          		mov	m, c		; *hl++	= c;
0065+  C8EA CD 09 C8    		call	j_printChar	; Вывод	символа	на экран
0066+  C8ED 23          		inx	h
0067+  C8EE 13          		inx	d		
0068+  C8EF E5          loc_C8EC:	push	h
0069+  C8F0 2A FC 8F    		lhld	v_cursorY
0070+  C8F3 E3          		xthl
0071+  C8F4 E5          		push	h
0072+  C8F5 CD 18 C8    		call	j_printString
0073+  C8F8 0E 20       		mvi	c, ' '
0074+  C8FA CD 09 C8    		call	j_printChar
0075+  C8FD E1          		pop	h
0076+  C8FE E3          		xthl
0077+  C8FF 22 FC 8F    		shld	v_cursorY
0078+  C902 E1          		pop	h
0079+  C903             
0080+  C903             		; Продолжение
0081+  C903 C3 BC C8    		jmp	input_loop
0082+  C906             
0083+  C906             ; ---------------------------------------------------------------------------
0084+  C906             
0085+  C906             input_bkspc:	; Если курсор в начале строки ничего не удаляем
0086+  C906 CD 49 C9    		call	cmp_hl_de_2
0087+  C909 CA BC C8    		jz	input_loop
0088+  C90C             
0089+  C90C             		; Сдвигаем строку
0090+  C90C 44          		mov	b, h
0091+  C90D 4D          		mov	c, l
0092+  C90E 23          		inx	h
0093+  C90F CD 57 C9    		call	memmove_bc_hl
0094+  C912             
0095+  C912             		; Уменьшаем положение курсора
0096+  C912 2B          		dcx	h
0097+  C913             
0098+  C913 1B          		dcx	d
0099+  C914 C3 EF C8    		jmp	loc_C8EC
0100+  C917             
0101+  C917             ; ---------------------------------------------------------------------------
0102+  C917             
0103+  C917             input_spec:	; Нажато влево
0104+  C917 FE 08       		cpi	8
0105+  C919 CA 2B C9    		jz	input_left
0106+  C91C             
0107+  C91C             		; Нажато вправо
0108+  C91C FE 18       		cpi	18h
0109+  C91E CA 3F C9    		jz	input_right
0110+  C921             
0111+  C921             		; Нажат не ввод
0112+  C921 FE 0D       		cpi	0Dh
0113+  C923 C2 BC C8    		jnz	input_loop
0114+  C926             
0115+  C926             		; Нажат ввод
0116+  C926             
0117+  C926             		; Сохраняем в конец стрки 0D
0118+  C926 12          		stax	d
0119+  C927             
0120+  C927             		; Восстанавливаем регистры и выходим
0121+  C927 F1          		pop	psw
0122+  C928 C1          		pop	b
0123+  C929 E1          		pop	h
0124+  C92A C9          		ret
0125+  C92B             
0126+  C92B             ; ---------------------------------------------------------------------------
0127+  C92B             
0128+  C92B             input_left:	; Если курсор в начале строки (hl==v_input_start) не перемещаем курсор
0129+  C92B EB          		xchg
0130+  C92C E5          		push	h		
0131+  C92D 2A C1 CE    		lhld	v_input_start
0132+  C930 CD 49 C9    		call	cmp_hl_de_2
0133+  C933 E1          		pop	h
0134+  C934 EB          		xchg
0135+  C935 CA BC C8    		jz	input_loop
0136+  C938             
0137+  C938             		; Уменьшаем положение курсора
0138+  C938 2B          		dcx	h
0139+  C939             
0140+  C939             input_lr:	; Перемещаем курсор вправо/влево
0141+  C939 CD 09 C8    		call	j_printChar
0142+  C93C             
0143+  C93C             		; Продолжаем ввод
0144+  C93C C3 BC C8    		jmp	input_loop
0145+  C93F             
0146+  C93F             ; ---------------------------------------------------------------------------
0147+  C93F             
0148+  C93F             input_right:	; Если курсор в конце строк (hl==de) не перемещаем курсор
0149+  C93F CD 49 C9    		call	cmp_hl_de_2
0150+  C942 CA BC C8    		jz	input_loop
0151+  C945             
0152+  C945             		; Увеличиваем положение курсора
0153+  C945 23          		inx	h
0154+  C946             
0155+  C946             		; Общее продолжение
0156+  C946 C3 39 C9    		jmp	input_lr
0157+  C949             
0190   C949             .include "cmp_hl_de_2.inc"
0001+  C949             ;+---------------------------------------------------------------------------
0002+  C949             ; MXOS
0003+  C949             ; Сравнить HL и DE
0004+  C949             ;
0005+  C949             ; 2013-12-12 Дизассемблировано vinxru
0006+  C949             ;----------------------------------------------------------------------------
0007+  C949             
0008+  C949 7C          cmp_hl_de_2:	mov	a, h
0009+  C94A BA          		cmp	d
0010+  C94B D8          		rc
0011+  C94C C0          		rnz
0012+  C94D 7D          		mov	a, l
0013+  C94E BB          		cmp	e
0014+  C94F C9          		ret
0015+  C950             
0191   C950             .include "sbb_de_hl_to_hl.inc"
0001+  C950             ;+---------------------------------------------------------------------------
0002+  C950             ; MXOS
0003+  C950             ; HL = DE - HL
0004+  C950             ;
0005+  C950             ; 2013-12-12 Дизассемблировано vinxru
0006+  C950             ;----------------------------------------------------------------------------
0007+  C950             
0008+  C950             sbb_de_hl_to_hl:
0009+  C950 7B          		mov	a, e
0010+  C951 95          		sub	l
0011+  C952 6F          		mov	l, a
0012+  C953 7A          		mov	a, d
0013+  C954 9C          		sbb	h
0014+  C955 67          		mov	h, a
0015+  C956 C9          		ret
0016+  C957             
0192   C957             .include "memmove_bc_hl.inc"
0001+  C957             ;+---------------------------------------------------------------------------
0002+  C957             ; MXOS
0003+  C957             ; Копирование накладывающихся блоков памяти (с ошибкой)
0004+  C957             ;
0005+  C957             ; На входе
0006+  C957             ;  hl - откуда
0007+  C957             ;  de - откуда, конечный адрес не включая
0008+  C957             ;  bc - куда BC с увеличением адресов
0009+  C957             ;
0010+  C957             ; 2013-12-12 Дизассемблировано vinxru
0011+  C957             ;----------------------------------------------------------------------------
0012+  C957             
0013+  C957             memmove_bc_hl:	; Сохраняем регистры
0014+  C957 E5          		push	h
0015+  C958 C5          		push	b
0016+  C959 D5          		push	d
0017+  C95A             
0018+  C95A             		; Если b<h или c<l, то
0019+  C95A 78          		mov	a, b
0020+  C95B BC          		cmp	h
0021+  C95C DA 79 C9    		jc	memcpy_bc_hl2
0022+  C95F             		; Тут не хватает jnz
0023+  C95F 79          		mov	a, c
0024+  C960 BD          		cmp	l
0025+  C961 DA 79 C9    		jc	memcpy_bc_hl2
0026+  C964             
0027+  C964             		; bc = bc + de - hl
0028+  C964 E5          		push	h		
0029+  C965 CD 50 C9    		call	sbb_de_hl_to_hl
0030+  C968 09          		dad	b
0031+  C969 44          		mov	b, h
0032+  C96A 4D          		mov	c, l
0033+  C96B E1          		pop	h
0034+  C96C             
0035+  C96C             memcpyb_bc_de:	; Копируем из DE в BC с уменьшением адресов, пока HL не равно DE
0036+  C96C 1A          		ldax	d
0037+  C96D 02          		stax	b
0038+  C96E CD 49 C9    		call	cmp_hl_de_2
0039+  C971 1B          		dcx	d
0040+  C972 0B          		dcx	b
0041+  C973 C2 6C C9    		jnz	memcpyb_bc_de
0042+  C976             
0043+  C976             		; Восстановление регистров и выход
0044+  C976 C3 83 C9    		jmp	pop_dbh_ret2
0045+  C979             
0046+  C979             ; ---------------------------------------------------------------------------
0047+  C979             
0048+  C979             memcpy_bc_hl2:	; Копируем из HL в BC с увеличением адресов, пока HL не равно DE
0049+  C979 7E          		mov	a, m
0050+  C97A 02          		stax	b
0051+  C97B CD 49 C9    		call	cmp_hl_de_2
0052+  C97E 23          		inx	h
0053+  C97F 03          		inx	b
0054+  C980 C2 79 C9    		jnz	memcpy_bc_hl2
0055+  C983             
0056+  C983             pop_dbh_ret2:	; Восстановление регистров и выход
0057+  C983 D1          		pop	d
0058+  C984 C1          		pop	b
0059+  C985 E1          		pop	h
0060+  C986 C9          		ret
0061+  C987             
0193   C987             .include "calcCS.inc"
0001+  C987             ;+---------------------------------------------------------------------------
0002+  C987             ; MXOS
0003+  C987             ; Расчет контрольной суммы
0004+  C987             ;
0005+  C987             ; На входе
0006+  C987             ;  hl - начальный адрес
0007+  C987             ;  de - конечный адрес
0008+  C987             ;
0009+  C987             ; На выходе
0010+  C987             ;  bc - контрольная сумма
0011+  C987             ;
0012+  C987             ; 2013-12-12 Дизассемблировано vinxru
0013+  C987             ;----------------------------------------------------------------------------
0014+  C987             
0015+  C987 01 00 00    calcCS:		lxi	b, 0
0016+  C98A 7E          calcCS_1:	mov	a, m
0017+  C98B 81          		add	c
0018+  C98C 4F          		mov	c, a
0019+  C98D F5          		push	psw
0020+  C98E CD 49 C9    		call	cmp_hl_de_2
0021+  C991 CA 9C C9    		jz	calcCS_2
0022+  C994 F1          		pop	psw
0023+  C995 78          		mov	a, b
0024+  C996 8E          		adc	m
0025+  C997 47          		mov	b, a
0026+  C998 23          		inx	h
0027+  C999 C3 8A C9    		jmp	calcCS_1
0028+  C99C             
0029+  C99C             ; ---------------------------------------------------------------------------
0030+  C99C             
0031+  C99C F1          calcCS_2:	pop	psw
0032+  C99D C9          		ret
0033+  C99E             
0194   C99E             .include "tapeSave.inc"
0001+  C99E             ;+---------------------------------------------------------------------------
0002+  C99E             ; MXOS
0003+  C99E             ; Запись программы на ленту
0004+  C99E             ;
0005+  C99E             ; На входе
0006+  C99E             ;  hl - начальный адрес
0007+  C99E             ;  de - конечный адрес
0008+  C99E             ;
0009+  C99E             ; На выходе
0010+  C99E             ;  bc - контрольная сумма
0011+  C99E             ;  de,hl - сохраняются
0012+  C99E             ;
0013+  C99E             ; 2013-12-12 Дизассемблировано vinxru
0014+  C99E             ;----------------------------------------------------------------------------
0015+  C99E             
0016+  C99E             tapeSave:	; Расчитываем CRC
0017+  C99E E5          		push	h
0018+  C99F CD 87 C9    		call	calcCS
0019+  C9A2 E1          		pop	h
0020+  C9A3             
0021+  C9A3 E5          		push	h
0022+  C9A4 C5          		push	b
0023+  C9A5             
0024+  C9A5             		; Пилот-тон (256 нулей)
0025+  C9A5 06 00       		mvi	b, 0
0026+  C9A7 AF          loc_C9A4:	xra	a
0027+  C9A8 CD 0C C8    		call	j_tapeWrite
0028+  C9AB 05          		dcr	b
0029+  C9AC C2 A7 C9    		jnz	loc_C9A4
0030+  C9AF             
0031+  C9AF             		; Стартовый байт 0E6h
0032+  C9AF 3E E6       		mvi	a, 0E6h
0033+  C9B1 CD 0C C8    		call	j_tapeWrite
0034+  C9B4             
0035+  C9B4             		; Запись адреса первого байта
0036+  C9B4 CD CF C9    		call	tapeWriteWord
0037+  C9B7 EB          		xchg
0038+  C9B8             
0039+  C9B8             		; Запись адреса последнего байта
0040+  C9B8 CD CF C9    		call	tapeWriteWord
0041+  C9BB EB          		xchg
0042+  C9BC             		
0043+  C9BC             loc_C9B9:	; Запись блока памяти от HL до DE
0044+  C9BC 7E          		mov	a, m
0045+  C9BD CD 0C C8    		call	j_tapeWrite
0046+  C9C0 CD 49 C9    		call	cmp_hl_de_2
0047+  C9C3 23          		inx	h
0048+  C9C4 C2 BC C9    		jnz	loc_C9B9
0049+  C9C7             
0050+  C9C7             		; Запись CRC
0051+  C9C7 E1          		pop	h
0052+  C9C8 CD CF C9    		call	tapeWriteWord
0053+  C9CB             
0054+  C9CB             		; Возвращаем CRC в регистре BC
0055+  C9CB 44          		mov	b, h
0056+  C9CC 4D          		mov	c, l
0057+  C9CD             
0058+  C9CD             		; Восстанавливаем регистры и выходим
0059+  C9CD E1          		pop	h
0060+  C9CE C9          		ret
0061+  C9CF             
0195   C9CF             .include "tapeWriteWord.inc"
0001+  C9CF             ;+---------------------------------------------------------------------------
0002+  C9CF             ; MXOS
0003+  C9CF             ; Запись слова на ленту
0004+  C9CF             ;
0005+  C9CF             ; На входе
0006+  C9CF             ;  hl - слово
0007+  C9CF             ;
0008+  C9CF             ; На выходе
0009+  C9CF             ;  bc,de,hl - сохраняются
0010+  C9CF             ;
0011+  C9CF             ; 2013-12-12 Дизассемблировано vinxru
0012+  C9CF             ;----------------------------------------------------------------------------
0013+  C9CF             
0014+  C9CF 7D          tapeWriteWord:	mov	a, l
0015+  C9D0 CD 0C C8    		call	j_tapeWrite
0016+  C9D3 7C          		mov	a, h
0017+  C9D4 C3 0C C8    		jmp	j_tapeWrite
0018+  C9D7             
0196   C9D7             .include "tapeLoad.inc"
0001+  C9D7             ;+---------------------------------------------------------------------------
0002+  C9D7             ; MXOS
0003+  C9D7             ; Загрузка программы с ленты. КС загружается, но не проверяется.
0004+  C9D7             ;
0005+  C9D7             ; В случае ошибки управление передается по адресу в v_tapeError
0006+  C9D7             ;
0007+  C9D7             ; На выходе 
0008+  C9D7             ;  bc - контольная сумма
0009+  C9D7             ;  hl, v_tapeAddr - адрес загруженной программы
0010+  C9D7             ;
0011+  C9D7             ; 2013-12-12 Дизассемблировано vinxru
0012+  C9D7             ;----------------------------------------------------------------------------
0013+  C9D7             
0014+  C9D7             tapeLoad:	; Загружаем файл с ленты без загрузки КС
0015+  C9D7 CD F9 C3    		call	tapeLoadInt
0016+  C9DA             
0017+  C9DA             		; Читаем КС
0018+  C9DA 3E 08       		mvi	a, 8
0019+  C9DC CD 06 C8    		call	j_tapeRead
0020+  C9DF 4F          		mov	c, a
0021+  C9E0 3E 08       		mvi	a, 8
0022+  C9E2 CD 06 C8    		call	j_tapeRead
0023+  C9E5 47          		mov	b, a
0024+  C9E6             
0025+  C9E6             		; В HL возврааем адрес запуска
0026+  C9E6 2A E3 8F    		lhld	v_tapeAddr
0027+  C9E9 C9          		ret
0028+  C9EA             
0197   C9EA             .include "reboot3.inc"
0001+  C9EA             ;+---------------------------------------------------------------------------
0002+  C9EA             ; MXOS
0003+  C9EA             ; Обновление драйвера по адресу 0FFC0h и запуск NC.COM
0004+  C9EA             ;
0005+  C9EA             ; А так же однократный запуск AUTOEX.BAT, если не нажата клавиша.
0006+  C9EA             ;
0007+  C9EA             ; 2013-12-12 Дизассемблировано vinxru
0008+  C9EA             ;----------------------------------------------------------------------------
0009+  C9EA             
0010+  C9EA             reboot3:	; Инициализация стека
0011+  C9EA 31 C0 FF    		lxi	sp, STACK_ADDR
0012+  C9ED             
0013+  C9ED             		; Копируем драйвер в отведенное для него место
0014+  C9ED 21 F8 CA    		lxi	h, driverStart
0015+  C9F0 11 16 CB    		lxi	d, driverEnd
0016+  C9F3 01 C0 FF    		lxi	b, 0FFC0h
0017+  C9F6 CD 57 C9    		call	memmove_bc_hl
0018+  C9F9             
0019+  C9F9             		; Обновляем переменные
0020+  C9F9 21 00 C8    		lxi	h, j_reboot3
0021+  C9FC 22 E1 8F    		shld	v_tapeError
0022+  C9FF             
0023+  C9FF             		; Код ниже будет выполнен лишь один раз после холодной перезагрузки.
0024+  C9FF             		; То есть при теплой перезагрузке он не вызывается.
0025+  C9FF             reboot3_0:
0026+  C9FF C3 02 CA    		jmp	reboot3_1
0027+  CA02             reboot3_1:
0028+  CA02 21 16 CA    		lxi	h, reboot3_2
0029+  CA05 22 00 CA    		shld	reboot3_0+1
0030+  CA08             
0031+  CA08             		; Если нажата клавиша, пропустить запуск A:AUTOEX.BAT
0032+  CA08 3A E1 FF    		lda	IO_KEYB_B	
0033+  CA0B E6 02       		ani	2
0034+  CA0D CA 16 CA    		jz	reboot3_2
0035+  CA10             
0036+  CA10             		; Запуск файла A:AUTOEX.BAT
0037+  CA10 21 D6 CE    		lxi	h, aAAutoex_bat
0038+  CA13 CD 73 CA    		call	fileExec
0039+  CA16             
0040+  CA16             reboot3_2:
0041+  CA16             		; Запуск файла NC.COM
0042+  CA16 21 CD CE    		lxi	h, aANc_com
0043+  CA19 CD 73 CA    		call	fileExec
0044+  CA1C             
0045+  CA1C             		; Теплая перезагрузка
0046+  CA1C C3 00 C8    		jmp	j_reboot3
0047+  CA1F             
0198   CA1F             .include "fileExecBat.inc"
0001+  CA1F             ;+---------------------------------------------------------------------------
0002+  CA1F             ; MXOS
0003+  CA1F             ; Запустить BAT файл. Вызывается функцией fileExec
0004+  CA1F             ;
0005+  CA1F             ; 2013-12-12 Дизассемблировано vinxru
0006+  CA1F             ;----------------------------------------------------------------------------
0007+  CA1F             
0008+  CA1F             execBat:
0009+  CA1F D1          		pop	d
0010+  CA20             
0011+  CA20             		; Устанавливаем адрес загрузки BAT-файла на diskDirectory
0012+  CA20 21 00 FC    		lxi  h, diskDirectory
0013+  CA23 22 C9 CE    		shld v_batPtr
0014+  CA26 EB          		xchg
0015+  CA27             
0016+  CA27             		; Изменяем адрес загрузки BAT-файла
0017+  CA27                     ; TODO: это не работает с ром-диском (A: без поддержки записи). Поэтому
0018+  CA27                     ; нельзя запустить BAT-файл с диска A:, если его адрес загрузки в каталоге
0019+  CA27                     ; уже не прошит как FC00h (= &diskDirectory)
0020+  CA27 21 EC CE    		lxi  h, v_fileName
0021+  CA2A 0E 01       		mvi  c, 1
0022+  CA2C CD 81 CD    		call fileGetSetAddr
0023+  CA2F DA D4 CA    		jc   badCommand
0024+  CA32             
0025+  CA32             		; Сохраняем имя BAT-файла
0026+  CA32 21 EC CE    		lxi  h, v_fileName	
0027+  CA35 11 FB CE    		lxi  d, v_fileName_end
0028+  CA38 01 FC CE    		lxi  b, v_batFileName
0029+  CA3B CD 57 C9    		call memmove_bc_hl
0030+  CA3E             
0031+  CA3E             		; Сохраняем диск содержащий BAT-файл
0032+  CA3E 3A C0 CE    		lda	v_drive
0033+  CA41 32 49 CA    		sta	v_batDrive+1 ; самомодификация кода
0034+  CA44             
0035+  CA44                     ; Этот цикл выполняется для каждой строки BAT-файла
0036+  CA44             execBat_loop:
0037+  CA44             
0038+  CA44             		; Сохраняем текущий диск в регистре B
0039+  CA44 3A C0 CE    		lda  v_drive
0040+  CA47 47          		mov  b, a
0041+  CA48             
0042+  CA48             v_batDrive:
0043+  CA48                     ; Выбрать диск содержащий BAT файл
0044+  CA48 3E 01       		mvi  a, 1 ; << сюда вместо 1 пишется диск, содержащий BAT файл
0045+  CA4A CD 89 CB    		call fileSelectDrive
0046+  CA4D             
0047+  CA4D             		; Загрузить BAT-файл в память
0048+  CA4D 21 FC CE    		lxi  h, v_batFileName 
0049+  CA50 CD D3 CC    		call fileLoad
0050+  CA53 2A C9 CE    		lhld v_batPtr
0051+  CA56             
0052+  CA56             		; Сохраняем начало строки
0053+  CA56 54          		mov	d, h
0054+  CA57 5D          		mov	e, l
0055+  CA58             
0056+  CA58                     ; Ищем конец строки
0057+  CA58             execBat_0:
0058+  CA58 7E          		mov	a, m		
0059+  CA59 23          		inx	h
0060+  CA5A             
0061+  CA5A             		; Найден конец строки, запускаем файл
0062+  CA5A FE 0D       		cpi	0Dh		
0063+  CA5C CA 65 CA    		jz	execBat_1
0064+  CA5F             
0065+  CA5F             		; Конец	файла
0066+  CA5F FE FF       		cpi	0FFh		
0067+  CA61 C2 58 CA    		jnz	execBat_0
0068+  CA64 C9          		ret
0069+  CA65             
0070+  CA65             ; ---------------------------------------------------------------------------
0071+  CA65             
0072+  CA65             execBat_1:
0073+  CA65                     ; Сохраняем указатель
0074+  CA65 22 C9 CE    		shld v_batPtr	
0075+  CA68             
0076+  CA68             		; Восстановление активного диска		
0077+  CA68 78          		mov  a, b		
0078+  CA69 CD 89 CB    		call fileSelectDrive
0079+  CA6C             
0080+  CA6C             		; Запустить файл
0081+  CA6C EB          		xchg			
0082+  CA6D CD 73 CA    		call fileExec
0083+  CA70             
0084+  CA70 C3 44 CA    		jmp execBat_loop
0085+  CA73             
0199   CA73             .include "fileExec.inc"
0001+  CA73             ;+---------------------------------------------------------------------------
0002+  CA73             ; MXOS
0003+  CA73             ; Запустить файл
0004+  CA73             ;
0005+  CA73             ; На входе
0006+  CA73             ;  hl - ком строка в формате [Диск:]файл[ аргументы]
0007+  CA73             ;
0008+  CA73             ; На выходе
0009+  CA73             ;  сf - ошибка
0010+  CA73             ;
0011+  CA73             ; 2013-12-12 Дизассемблировано vinxru
0012+  CA73             ;----------------------------------------------------------------------------
0013+  CA73             
0014+  CA73             fileExec:	; Сюда будем записывать результат
0015+  CA73 11 00 FF    		lxi d, v_cmdLine
0016+  CA76             		
0017+  CA76             		; Если первый символ меньше пробела, выходим c CF
0018+  CA76 7E          		mov a, m
0019+  CA77 FE 20       		cpi ' '
0020+  CA79 DA DA CA    		jc  stc_ret
0021+  CA7C             
0022+  CA7C             		; Максимальный размер ком строки (+2 терминатора, итого 82h)
0023+  CA7C 0E 80       		mvi c, 80h		
0024+  CA7E             
0025+  CA7E             fileExec_0:	; Если символ меньше пробела, выходим
0026+  CA7E 7E          		mov a, m
0027+  CA7F FE 20       		cpi 20h
0028+  CA81 DA 8B CA    		jc  fileExec_1
0029+  CA84             
0030+  CA84             		; Копируем симовол из HL в DE
0031+  CA84 12          		stax d
0032+  CA85 23          		inx  h
0033+  CA86 13          		inx  d
0034+  CA87             
0035+  CA87             		; Повторяем 80h раз
0036+  CA87 0D          		dcr c
0037+  CA88 C2 7E CA    		jnz fileExec_0
0038+  CA8B             
0039+  CA8B             fileExec_1:	; В конец имени помещаем 13,0
0040+  CA8B 3E 0D       		mvi  a, 0Dh
0041+  CA8D 12          		stax d
0042+  CA8E 13          		inx  d
0043+  CA8F AF          		xra  a
0044+  CA90 12          		stax d
0045+  CA91             
0046+  CA91             		; Выводим на экран 0Ah
0047+  CA91 CD DC CA    		call printCharA
0048+  CA94             
0049+  CA94             		; Вывод имени файла на экран
0050+  CA94 21 00 FF    		lxi  h, v_cmdLine
0051+  CA97 CD 18 C8    		call j_printString
0052+  CA9A             
0053+  CA9A             		; Подготовка имени файла
0054+  CA9A 21 00 FF    		lxi  h, v_cmdLine
0055+  CA9D 11 EC CE    		lxi  d, v_fileName
0056+  CAA0 CD D5 CD    		call fileNamePrepare
0057+  CAA3             
0058+  CAA3                     ; Запоминаем в стеке текущий адрес командной строки (начало спаска аргументов)
0059+  CAA3 E5          		push h
0060+  CAA4             
0061+  CAA4             		; Если это BAT файл
0062+  CAA4 11 E3 CE    		lxi  d, aBat ; "BAT"
0063+  CAA7 CD E1 CA    		call cmpFileExt
0064+  CAAA CA 1F CA    		jz   execBat
0065+  CAAD             
0066+  CAAD             		; Если это COM или EXE файл
0067+  CAAD CD E1 CA    		call cmpFileExt
0068+  CAB0 CA B9 CA    		jz   execExeCom
0069+  CAB3 CD E1 CA    		call cmpFileExt
0070+  CAB6 C2 D3 CA    		jnz  execError
0071+  CAB9             
0072+  CAB9             execExeCom:
0073+  CAB9                     ; Вытаскиваем из стека текущий адрес командной строки (начало спаска аргументов)
0074+  CAB9 D1          		pop	d
0075+  CABA             
0076+  CABA             		; Загрузить файл
0077+  CABA 21 EC CE    		lxi  h, v_fileName
0078+  CABD CD D3 CC    		call fileLoad
0079+  CAC0 DA D4 CA    		jc   badCommand
0080+  CAC3             
0081+  CAC3                     ; Адрес командной строки
0082+  CAC3 D5          		push d
0083+  CAC4             
0084+  CAC4             		; Выводим на экран 0Ah
0085+  CAC4             		;call	printCharA
0086+  CAC4             
0087+  CAC4             		; Получаем адрес загрузки (= адрес запуска) файла в DE
0088+  CAC4 11 0A 00    		lxi	d, 10
0089+  CAC7 19          		dad	d   ; HL += 10
0090+  CAC8 5E          		mov	e, m
0091+  CAC9 23          		inx	h
0092+  CACA 56          		mov	d, m
0093+  CACB             
0094+  CACB             		; Адрес возврата
0095+  CACB 21 D1 CA    		lxi	h, defAppReturn
0096+  CACE E3          		xthl
0097+  CACF             
0098+  CACF             		; Запуск программы (переход на DE)
0099+  CACF EB          		xchg    ; HL <--> DE
0100+  CAD0 E9          		pchl    ; PC <-- HL
0101+  CAD1             
0102+  CAD1             ; ---------------------------------------------------------------------------
0103+  CAD1             
0104+  CAD1             defAppReturn:
0105+  CAD1 B7          		ora	a
0106+  CAD2 C9          		ret
0107+  CAD3             
0108+  CAD3             ; ---------------------------------------------------------------------------
0109+  CAD3             
0110+  CAD3             execError:
0111+  CAD3 D1                  pop d
0112+  CAD4             badCommand:
0113+  CAD4 21 94 CE            lxi  h, aBadCommandOrFi ; "\nBAD COMMAND OR FILE NAME"
0114+  CAD7 CD 18 C8            call j_printString
0115+  CADA             stc_ret:
0116+  CADA 37                  stc
0117+  CADB C9                  ret
0118+  CADC             
0119+  CADC             ; ---------------------------------------------------------------------------
0120+  CADC             
0121+  CADC             printCharA:
0122+  CADC 0E 0A               mvi c, 0Ah
0123+  CADE C3 09 C8            jmp j_printChar
0124+  CAE1             
0200   CAE1             .include "fileCmpExt.inc"
0001+  CAE1             ;+---------------------------------------------------------------------------
0002+  CAE1             ; MXOS
0003+  CAE1             ; Сранивать расширения файлов
0004+  CAE1             ;
0005+  CAE1             ; На входе
0006+  CAE1             ;  de - адрес расширения 1
0007+  CAE1             ;  v_fileName_ext - расширение 2
0008+  CAE1             ;
0009+  CAE1             ; На выходе
0010+  CAE1             ;  zf=0 - расширения равны
0011+  CAE1             ;  de - de+3
0012+  CAE1             ;
0013+  CAE1             ; 2013-12-12 Дизассемблировано vinxru
0014+  CAE1             ;----------------------------------------------------------------------------
0015+  CAE1             
0016+  CAE1 21 F2 CE    cmpFileExt:	lxi	h, v_fileName_ext
0017+  CAE4             
0018+  CAE4             		; Сравниваем 3 символа
0019+  CAE4 01 03 00                    lxi	b, 3
0020+  CAE7 1A          cmpFileExt_0:	ldax	d
0021+  CAE8 BE          		cmp	m
0022+  CAE9 C2 F2 CA    		jnz	cmpFileExt_1
0023+  CAEC 23          		inx	h
0024+  CAED 13          		inx	d
0025+  CAEE 0D          		dcr	c
0026+  CAEF C2 E7 CA    		jnz	cmpFileExt_0
0027+  CAF2             
0028+  CAF2             		; ZF=1 если равны
0029+  CAF2             
0030+  CAF2             cmpFileExt_1:	; Делаем так, что бы DE на выходе функции был на 3 больше, 
0031+  CAF2             		; чем на входе в функцию
0032+  CAF2 F5          		push	psw
0033+  CAF3 EB          		xchg
0034+  CAF4 09          		dad	b
0035+  CAF5 EB          		xchg
0036+  CAF6 F1          		pop	psw
0037+  CAF7             
0038+  CAF7             		; Выход
0039+  CAF7 C9          		ret
0040+  CAF8             
0201   CAF8             .include "driver_FFC0.inc"
0001+  CAF8             ;+---------------------------------------------------------------------------
0002+  CAF8             ; MXOS
0003+  CAF8             ; Драйвер диска в ДОЗУ, ПЗУ (часть которая копируется на адрес 0FFC0h)
0004+  CAF8             ;
0005+  CAF8             ; FFC0h - чтение 256-байтного блока
0006+  CAF8             ;   На входе
0007+  CAF8             ;     c = номер страницы
0008+  CAF8             ;     d = номер блока 
0009+  CAF8             ;     e = 0
0010+  CAF8             ;     hl = адрес буфера в памяти
0011+  CAF8             ;
0012+  CAF8             ; FFD0h - запись 256-байтного блока
0013+  CAF8             ;   На входе
0014+  CAF8             ;     c = номер страницы
0015+  CAF8             ;     d = номер блока 
0016+  CAF8             ;     e = 0
0017+  CAF8             ;     hl = адрес буфера в памяти
0018+  CAF8             ;
0019+  CAF8             ; 2013-12-12 Дизассемблировано и доработано vinxru
0020+  CAF8             ;----------------------------------------------------------------------------
0021+  CAF8             
0022+  CAF8~            #if BIG_MEM==0
0023+  CAF8~            
0024+  CAF8~            ; ---------------------------------------------------------------------------
0025+  CAF8~            ; Чтение 256-байтного блока с диска
0026+  CAF8~            
0027+  CAF8~            driverStart:
0028+  CAF8~            driverR:
0029+  CAF8~            		sta  IO_ARAM		; Сюда встает STA IO_ROM для ROM-диска
0030+  CAF8~            		ldax d
0031+  CAF8~            		sta  IO_RAM
0032+  CAF8~            		mov  m, a
0033+  CAF8~            		inx  h
0034+  CAF8~            		inr  e
0035+  CAF8~            		jnz  0FFC0h
0036+  CAF8~            		ret
0037+  CAF8~            
0038+  CAF8~            ; ---------------------------------------------------------------------------
0039+  CAF8~            
0040+  CAF8~            		.db 0FFh
0041+  CAF8~            		.db 0FFh
0042+  CAF8~            
0043+  CAF8~            ; ---------------------------------------------------------------------------
0044+  CAF8~            ; Запись 256-байтного блока на диск
0045+  CAF8~            
0046+  CAF8~            driverW:
0047+  CAF8~            		mov  a, m		; Сюда встает RET для ROM-диска
0048+  CAF8~            		sta  IO_ARAM
0049+  CAF8~            		stax d
0050+  CAF8~            		sta  IO_RAM
0051+  CAF8~            		inx  h
0052+  CAF8~            		inr  e
0053+  CAF8~            		jnz  0FFD0h
0054+  CAF8~            driverEnd:
0055+  CAF8~            		ret
0056+  CAF8~            
0057+  CAF8             #else
0058+  CAF8             
0059+  CAF8             ; ---------------------------------------------------------------------------
0060+  CAF8             ; Чтение 256-байтного блока с диска
0061+  CAF8             
0062+  CAF8             driverStart:
0063+  CAF8 79          		mov  a, c
0064+  CAF9             driverR:
0065+  CAF9 32 FD FF    		sta  IO_ARAM		; Сюда встает STA IO_ROM для ROM-диска
0066+  CAFC 1A          		ldax d
0067+  CAFD 32 FC FF    		sta  IO_RAM
0068+  CB00 77          		mov  m, a
0069+  CB01 23          		inx  h
0070+  CB02 1C          		inr  e
0071+  CB03 C2 C0 FF    		jnz  0FFC0h
0072+  CB06 C9          		ret
0073+  CB07             
0074+  CB07             ; ---------------------------------------------------------------------------
0075+  CB07             ; Запись 256-байтного блока на диск
0076+  CB07             
0077+  CB07             loc_FFCF:
0078+  CB07 23          		inx	h
0079+  CB08             loc_FFD0:
0080+  CB08             driverW:
0081+  CB08 46          		mov  b, m		; Сюда встает RET для ROM-диска
0082+  CB09 79          		mov  a, c
0083+  CB0A 32 FD FF    		sta  IO_ARAM
0084+  CB0D 78          		mov  a, b
0085+  CB0E 12          		stax d
0086+  CB0F 32 FC FF    		sta  IO_RAM
0087+  CB12 1C          		inr  e
0088+  CB13 C2 CF FF    		jnz  0FFCFh
0089+  CB16             driverEnd:
0090+  CB16 C9          		ret
0091+  CB17             
0092+  CB17             ; ---------------------------------------------------------------------------
0093+  CB17             ; Проверка
0094+  CB17             
0095+  CB17~            #if loc_FFD0-driverStart+0FFC0h != 0FFD0h
0096+  CB17~            Entry_point_FFD0_has_been_shifted
0097+  CB17             #endif
0098+  CB17             
0099+  CB17~            #if driverEnd-driverStart+1 > 32
0100+  CB17~            Driver_did_not_fit
0101+  CB17             #endif
0102+  CB17             
0103+  CB17             #endif
0104+  CB17             
0202   CB17             .include "driver.inc"
0001+  CB17             ;+---------------------------------------------------------------------------
0002+  CB17             ; MXOS
0003+  CB17             ; Драйвер диска в ДОЗУ, ПЗУ
0004+  CB17             ;
0005+  CB17             ; Запись 256-байтного блока
0006+  CB17             ;   На входе
0007+  CB17             ;     e = 1
0008+  CB17             ;     d = номер блока 
0009+  CB17             ;     hl = адрес буфера в памяти
0010+  CB17             ;   На выходе
0011+  CB17             ;     все регистры сохраняются
0012+  CB17             ;
0013+  CB17             ; Чтение 256-байтного блока
0014+  CB17             ;   На входе
0015+  CB17             ;     e = 2
0016+  CB17             ;     d = номер блока 
0017+  CB17             ;     hl = адрес буфера в памяти
0018+  CB17             ;   На выходе
0019+  CB17             ;     все регистры сохраняются
0020+  CB17             ;
0021+  CB17             ; Получение размера накопителя
0022+  CB17             ;   На входе
0023+  CB17             ;     e = 3
0024+  CB17             ;   На выходе
0025+  CB17             ;     a = кол-во секторов на диске (для функции e=0)
0026+  CB17             ;     bc, de, hl - сохраняются
0027+  CB17             ;
0028+  CB17             ; 2013-12-12 Дизассемблировано и доработано vinxru
0029+  CB17             ;----------------------------------------------------------------------------
0030+  CB17             
0031+  CB17             #if ROM_64K
0032+  CB17             ROM_SIZE = 0
0033+  CB17~            #else
0034+  CB17~            ROM_SIZE = 0C0h
0035+  CB17             #endif
0036+  CB17             
0037+  CB17             diskDriver:	; Сохраняем регистры
0038+  CB17 E5          		push	h
0039+  CB18             #if BIG_MEM
0040+  CB18 C5          		push	b		; +1
0041+  CB19             #endif
0042+  CB19 D5          		push	d
0043+  CB1A F5          		push	psw
0044+  CB1B             
0045+  CB1B             		; Заранее загружаем в С активный диск
0046+  CB1B             #if BIG_MEM
0047+  CB1B 3A C0 CE    		lda	v_drive		; +4
0048+  CB1E 4F          		mov	c, a		; +5
0049+  CB1F 0D          		dcr	c		; +6
0050+  CB20             #endif
0051+  CB20             		; Функция 1 - Запись блока
0052+  CB20 1D          		dcr	e
0053+  CB21 CA 67 CB    		jz	diskDriver_w
0054+  CB24             
0055+  CB24             		; Функция 2 - Чтение блока
0056+  CB24 1D          		dcr	e
0057+  CB25 CA 34 CB    		jz	diskDriver_r
0058+  CB28             		
0059+  CB28             		; Функция 3 - Получение размера диска
0060+  CB28 F1          		pop	psw		
0061+  CB29~            #if BIG_MEM==0
0062+  CB29~            		lda	v_drive         ; +3
0063+  CB29~            		ana	a
0064+  CB29~            		mvi	a, ROM_SIZE
0065+  CB29             #else
0066+  CB29 0C          		inr	c
0067+  CB2A 3E 00       		mvi	a, ROM_SIZE
0068+  CB2C             #endif
0069+  CB2C CA 31 CB    		jz	diskDriver_1
0070+  CB2F 3E FF       		mvi	a, 0FFh		; Размер RAM-диска		
0071+  CB31             diskDriver_1:		
0072+  CB31             		; Восстановливаем регистры и выходим
0073+  CB31             #if BIG_MEM
0074+  CB31 C3 12 CC    		jmp	pop_dbh_ret
0075+  CB34~            #else
0076+  CB34~            		pop	d
0077+  CB34~            		pop	h
0078+  CB34~            		ret
0079+  CB34             #endif
0080+  CB34             		
0081+  CB34             ; ---------------------------------------------------------------------------
0082+  CB34             ; Функция 2 - Чтение блока
0083+  CB34             
0084+  CB34             diskDriver_r:	
0085+  CB34             #if ROM_64K
0086+  CB34             		; Это ПЗУ
0087+  CB34 0C          		inr	c
0088+  CB35 C2 5F CB    		jnz	rom_64k
0089+  CB38             		; Это старшая часть ПЗУ
0090+  CB38 3E 80       		mvi	a, 80h
0091+  CB3A AA          		xra	d
0092+  CB3B FA 5F CB    		jm	rom_64k
0093+  CB3E             		; 
0094+  CB3E 57          		mov	d, a
0095+  CB3F             		; Первые 4 байта в ПЗУ СТД это программа инициализации
0096+  CB3F 13          		inx	d
0097+  CB40 13          		inx	d
0098+  CB41 13          		inx	d
0099+  CB42 13          		inx	d
0100+  CB43             		; Включаем ПЗУ СТД (да, надо регистр цвета сбросить для этого)
0101+  CB43 AF          		xra	a
0102+  CB44 32 F8 FF    		sta	IO_COLOR
0103+  CB47             		; Включаем ПЗУ СТД
0104+  CB47             rom_64k_0:
0105+  CB47 32 FF FF    		sta	IO_PAGE_STD
0106+  CB4A             		; Чтение
0107+  CB4A 1A          		ldax	d
0108+  CB4B             		; Включение ОЗУ MX
0109+  CB4B 32 FC F7    		sta	IO_RAM-800h
0110+  CB4E             		; Запись
0111+  CB4E 77          		mov	m, a
0112+  CB4F 23          		inx	h
0113+  CB50             		; Цикл
0114+  CB50 13          		inx	d
0115+  CB51 3E 04       		mvi	a, 4
0116+  CB53 BB          		cmp	e
0117+  CB54 C2 47 CB    		jnz	rom_64k_0
0118+  CB57             		; Восстаналиваем цвет
0119+  CB57 3E F0       		mvi	a, INIT_COLOR
0120+  CB59 32 F8 FF    		sta	IO_COLOR
0121+  CB5C             		; Выходим
0122+  CB5C C3 63 CB    		jmp	popa_adh_ret
0123+  CB5F             		
0124+  CB5F 0D          rom_64k:	dcr	c
0125+  CB60             #endif
0126+  CB60~            #if BIG_MEM==0
0127+  CB60~            		; Не нужно, тут и так E=0
0128+  CB60~            		mvi	e, 0		;+1
0129+  CB60             #endif
0130+  CB60 CD C0 FF    		call	0FFC0h
0131+  CB63             
0132+  CB63             popa_adh_ret:	; Восстанавливаем регистры и выходим
0133+  CB63 F1          		pop	psw
0134+  CB64             #if BIG_MEM
0135+  CB64 C3 12 CC    		jmp	pop_dbh_ret
0136+  CB67~            #else
0137+  CB67~            		pop	d
0138+  CB67~            		pop	h
0139+  CB67~            		ret
0140+  CB67             #endif
0141+  CB67             
0142+  CB67             ; ---------------------------------------------------------------------------
0143+  CB67             ; Функция 1 - Запись блока
0144+  CB67             
0145+  CB67             diskDriver_w:	
0146+  CB67~            #if BIG_MEM==0
0147+  CB67~            		; Не нужно, тут и так E=0
0148+  CB67~            		mvi	e, 0		;-1 у нас лишний байт в драйвере
0149+  CB67             #endif
0150+  CB67 CD D0 FF    		call	0FFD0h
0151+  CB6A             
0152+  CB6A             		; Восстановливаем регистры и выходим
0153+  CB6A C3 63 CB    		jmp	popa_adh_ret
0154+  CB6D             
0203   CB6D             .include "installDriver.inc"
0001+  CB6D             ;+---------------------------------------------------------------------------
0002+  CB6D             ; MXOS
0003+  CB6D             ; Установить драйвер устройства
0004+  CB6D             ;
0005+  CB6D             ; На входе
0006+  CB6D             ;  a - диск
0007+  CB6D             ;  hl - адрес драйвера
0008+  CB6D             ;
0009+  CB6D             ; На выходе
0010+  CB6D             ;  bc, de, hl - сохраняются
0011+  CB6D             ;
0012+  CB6D             ; 2013-12-12 Дизассемблировано vinxru
0013+  CB6D             ;----------------------------------------------------------------------------
0014+  CB6D             
0015+  CB6D             installDriver:	; Сохранение регистров
0016+  CB6D D5          		push	d
0017+  CB6E E5          		push	h
0018+  CB6F             
0019+  CB6F             		; Максимум дисков
0020+  CB6F E6 07       		ani	7
0021+  CB71             
0022+  CB71             		; Вычисление адреса в таблице дисков
0023+  CB71 87          		add	a
0024+  CB72 6F          		mov	l, a
0025+  CB73 26 00       		mvi	h, 0
0026+  CB75 11 AE CE    		lxi	d, v_drives
0027+  CB78 19          		dad	d
0028+  CB79             
0029+  CB79             		; Установка драйвера
0030+  CB79 D1          		pop	d
0031+  CB7A 73          		mov	m, e
0032+  CB7B 23          		inx	h
0033+  CB7C 72          		mov	m, d
0034+  CB7D             
0035+  CB7D             		; Восстановление регистров
0036+  CB7D EB          		xchg
0037+  CB7E D1          		pop	d
0038+  CB7F 0F          		rrc
0039+  CB80             
0040+  CB80             		; Выход
0041+  CB80 C9          		ret
0042+  CB81             
0204   CB81             .include "fileGetSetDrive.inc"
0001+  CB81             ;+---------------------------------------------------------------------------
0002+  CB81             ; MXOS
0003+  CB81             ; Получение/изменение текущего накопителя
0004+  CB81             ;
0005+  CB81             ; На входе 
0006+  CB81             ;   e  - 0=чтение, 1=изменение
0007+  CB81             ;   a  - накопитель от 0 до 7
0008+  CB81             ;
0009+  CB81             ; На выходе 
0010+  CB81             ;   a  - накопитель
0011+  CB81             ;   bc,de,hl - сохраняются
0012+  CB81             ;
0013+  CB81             ; 2013-12-12 Дизассемблировано vinxru
0014+  CB81             ;----------------------------------------------------------------------------
0015+  CB81             
0016+  CB81             fileGetSetDrive:
0017+  CB81 1D          		dcr	e
0018+  CB82 CA 89 CB    		jz	fileSelectDrive
0019+  CB85 3A C0 CE    		lda	v_drive
0020+  CB88 C9          		ret
0021+  CB89             
0022+  CB89             ; ---------------------------------------------------------------------------
0023+  CB89             
0024+  CB89             fileSelectDrive:; Максимум устройств
0025+  CB89 E6 07       		ani	7
0026+  CB8B             
0027+  CB8B             		; Сохраняем выбранное устройство
0028+  CB8B 32 C0 CE    		sta	v_drive
0029+  CB8E             
0030+  CB8E             		; Пригодится ниже (a = a * 2)
0031+  CB8E 87          		add	a
0032+  CB8F             
0033+  CB8F             		; Сохраняем регистры
0034+  CB8F E5          		push	h
0035+  CB90 D5          		push	d
0036+  CB91             
0037+  CB91             		; Получаем точку входа драйвера
0038+  CB91 6F          		mov	l, a
0039+  CB92 26 00       		mvi	h, 0
0040+  CB94 11 AE CE    		lxi	d, v_drives
0041+  CB97 19          		dad	d
0042+  CB98 5E          		mov	e, m
0043+  CB99 23          		inx	h
0044+  CB9A 56          		mov	d, m
0045+  CB9B EB          		xchg
0046+  CB9C             
0047+  CB9C             		; Сохраняем её
0048+  CB9C 22 64 C8    		shld	j_diskDriver+1
0049+  CB9F             
0050+  CB9F             		; Восстаналвиаем A
0051+  CB9F 0F          		rrc
0052+  CBA0             
0053+  CBA0             .include "driver_sel.inc"
0001++ CBA0             ;+---------------------------------------------------------------------------
0002++ CBA0             ; MXOS
0003++ CBA0             ; Драйвер диска в ДОЗУ, ПЗУ. Вызывается при смене диска.
0004++ CBA0             ;
0005++ CBA0             ; 2013-12-12 Дизассемблировано и доработано vinxru
0006++ CBA0             ;----------------------------------------------------------------------------
0007++ CBA0             
0008++ CBA0             		; Cохраняем A в E
0009++ CBA0 5F          		mov	e, a
0010++ CBA1             
0011++ CBA1             		; Корректируем стандартный драйвер.
0012++ CBA1             		; Если это диск 0 - то работаем с ПЗУ, иначе с ДОЗУ.
0013++ CBA1 A7          		ana	a
0014++ CBA2 3E FE       		mvi	a, IO_ROM & 0FFh	; STA IO_ROM
0015++ CBA4 2E C9       		mvi	l, 0C9h			; RET
0016++ CBA6             
0017++ CBA6 CA AD CB    		jz	disableRom_2
0018++ CBA9             #if BIG_MEM
0019++ CBA9 2E 46       		 mvi	l, 46h			; MOV B, M
0020++ CBAB~            #else
0021++ CBAB~            		 mvi	l, 7Eh			; MOV A, M
0022++ CBAB             #endif
0023++ CBAB 3E FD       		 mvi	a, IO_ARAM & 0FFh	; STA IO_ARAM
0024++ CBAD             disableRom_2:
0025++ CBAD 32 C2 FF            sta	0FFC0h + (driverR - driverStart) + 1
0026++ CBB0 7D          		mov	a, l
0027++ CBB1 32 D0 FF    		sta	0FFC0h + (driverW - driverStart)
0028++ CBB4             
0029++ CBB4             		; Восстанавливаем A из E
0030++ CBB4 7B          		mov	a, e
0031++ CBB5             
0054+  CBB5             
0055+  CBB5             		; Восстанавливаем регистры и выходим
0056+  CBB5 D1          		pop	d
0057+  CBB6 E1          		pop	h
0058+  CBB7 C9          		ret
0059+  CBB8             
0205   CBB8             .include "loadSaveFatDir.inc"
0001+  CBB8             ;+---------------------------------------------------------------------------
0002+  CBB8             ; MXOS
0003+  CBB8             ; Сохранить FAT и корневой каталог на устройство
0004+  CBB8             ;
0005+  CBB8             ; На выходе
0006+  CBB8             ;  регистры bc,de,hl сохраняются
0007+  CBB8             ;
0008+  CBB8             ; 2013-12-12 Дизассемблировано vinxru
0009+  CBB8             ;----------------------------------------------------------------------------
0010+  CBB8             
0011+  CBB8             saveFatDir:	; Сохраняем регистры
0012+  CBB8 D5          		push	d
0013+  CBB9             
0014+  CBB9             		; Режим - запись
0015+  CBB9 1E 01       		mvi	e, 1	
0016+  CBBB             
0017+  CBBB             		; Переход к общему коду			
0018+  CBBB C3 C1 CB    		jmp	loadFatDir_0
0019+  CBBE             
0020+  CBBE             ;----------------------------------------------------------------------------
0021+  CBBE             ; Загрузить FAT и корневой каталог с устройства
0022+  CBBE             ;
0023+  CBBE             ; На выходе
0024+  CBBE             ;  регистры bc,de,hl сохраняются
0025+  CBBE             ;----------------------------------------------------------------------------
0026+  CBBE             
0027+  CBBE             loadFatDir:	; Сохраняем регистры
0028+  CBBE D5          		push	d
0029+  CBBF             
0030+  CBBF             		; Режим - чтение
0031+  CBBF 1E 02       		mvi	e, 2
0032+  CBC1             
0033+  CBC1             loadFatDir_0:	; Сохраняем регистры
0034+  CBC1 E5          		push	h
0035+  CBC2             
0036+  CBC2             		; Чтение/запись 1024 байт с начала диска в FB00h
0037+  CBC2 21 00 FE    		lxi	h, diskDirectoryL
0038+  CBC5 16 03       		mvi	d, 3		; Сектор
0039+  CBC7 CD 63 C8    loadFatDir_1:	 call	j_diskDriver
0040+  CBCA 25          		 dcr	h
0041+  CBCB 15          		 dcr	d
0042+  CBCC F2 C7 CB    		jp	loadFatDir_1
0043+  CBCF             
0044+  CBCF             		; Восстанавливаем регистры и выходим
0045+  CBCF E1          		pop	h
0046+  CBD0 D1          		pop	d
0047+  CBD1 C9          		ret
0048+  CBD2             
0206   CBD2             .include "fileFindCluster.inc"
0001+  CBD2             ;+---------------------------------------------------------------------------
0002+  CBD2             ; MXOS
0003+  CBD2             ; Поиск свободного кластера 
0004+  CBD2             ;
0005+  CBD2             ; На выходе
0006+  CBD2             ;  cf - ошибка
0007+  CBD2             ;  a - кластер
0008+  CBD2             ;  регистры BC,DE,HL сохраняются
0009+  CBD2             ;
0010+  CBD2             ; 2013-12-12 Дизассемблировано vinxru
0011+  CBD2             ;----------------------------------------------------------------------------
0012+  CBD2             
0013+  CBD2             fileFindClusterFirst:
0014+  CBD2             		; Сохраняем регистры
0015+  CBD2 E5          		push	h
0016+  CBD3             
0017+  CBD3             		; Начинаем поиск с первого кластера (первые 4 не используются)
0018+  CBD3 21 04 FB    		lxi	h,  fat + 4
0019+  CBD6 C3 DD CB    		jmp	fileFindClus_2
0020+  CBD9             
0021+  CBD9             ;----------------------------------------------------------------------------
0022+  CBD9             ; Продолжение поиска свободного кластера 
0023+  CBD9             ;
0024+  CBD9             ; На выходе
0025+  CBD9             ;  cf - ошибка
0026+  CBD9             ;  a - кластер
0027+  CBD9             ;  регистры BC,DE,HL сохраняются
0028+  CBD9             ;----------------------------------------------------------------------------
0029+  CBD9             
0030+  CBD9             fileFindClusterNext:
0031+  CBD9             		; Сохраняем регистры
0032+  CBD9 E5          		push	h
0033+  CBDA             
0034+  CBDA             		; Начинаем поиск с этого кластера
0035+  CBDA 2A BE CE    		lhld	v_findCluster
0036+  CBDD             
0037+  CBDD             		; Ищем свободный кластер
0038+  CBDD             		; В соответствующей ячейке таблицы FAT должен быть 0
0039+  CBDD AF          fileFindClus_2:	xra	a
0040+  CBDE BE          fileFindClus_0:	cmp	m
0041+  CBDF CA EB CB    		jz	fileFindClus_1	; Найден
0042+  CBE2 2C          		inr	l
0043+  CBE3 C2 DE CB    		jnz	fileFindClus_0
0044+  CBE6             
0045+  CBE6             		; Восстаналиваем регистры и выходим A=1, CF=1, ZF=0
0046+  CBE6 E1          		pop	h
0047+  CBE7 3E 01       		mvi	a, 1
0048+  CBE9 37          		stc
0049+  CBEA C9          		ret
0050+  CBEB             
0051+  CBEB             ; ---------------------------------------------------------------------------
0052+  CBEB             
0053+  CBEB             fileFindClus_1:	; Свобожный кластер найден
0054+  CBEB 7D          		mov	a, l
0055+  CBEC             
0056+  CBEC             		; Устаналиваем ZF=0. Номер кластера не может быть нулевым.
0057+  CBEC             		; В случае ошибки мы то же выходим с ZF=1
0058+  CBEC B7          		ora	a
0059+  CBED             
0060+  CBED             		; Для ускорения поиска сохраняем номер следующего кластера в v_findCluster
0061+  CBED 2C          		inr	l
0062+  CBEE 22 BE CE    		shld	v_findCluster
0063+  CBF1             
0064+  CBF1             		; Восстанавливаем регистры и выходим с CF=0, ZF=0
0065+  CBF1 E1          		pop	h
0066+  CBF2 C9          		ret
0067+  CBF3             
0207   CBF3             .include "fileCreate.inc"
0001+  CBF3             ;----------------------------------------------------------------------------
0002+  CBF3             ; MXOS
0003+  CBF3             ; Создать файл
0004+  CBF3             ;
0005+  CBF3             ; На входе
0006+  CBF3             ;  hl - имя файла и информация (всё в формате записи каталога)
0007+  CBF3             ;
0008+  CBF3             ; На выходе
0009+  CBF3             ;  сf - ошибка
0010+  CBF3             ;
0011+  CBF3             ; 2013-12-12 Дизассемблировано vinxru
0012+  CBF3             ;----------------------------------------------------------------------------
0013+  CBF3             
0014+  CBF3             fileCreate:	; Сохраняем регистры
0015+  CBF3 E5          		push	h
0016+  CBF4 C5          		push	b
0017+  CBF5 D5          		push	d
0018+  CBF6             
0019+  CBF6             		; Если файл существует, то удаляем его
0020+  CBF6 CD 8A CC    		call	fileFind
0021+  CBF9 D4 2B CD    		cnc	deleteFileInt
0022+  CBFC             
0023+  CBFC             		; Сохраняем готовую запись каталога
0024+  CBFC E5          		push	h
0025+  CBFD             
0026+  CBFD             		; Ищем свободную запись в каталоге
0027+  CBFD 21 00 FC    		lxi	h, diskDirectory	; Адрес каталога
0028+  CC00 11 10 00    		lxi	d, 16			; Размер записи в каталоге
0029+  CC03 06 30       		mvi	b, 48			; Максимум файлов
0030+  CC05 7E          fileCreate_0:	mov	a, m
0031+  CC06 3C          		inr	a
0032+  CC07 CA 16 CC    		jz	fileCreate_1		; Свободная запись найдена
0033+  CC0A 19          		dad	d
0034+  CC0B 05          		dcr	b
0035+  CC0C C2 05 CC    		jnz	fileCreate_0
0036+  CC0F             
0037+  CC0F             		; Свободных записей нет
0038+  CC0F             
0039+  CC0F             		; Освобождаем стек
0040+  CC0F E1          		pop	h
0041+  CC10             
0042+  CC10             		; Установка A=0, ZF=1
0043+  CC10 AF          		xra	a		
0044+  CC11             
0045+  CC11             stc_pop_dbh_ret:; Установка флага CF=1
0046+  CC11 37          		stc
0047+  CC12             
0048+  CC12             pop_dbh_ret:	; Восстановление регистров и выход
0049+  CC12 D1          		pop	d
0050+  CC13 C1          		pop	b
0051+  CC14 E1          		pop	h
0052+  CC15 C9          		ret
0053+  CC16             
0054+  CC16             ; ---------------------------------------------------------------------------
0055+  CC16             ; Свободная запись найдена
0056+  CC16             
0057+  CC16             fileCreate_1:	; Адрес свободной записи в DE
0058+  CC16 EB          		xchg
0059+  CC17             
0060+  CC17             		; Готовая запись каталога в HL
0061+  CC17 E1          		pop	h
0062+  CC18             
0063+  CC18             		; Копируем готовую запись в каталог 
0064+  CC18 0E 0E       		mvi	c, 14
0065+  CC1A 7E          fileCreate_2:	mov	a, m
0066+  CC1B 12          		stax	d
0067+  CC1C 23          		inx	h
0068+  CC1D 13          		inx	d
0069+  CC1E 0D          		dcr	c
0070+  CC1F C2 1A CC    		jnz	fileCreate_2
0071+  CC22             
0072+  CC22             		; Сохраняем адрес созданного файла
0073+  CC22 EB          		xchg
0074+  CC23 22 C3 CE    		shld	v_createdFile
0075+  CC26             			
0076+  CC26             		; Ищем свободный кластер
0077+  CC26 CD D2 CB    		call	fileFindClusterFirst
0078+  CC29 DA 11 CC    		jc	stc_pop_dbh_ret
0079+  CC2C             
0080+  CC2C F5          		push	psw
0081+  CC2D             
0082+  CC2D             		; Сохраняем в каталог адрес первого кластера
0083+  CC2D 23          		inx	h
0084+  CC2E 77          		mov	m, a ; [15]
0085+  CC2F             
0086+  CC2F             		; Читаем длину
0087+  CC2F 2B          		dcx	h
0088+  CC30 2B          		dcx	h
0089+  CC31 56          		mov	d, m ; [13]
0090+  CC32 2B          		dcx	h
0091+  CC33 5E          		mov	e, m ; [12]
0092+  CC34             
0093+  CC34             		; Читаем адрес
0094+  CC34 2B          		dcx	h
0095+  CC35 46          		mov	b, m ; [11]
0096+  CC36 2B          		dcx	h
0097+  CC37 6E          		mov	l, m ; [10]
0098+  CC38             
0099+  CC38             		; Сохраняем адрес
0100+  CC38 60          		mov	h, b
0101+  CC39 22 C1 CE    		shld	v_input_start
0102+  CC3C             
0103+  CC3C             		; Сохраняем длину
0104+  CC3C EB          		xchg
0105+  CC3D 22 C7 CE    		shld	v_input_end
0106+  CC40             
0107+  CC40             		; ?
0108+  CC40 44          		mov	b, h
0109+  CC41 04          		inr	b
0110+  CC42 26 FB       		mvi	h, 0FBh
0111+  CC44             
0112+  CC44             		; Первый кластер файла
0113+  CC44 F1          		pop	psw
0114+  CC45 4F          		mov	c, a
0115+  CC46 6F          		mov	l, a
0116+  CC47             
0117+  CC47 C3 50 CC    		jmp	loc_CC24
0118+  CC4A             
0119+  CC4A             ; ---------------------------------------------------------------------------
0120+  CC4A             
0121+  CC4A CD D9 CB    allocClusters:	call	fileFindClusterNext
0122+  CC4D DA 11 CC    		jc	stc_pop_dbh_ret		
0123+  CC50 77          loc_CC24:	mov	m, a
0124+  CC51 6F          		mov	l, a
0125+  CC52 05          		dcr	b
0126+  CC53 C2 4A CC    		jnz	allocClusters
0127+  CC56 75          		mov	m, l		
0128+  CC57 06 FB       		mvi	b, 0FBh
0129+  CC59 EB          		xchg
0130+  CC5A 1E 01       		mvi	e, 1		
0131+  CC5C 51          loc_CC30:	mov	d, c
0132+  CC5D CD 63 C8    		call	j_diskDriver
0133+  CC60 24          		inr	h
0134+  CC61 0A          		ldax	b
0135+  CC62 B9          		cmp	c
0136+  CC63 4F          		mov	c, a
0137+  CC64 C2 5C CC    		jnz	loc_CC30		
0138+  CC67 2A C7 CE    		lhld	v_input_end
0139+  CC6A 23          		inx	h
0140+  CC6B EB          		xchg
0141+  CC6C 2A C1 CE    		lhld	v_input_start
0142+  CC6F 06 00       		mvi	b, 0		
0143+  CC71 7A          loc_CC45:	mov	a, d
0144+  CC72 B3          		ora	e
0145+  CC73 CA 7E CC    		jz	loc_CC52
0146+  CC76 7E          		mov	a, m
0147+  CC77 80          		add	b
0148+  CC78 47          		mov	b, a
0149+  CC79 23          		inx	h
0150+  CC7A 1B          		dcx	d
0151+  CC7B C3 71 CC    		jmp	loc_CC45
0152+  CC7E             
0153+  CC7E             ; ---------------------------------------------------------------------------
0154+  CC7E             
0155+  CC7E 78          loc_CC52:	mov	a, b
0156+  CC7F 2A C3 CE    		lhld	v_createdFile
0157+  CC82 77          		mov	m, a
0158+  CC83 CD B8 CB    		call	saveFatDir
0159+  CC86 B7          		ora	a
0160+  CC87 C3 12 CC    		jmp	pop_dbh_ret
0161+  CC8A             
0208   CC8A             .include "fileFind.inc"
0001+  CC8A             ;+---------------------------------------------------------------------------
0002+  CC8A             ; MXOS
0003+  CC8A             ; Найти файл
0004+  CC8A             ;
0005+  CC8A             ; На входе
0006+  CC8A             ;  hl - имя
0007+  CC8A             ;
0008+  CC8A             ; На выходе
0009+  CC8A             ;  bc,de,hl - сохраняются
0010+  CC8A             ;  cf - ошибка
0011+  CC8A             ;  v_foundedFile - найденный файл
0012+  CC8A             ;
0013+  CC8A             ; 2013-12-12 Дизассемблировано vinxru
0014+  CC8A             ;----------------------------------------------------------------------------
0015+  CC8A             
0016+  CC8A             fileFind:	; Загрузка FAT и корневого каталога в память
0017+  CC8A CD BE CB    		call	loadFatDir
0018+  CC8D             
0019+  CC8D             fileFind2:	; Сохраняем регистры
0020+  CC8D C5          		push	b
0021+  CC8E D5          		push	d
0022+  CC8F             
0023+  CC8F             		; Начало каталога
0024+  CC8F 11 00 FC    		lxi	d, diskDirectory
0025+  CC92             
0026+  CC92             		; Кол-во файлов в каталоге
0027+  CC92 06 30       		mvi	b, 48
0028+  CC94             
0029+  CC94             fileFind_loop:	; Сохраняем адрес начала имени в каталоге и образец
0030+  CC94 E5          		push	h
0031+  CC95 D5          		push	d
0032+  CC96             
0033+  CC96             		; Если первый символ имени 0FFh, переходим к следующем файлу
0034+  CC96 1A          		ldax	d
0035+  CC97 3C          		inr	a
0036+  CC98 CA B1 CC    		jz	fileFind_next
0037+  CC9B             
0038+  CC9B             		; Длина имени 9 символов
0039+  CC9B 0E 09       		mvi	c, 9
0040+  CC9D             
0041+  CC9D             fileFind_name:	; Если символы не равны, переходим к следующему файлу
0042+  CC9D 1A          		ldax	d
0043+  CC9E BE          		cmp	m
0044+  CC9F C2 B1 CC    		jnz	fileFind_next
0045+  CCA2 23          		inx	h
0046+  CCA3 13          		inx	d
0047+  CCA4             
0048+  CCA4             		; Цикл
0049+  CCA4 0D          		dcr	c
0050+  CCA5 C2 9D CC    		jnz	fileFind_name
0051+  CCA8             
0052+  CCA8             		; Сохраняем адрес найденного файла
0053+  CCA8 E1          		pop	h
0054+  CCA9 22 C5 CE    		shld	v_foundedFile
0055+  CCAC             
0056+  CCAC             		; Восстаналиваем регистры и выходим с CF=0
0057+  CCAC E1          		pop	h
0058+  CCAD B7          		ora	a	; х.з.
0059+  CCAE D1          		pop	d
0060+  CCAF C1          		pop	b
0061+  CCB0 C9          		ret
0062+  CCB1             
0063+  CCB1             ; ---------------------------------------------------------------------------
0064+  CCB1             
0065+  CCB1             fileFind_next:	; Вычисляем адрес следующего файла
0066+  CCB1 D1          		pop	d
0067+  CCB2 21 10 00    		lxi	h, 10h
0068+  CCB5 19          		dad	d
0069+  CCB6 EB          		xchg
0070+  CCB7             
0071+  CCB7             		; Восстанавливаем образец
0072+  CCB7 E1          		pop	h
0073+  CCB8             
0074+  CCB8             		; Еще остались файлы?
0075+  CCB8 05          		dcr	b
0076+  CCB9 C2 94 CC    		jnz	fileFind_loop
0077+  CCBC             
0078+  CCBC             		; Восстаналиваем регистры и выходим с CF=1 и A=3
0079+  CCBC D1          		pop	d
0080+  CCBD C1          		pop	b
0081+  CCBE 3E 03       		mvi	a, 3
0082+  CCC0 37          		stc
0083+  CCC1 C9          		ret
0084+  CCC2             
0209   CCC2             .include "fileLoad.inc"
0001+  CCC2             ;+---------------------------------------------------------------------------
0002+  CCC2             ; MXOS
0003+  CCC2             ; Загрузить файл
0004+  CCC2             ;
0005+  CCC2             ; На входе
0006+  CCC2             ;  hl - имя
0007+  CCC2             ;  de - адрес загрузки
0008+  CCC2             ;
0009+  CCC2             ; На выходе
0010+  CCC2             ;  bc,de,hl - сохраняются
0011+  CCC2             ;  v_foundedFile - найденный файл
0012+  CCC2             ;  cf - ошибка
0013+  CCC2             ;
0014+  CCC2             ; 2013-12-12 Дизассемблировано vinxru
0015+  CCC2             ;----------------------------------------------------------------------------
0016+  CCC2             
0017+  CCC2             fileLoad2:	; Ищем файл с именем в HL
0018+  CCC2             
0019+  CCC2                     ; SpaceEngineer: функция fileFind2 пропускает обновление буфера fat и
0020+  CCC2                     ; каталога текущего диска. Из-за этого fileLoad2 некорректно работает
0021+  CCC2                     ; с файлами на ром-диске (A:, без поддержки записи - потому что изменение
0022+  CCC2                     ; адреса загрузки программы сделано несколько костыльно, через патчинг
0023+  CCC2                     ; этого адреса в структуре каталога). 
0024+  CCC2                     ; Вызывающая программа могла бы сама вызвать loadFatDir перед вызовом
0025+  CCC2                     ; fileLoad2, но, к сожалению, loadFatDir не числится в списке стандартных
0026+  CCC2                     ; точек вызова.
0027+  CCC2             
0028+  CCC2             		;call	fileFind2
0029+  CCC2 CD 8A CC            call	fileFind
0030+  CCC5 D8          		rc
0031+  CCC6             
0032+  CCC6             		; Сохранить регистры
0033+  CCC6 E5          		push	h
0034+  CCC7 C5          		push	b
0035+  CCC8 D5          		push	d
0036+  CCC9             
0037+  CCC9             		; Указатель на длину найденного файла
0038+  CCC9 2A C5 CE    		lhld	v_foundedFile
0039+  CCCC 01 0D 00    		lxi	b, 13
0040+  CCCF 09          		dad	b
0041+  CCD0             
0042+  CCD0 C3 E6 CC    		jmp	loc_CCBA
0043+  CCD3             
0044+  CCD3             ;----------------------------------------------------------------------------
0045+  CCD3             ; Загрузить файл по адресу указанному в заголовке
0046+  CCD3             ;
0047+  CCD3             ; На входе
0048+  CCD3             ;  hl - имя
0049+  CCD3             ;
0050+  CCD3             ; На выходе
0051+  CCD3             ;  bc,de,hl - сохраняются
0052+  CCD3             ;  v_foundedFile - найденный файл
0053+  CCD3             ;  cf - ошибка
0054+  CCD3             ;----------------------------------------------------------------------------
0055+  CCD3             
0056+  CCD3             fileLoad:	; Ищем файл с именем в HL
0057+  CCD3 CD 8A CC    		call	fileFind
0058+  CCD6 D8          		rc
0059+  CCD7             
0060+  CCD7             		; Сохраняем регистры
0061+  CCD7 E5          		push	h
0062+  CCD8 C5          		push	b
0063+  CCD9 D5          		push	d
0064+  CCDA             
0065+  CCDA             		; DE = адрес загрузки
0066+  CCDA 2A C5 CE    		lhld	v_foundedFile
0067+  CCDD 11 0A 00    		lxi	d, 10
0068+  CCE0 19          		dad	d
0069+  CCE1 5E          		mov	e, m ; +10
0070+  CCE2 23          		inx	h
0071+  CCE3 56          		mov	d, m ; +11
0072+  CCE4             
0073+  CCE4 23          		inx	h
0074+  CCE5 23          		inx	h
0075+  CCE6             
0076+  CCE6             loc_CCBA:	; Длина файла в кластерах
0077+  CCE6 46          		mov	b, m ; +13
0078+  CCE7 04          		inr	b
0079+  CCE8             		
0080+  CCE8             		; Первый кластер
0081+  CCE8 23          		inx	h
0082+  CCE9 23          		inx	h
0083+  CCEA 7E          		mov	a, m ; +15
0084+  CCEB             
0085+  CCEB EB          		xchg
0086+  CCEC             
0087+  CCEC             loc_CCC0:	; Читаем кластер в память
0088+  CCEC 1E 02       		mvi	e, 2		; Чтение
0089+  CCEE 57          		mov	d, a		; Кластер
0090+  CCEF CD 63 C8    		call	j_diskDriver
0091+  CCF2             
0092+  CCF2             		; Следующий кластер
0093+  CCF2 24          		inr	h
0094+  CCF3 5A          		mov	e, d
0095+  CCF4 16 FB       		mvi	d, 0FBh
0096+  CCF6 1A          		ldax	d
0097+  CCF7             
0098+  CCF7             		; Цикл
0099+  CCF7 05          		dcr	b
0100+  CCF8 C2 EC CC    		jnz	loc_CCC0
0101+  CCFB             
0102+  CCFB             		; Восстанавливаем регистры
0103+  CCFB D1          		pop	d
0104+  CCFC C1          		pop	b
0105+  CCFD E1          		pop	h
0106+  CCFE             
0107+  CCFE C3 05 CD    		jmp	loc_CCD9
0108+  CD01             
0109+  CD01             ; ---------------------------------------------------------------------------
0110+  CD01             
0111+  CD01             fileLoadInfo:	; Ищем файл с именем в HL
0112+  CD01 CD 8A CC    		call	fileFind
0113+  CD04 D8          		rc
0114+  CD05             
0115+  CD05             loc_CCD9:	; Сохраняем регистры
0116+  CD05 E5          		push	h
0117+  CD06 C5          		push	b
0118+  CD07 D5          		push	d
0119+  CD08             
0120+  CD08             		; Что то в DE
0121+  CD08 01 09 00    		lxi	b, 9
0122+  CD0B 09          		dad	b
0123+  CD0C EB          		xchg
0124+  CD0D             
0125+  CD0D             		; Информация о файле исключая имя
0126+  CD0D 2A C5 CE    		lhld	v_foundedFile
0127+  CD10 09          		dad	b
0128+  CD11             
0129+  CD11             		; Копируем 7 байт из HL в DE
0130+  CD11 06 07       		mvi	b, 7
0131+  CD13 7E          loc_CCE7:	mov	a, m
0132+  CD14 12          		stax	d
0133+  CD15 23          		inx	h
0134+  CD16 13          		inx	d
0135+  CD17 05          		dcr	b
0136+  CD18 C2 13 CD    		jnz	loc_CCE7
0137+  CD1B             
0138+  CD1B             		; Выход CF=0
0139+  CD1B B7          		ora	a
0140+  CD1C C3 12 CC    		jmp	pop_dbh_ret
0141+  CD1F             
0210   CD1F             .include "fileDelete.inc"
0001+  CD1F             ;+---------------------------------------------------------------------------
0002+  CD1F             ; MXOS
0003+  CD1F             ; Удаление файла
0004+  CD1F             ;
0005+  CD1F             ; На входе
0006+  CD1F             ;  hl - имя файла
0007+  CD1F             ;
0008+  CD1F             ; На выходе
0009+  CD1F             ;  cf - ошибка
0010+  CD1F             ;  bc,de,hl - сохраняются
0011+  CD1F             ;
0012+  CD1F             ; 2013-12-12 Дизассемблировано vinxru
0013+  CD1F             ;----------------------------------------------------------------------------
0014+  CD1F             
0015+  CD1F             fileDelete:	; Найти файл с именем из HL
0016+  CD1F CD 8A CC    		call	fileFind
0017+  CD22 D8          		rc
0018+  CD23             
0019+  CD23             		; Удалить файл
0020+  CD23 CD 2B CD    		call	deleteFileInt
0021+  CD26             
0022+  CD26             		; Сохранить изменения на диск
0023+  CD26 CD B8 CB    		call	saveFatDir
0024+  CD29             
0025+  CD29             		; Результат
0026+  CD29 B7          		ora	a
0027+  CD2A C9          		ret
0028+  CD2B             		
0029+  CD2B             ; ---------------------------------------------------------------------------
0030+  CD2B             
0031+  CD2B             deleteFileInt:	; Сохраняем регистры
0032+  CD2B E5          		push	h
0033+  CD2C C5          		push	b
0034+  CD2D D5          		push	d
0035+  CD2E             
0036+  CD2E             		; Помечаем файл, как удаленный заменяя его первую букву на FF
0037+  CD2E 2A C5 CE    		lhld	v_foundedFile
0038+  CD31 36 FF       		mvi	m, 0FFh		
0039+  CD33             
0040+  CD33             		; Получаем первый кластер файла в A
0041+  CD33 11 0F 00    		lxi	d, 15
0042+  CD36 19          		dad	d
0043+  CD37 7E          		mov	a, m
0044+  CD38             
0045+  CD38             		; Адрес таблицы FAT
0046+  CD38 26 FB       		mvi	h, fat>>8
0047+  CD3A             
0048+  CD3A             deleteFileIn_0:	; Получаем следующий кластер в А
0049+  CD3A 6F          		mov	l, a
0050+  CD3B 7E          		mov	a, m
0051+  CD3C             
0052+  CD3C             		; А этот помечаем не занятым
0053+  CD3C 36 00       		mvi	m, 0
0054+  CD3E             
0055+  CD3E             		; Если это был не последний кластер, продолжаем.
0056+  CD3E BD          		cmp	l
0057+  CD3F C2 3A CD    		jnz	deleteFileIn_0
0058+  CD42             
0059+  CD42             		; Восстаналиваем регистры и выходим
0060+  CD42 C3 12 CC    		jmp	pop_dbh_ret
0061+  CD45             
0211   CD45             .include "fileRename.inc"
0001+  CD45             ;+---------------------------------------------------------------------------
0002+  CD45             ; MXOS
0003+  CD45             ; Переименовать файл
0004+  CD45             ;
0005+  CD45             ; На входе 
0006+  CD45             ;  hl - исходное имя
0007+  CD45             ;  de - новое имя
0008+  CD45             ;
0009+  CD45             ; На выходе
0010+  CD45             ;  cf - ошибка
0011+  CD45             ;  bc,de,hl - сохраняются
0012+  CD45             ;
0013+  CD45             ; 2013-12-12 Дизассемблировано vinxru
0014+  CD45             ;----------------------------------------------------------------------------
0015+  CD45             
0016+  CD45             fileRename:	; Найти файл с именем из HL
0017+  CD45 CD 8A CC    		call	fileFind
0018+  CD48 D8          		rc
0019+  CD49             
0020+  CD49             		; Сохранить регистры
0021+  CD49 E5          		push	h
0022+  CD4A C5          		push	b
0023+  CD4B D5          		push	d
0024+  CD4C             		
0025+  CD4C             		;
0026+  CD4C 2A C5 CE    		lhld	v_foundedFile
0027+  CD4F             
0028+  CD4F             		; Попытаться найти файл с новым именем
0029+  CD4F EB          		xchg
0030+  CD50 CD 8D CC    		call	fileFind2		
0031+  CD53             
0032+  CD53             		; Если такой файл есть, то удалить
0033+  CD53 D4 2B CD    		cnc	deleteFileInt
0034+  CD56             		
0035+  CD56             		; Заменяем имя
0036+  CD56 0E 09       		mvi	c, 9		
0037+  CD58 7E          loc_CD2C:	mov	a, m
0038+  CD59 12          		stax	d
0039+  CD5A 23          		inx	h
0040+  CD5B 13          		inx	d
0041+  CD5C 0D          		dcr	c
0042+  CD5D C2 58 CD    		jnz	loc_CD2C
0043+  CD60             
0044+  CD60             		; Сохраняем изменения
0045+  CD60 CD B8 CB    		call	saveFatDir
0046+  CD63             
0047+  CD63             		; Выход
0048+  CD63 B7          		ora	a
0049+  CD64 C3 12 CC    		jmp	pop_dbh_ret
0050+  CD67             
0212   CD67             .include "fileGetSetAttr.inc"
0001+  CD67             ;+---------------------------------------------------------------------------
0002+  CD67             ; MXOS
0003+  CD67             ; Получение/изменение атрибутов файла
0004+  CD67             ;
0005+  CD67             ; На входе 
0006+  CD67             ;   hl - имя файла
0007+  CD67             ;   с  - 0=чтение, 1=изменение
0008+  CD67             ;   b  - новые атрибуты (если C==1)
0009+  CD67             ;
0010+  CD67             ; На выходе 
0011+  CD67             ;   cf - ошибка
0012+  CD67             ;   a  - атрибуты
0013+  CD67             ;   bc,de,hl - сохраняются
0014+  CD67             ;
0015+  CD67             ; 2013-12-12 Дизассемблировано vinxru
0016+  CD67             ;----------------------------------------------------------------------------
0017+  CD67             
0018+  CD67 C5          fileGetSetAttr:	push	b
0019+  CD68 47          		mov	b, a		
0020+  CD69             
0021+  CD69             		; Ищем файл с именем в HL. Если найден, то переходим
0022+  CD69 CD 8A CC    		call	fileFind
0023+  CD6C D2 71 CD    		jnc	fileGetSetAt_0
0024+  CD6F             
0025+  CD6F             		; Ошибка, выходим
0026+  CD6F C1          		pop	b
0027+  CD70 C9          		ret
0028+  CD71             
0029+  CD71             ; ---------------------------------------------------------------------------
0030+  CD71             
0031+  CD71 E5          fileGetSetAt_0:	push	h
0032+  CD72 CD 9C CD    		call	fileGetInfoAddr
0033+  CD75             
0034+  CD75             		; Переходим, если на входе в функцию C=0
0035+  CD75 C2 79 CD    		jnz	fileGetSetAt_1
0036+  CD78             
0037+  CD78             		; Устанавливаем флаги
0038+  CD78 70          		mov	m, b
0039+  CD79             
0040+  CD79             fileGetSetAt_1:	; Читаем флаги
0041+  CD79 7E          		mov	a, m
0042+  CD7A             
0043+  CD7A             		; Сохраняем изменения (хотя для чтения это не нужно делать)
0044+  CD7A CD B8 CB    		call	saveFatDir
0045+  CD7D             
0046+  CD7D             		; Восстанавливаем регистры и выходим ;! А тут точно CF==0 будет?
0047+  CD7D B7          		ora	a
0048+  CD7E E1          		pop	h
0049+  CD7F C1          		pop	b
0050+  CD80 C9          		ret
0051+  CD81             
0213   CD81             .include "fileGetSetAddr.inc"
0001+  CD81             ;+---------------------------------------------------------------------------
0002+  CD81             ; MXOS
0003+  CD81             ; Получение/изменение адреса загрузки файла
0004+  CD81             ;
0005+  CD81             ; На входе 
0006+  CD81             ;   hl - имя файла
0007+  CD81             ;   с  - 0=чтение, 1=изменение
0008+  CD81             ;   de - адрес
0009+  CD81             ;
0010+  CD81             ; На выходе 
0011+  CD81             ;   de - адрес
0012+  CD81             ;   bc,hl - сохраняются
0013+  CD81             ;
0014+  CD81             ; 2013-12-12 Дизассемблировано vinxru
0015+  CD81             ;----------------------------------------------------------------------------
0016+  CD81             
0017+  CD81             fileGetSetAddr:	; Ищем файл с именем в HL
0018+  CD81 CD 8A CC    		call	fileFind
0019+  CD84 D8          		rc
0020+  CD85             
0021+  CD85 E5          		push	h
0022+  CD86             
0023+  CD86             		; Получаем адрес где находится длина файла
0024+  CD86 CD 9C CD    		call	fileGetInfoAddr
0025+  CD89 23          		inx	h
0026+  CD8A             
0027+  CD8A             		; Переходим, если на входе в функцию C=0
0028+  CD8A C2 96 CD    		jnz	fileGetSetAd_0
0029+  CD8D             
0030+  CD8D             		; Заменяем адрес загрузки
0031+  CD8D 73          		mov	m, e
0032+  CD8E 23          		inx	h
0033+  CD8F 72          		mov	m, d
0034+  CD90             
0035+  CD90             		; Сохраняем изменения
0036+  CD90 CD B8 CB    		call	saveFatDir
0037+  CD93             
0038+  CD93             		; Выходим
0039+  CD93 E1          		pop	h
0040+  CD94 B7          		ora	a
0041+  CD95 C9          		ret
0042+  CD96             
0043+  CD96             ; ---------------------------------------------------------------------------
0044+  CD96             
0045+  CD96             fileGetSetAd_0:	; Читаем адрес загрузки
0046+  CD96 5E          		mov	e, m
0047+  CD97 23          		inx	h
0048+  CD98 56          		mov	d, m
0049+  CD99             
0050+  CD99             		; Выходим
0051+  CD99 E1          		pop	h
0052+  CD9A B7          		ora	a
0053+  CD9B C9          		ret
0054+  CD9C             
0214   CD9C             .include "fileGetInfoAddr.inc"
0001+  CD9C             ;+---------------------------------------------------------------------------
0002+  CD9C             ; MXOS
0003+  CD9C             ; Адрес информации о найденном файлое
0004+  CD9C             ;
0005+  CD9C             ; На входе 
0006+  CD9C             ;   c - любое число
0007+  CD9C             ;
0008+  CD9C             ; На выходе 
0009+  CD9C             ;   b, de - сохраняются
0010+  CD9C             ;   hl - адрес информации о найденном файлое
0011+  CD9C             ;   zf - если a==1
0012+  CD9C             ;   a = c
0013+  CD9C             ;   c = c-1
0014+  CD9C             ;
0015+  CD9C             ; 2013-12-12 Дизассемблировано vinxru
0016+  CD9C             ;----------------------------------------------------------------------------
0017+  CD9C             
0018+  CD9C D5          fileGetInfoAddr:push	d
0019+  CD9D             
0020+  CD9D             		; Помещаем в hl адрес информации о файле
0021+  CD9D 2A C5 CE    		lhld	v_foundedFile
0022+  CDA0 11 09 00    		lxi	d, 9
0023+  CDA3 19          		dad	d
0024+  CDA4             
0025+  CDA4             		; Помещаем в A режим
0026+  CDA4 79          		mov	a, c
0027+  CDA5             
0028+  CDA5             		; ZF=1 если режим 1
0029+  CDA5 0D          		dcr	c
0030+  CDA6             
0031+  CDA6 D1          		pop	d
0032+  CDA7 C9          		ret
0033+  CDA8             
0215   CDA8             .include "fileList.inc"
0001+  CDA8             ;+---------------------------------------------------------------------------
0002+  CDA8             ; MXOS
0003+  CDA8             ; Получить список файлов
0004+  CDA8             ;
0005+  CDA8             ; На входе 
0006+  CDA8             ;  hl - адрес буфера (769 байт)
0007+  CDA8             ;
0008+  CDA8             ; На выходе
0009+  CDA8             ;  bc,de,hl - сохраняются
0010+  CDA8             ;
0011+  CDA8             ; 2013-12-12 Дизассемблировано vinxru
0012+  CDA8             ;----------------------------------------------------------------------------
0013+  CDA8             
0014+  CDA8             fileList:	; Загрузка FAT и каталога
0015+  CDA8 CD BE CB    		call	loadFatDir
0016+  CDAB             
0017+  CDAB             		; Сохранение регистров
0018+  CDAB E5          		push	h
0019+  CDAC C5          		push	b
0020+  CDAD D5          		push	d
0021+  CDAE             
0022+  CDAE             		; Максимум файлов
0023+  CDAE 06 30       		mvi	b, 48
0024+  CDB0             
0025+  CDB0             		; Адрес первого файла
0026+  CDB0 11 00 FC    		lxi	d, diskDirectory
0027+  CDB3             		
0028+  CDB3             fileList_loop:	; Если первый символ не FFh, копируем описатель
0029+  CDB3 1A          		ldax	d
0030+  CDB4 3C          		inr	a
0031+  CDB5 C2 C8 CD    		jnz	fileList_copy
0032+  CDB8             
0033+  CDB8             		; Вычисляем адрес следующего файла
0034+  CDB8 E5          		push	h
0035+  CDB9 21 10 00    		lxi	h, 10h
0036+  CDBC 19          		dad	d
0037+  CDBD EB          		xchg
0038+  CDBE E1          		pop	h
0039+  CDBF             
0040+  CDBF             fileList_next:	; Цикл
0041+  CDBF 05          		dcr	b
0042+  CDC0 C2 B3 CD    		jnz	fileList_loop
0043+  CDC3             
0044+  CDC3             		; В конце символ 0FFh
0045+  CDC3 36 FF       		mvi	m, 0FFh
0046+  CDC5 C3 12 CC    		jmp	pop_dbh_ret
0047+  CDC8             
0048+  CDC8             ; ---------------------------------------------------------------------------
0049+  CDC8             
0050+  CDC8             fileList_copy:	; Копируем 16 байт из DE в HL
0051+  CDC8 0E 10       		mvi	c, 16
0052+  CDCA 1A          fileList_copyl:	ldax	d
0053+  CDCB 77          		mov	m, a
0054+  CDCC 23          		inx	h
0055+  CDCD 13          		inx	d
0056+  CDCE 0D          		dcr	c
0057+  CDCF C2 CA CD    		jnz	fileList_copyl
0058+  CDD2 C3 BF CD    		jmp	fileList_next
0059+  CDD5             
0216   CDD5             .include "fileNamePrepare.inc"
0001+  CDD5             ;+---------------------------------------------------------------------------
0002+  CDD5             ; MXOS
0003+  CDD5             ; Подготовить имя файла для функций ОС
0004+  CDD5             ;
0005+  CDD5             ; На входе 
0006+  CDD5             ;  hl - исходное имя
0007+  CDD5             ;  de - буфер для результата (9 байт)
0008+  CDD5             ;
0009+  CDD5             ; 2013-12-12 Дизассемблировано vinxru
0010+  CDD5             ;----------------------------------------------------------------------------
0011+  CDD5             
0012+  CDD5             fileNamePrepare:; Сохраняем регистры
0013+  CDD5 C5          		push	b
0014+  CDD6 D5          		push	d
0015+  CDD7             
0016+  CDD7             		; Если второй символ исходной строки ':', то меняем диск
0017+  CDD7 23          		inx	h		
0018+  CDD8 7E          		mov	a, m
0019+  CDD9 FE 3A       		cpi	':'
0020+  CDDB 2B          		dcx	h
0021+  CDDC C2 E7 CD    		jnz	fileNamePr_1
0022+  CDDF             
0023+  CDDF             		; Меняем диск
0024+  CDDF 7E          		mov	a, m		
0025+  CDE0 D6 41       		sui	'A'
0026+  CDE2 CD 89 CB    		call	fileSelectDrive
0027+  CDE5             
0028+  CDE5             		; Диск не входит в имя файла
0029+  CDE5 23          		inx	h		
0030+  CDE6 23          		inx	h		
0031+  CDE7             		
0032+  CDE7             fileNamePr_1:	; 6 символов имени, 3 расширения
0033+  CDE7 01 03 06    		lxi	b, 603h
0034+  CDEA             
0035+  CDEA             		; Копируем текст до точки, пробела или конца строки, не более 6 символов. 
0036+  CDEA 7E          fileNamePr_2:	mov	a, m
0037+  CDEB A7          		ana	a
0038+  CDEC F2 F1 CD    		jp	fileNamePr_3
0039+  CDEF D6 40       		sui	40h
0040+  CDF1 FE 21       fileNamePr_3:	cpi	' '+1
0041+  CDF3 DA 11 CE    		jc	fileNamePr_5
0042+  CDF6 23          		inx	h
0043+  CDF7 FE 2E       		cpi	'.'
0044+  CDF9 CA 11 CE    		jz	fileNamePr_5		
0045+  CDFC 12          		stax	d
0046+  CDFD 13          		inx	d
0047+  CDFE 05          		dcr	b
0048+  CDFF C2 EA CD    		jnz	fileNamePr_2
0049+  CE02             
0050+  CE02             		; Пропускаем текст до точки, пробела или конца строки
0051+  CE02 7E          fileNamePr_4:	mov	a, m
0052+  CE03 FE 21       		cpi	' '+1
0053+  CE05 DA 14 CE    		jc	fileNamePr_6
0054+  CE08 23          		inx	h
0055+  CE09 FE 2E       		cpi	'.'
0056+  CE0B C2 02 CE    		jnz	fileNamePr_4
0057+  CE0E C3 14 CE    		jmp	fileNamePr_6
0058+  CE11             
0059+  CE11             ; ---------------------------------------------------------------------------
0060+  CE11             
0061+  CE11             fileNamePr_5:	; Имя короче 6 символов
0062+  CE11             		; Заполняем недостающие символы имени пробелами
0063+  CE11 CD 46 CE    		call	memset_de_20_b
0064+  CE14             
0065+  CE14             		; Копируем текст до пробела или конца строки, не более 3 символов. 
0066+  CE14 7E          fileNamePr_6:	mov	a, m                         
0067+  CE15 A7          		ana	a
0068+  CE16 F2 1B CE    		jp	fileNamePr_7
0069+  CE19 D6 40       		sui	40h		
0070+  CE1B FE 21       fileNamePr_7:	cpi	' '+1
0071+  CE1D DA 3F CE    		jc	fileNamePr_11
0072+  CE20 12          		stax	d
0073+  CE21 23          		inx	h
0074+  CE22 13          		inx	d
0075+  CE23 0D          		dcr	c
0076+  CE24 C2 14 CE    		jnz	fileNamePr_6
0077+  CE27             
0078+  CE27             fileNamePr_8:	; Пропускаем текст до пробела или конца строки
0079+  CE27 7E          		mov	a, m
0080+  CE28 FE 20       		cpi	' '
0081+  CE2A DA 3C CE    		jc	fileNamePr_10
0082+  CE2D 23          		inx	h
0083+  CE2E C2 27 CE    		jnz	fileNamePr_8
0084+  CE31             		
0085+  CE31             fileNamePr_9:	; Пропускаем текст до пробела или конца строки
0086+  CE31             		; Почему то дублируется код
0087+  CE31 7E          		mov	a, m
0088+  CE32 FE 20       		cpi	' '
0089+  CE34 DA 3C CE    		jc	fileNamePr_10
0090+  CE37 23          		inx	h
0091+  CE38 CA 31 CE    		jz	fileNamePr_9
0092+  CE3B 2B          		dcx	h
0093+  CE3C             
0094+  CE3C             fileNamePr_10:	; Восстанавливаем регистры и выходим
0095+  CE3C D1          		pop	d
0096+  CE3D C1          		pop	b
0097+  CE3E C9          		ret
0098+  CE3F             
0099+  CE3F             ; ---------------------------------------------------------------------------
0100+  CE3F             
0101+  CE3F             fileNamePr_11:	; Заполняем недостающие символы расширения пробелами
0102+  CE3F 41          		mov	b, c
0103+  CE40 CD 46 CE    		call	memset_de_20_b
0104+  CE43             
0105+  CE43             		; Восстанавливаем регистры и выходим
0106+  CE43 D1          		pop	d
0107+  CE44 C1          		pop	b
0108+  CE45 C9          		ret
0109+  CE46             
0217   CE46             .include "memset_de_20_b.inc"
0001+  CE46             ;+---------------------------------------------------------------------------
0002+  CE46             ; MXOS
0003+  CE46             ; Заполнить память пробелами
0004+  CE46             ;
0005+  CE46             ; На входе
0006+  CE46             ;  de - адрес
0007+  CE46             ;  b  - длина (0 считается за 256)
0008+  CE46             ;
0009+  CE46             ; 2013-12-12 Дизассемблировано vinxru
0010+  CE46             ;----------------------------------------------------------------------------
0011+  CE46             
0012+  CE46 3E 20       memset_de_20_b:	mvi	a, ' '
0013+  CE48 12          memset_de_a_b:	stax	d
0014+  CE49 13          		inx	d
0015+  CE4A 05          		dcr	b
0016+  CE4B C2 48 CE    		jnz	memset_de_a_b
0017+  CE4E C9          		ret
0018+  CE4F             
0218   CE4F             
0219   CE4F             #if RAMFOS_COMPATIBILITY
0220   CE4F             .include "strToHex.inc"
0001+  CE4F             ;+---------------------------------------------------------------------------
0002+  CE4F             ; MXOS
0003+  CE4F             ; Преобразвоние строки в 16-ричное число
0004+  CE4F             ; Заимствовано из RAMFOS
0005+  CE4F             ;
0006+  CE4F             ; На входе
0007+  CE4F             ;  de - Строка
0008+  CE4F             ;
0009+  CE4F             ; На выходе
0010+  CE4F             ;  bc       - Сохраняется
0011+  CE4F             ;  de       - Следующий символ за запятой или концом строки
0012+  CE4F             ;  jz       - Ошибка
0013+  CE4F             ;  jnz, jc  - Конец строки
0014+  CE4F             ;  jnz, jnc - Пробел или запятая
0015+  CE4F             ;  hl       - Число
0016+  CE4F             ;
0017+  CE4F             ; 2013-11-01 Дизассемблировано vinxru
0018+  CE4F             ;----------------------------------------------------------------------------
0019+  CE4F             
0020+  CE4F             strToHex:
0021+  CE4F 21 00 00            lxi	h, 0		
0022+  CE52             
0023+  CE52             strToHex_loop:	; Чтение символа
0024+  CE52 1A          		ldax	d
0025+  CE53 13          		inx	d
0026+  CE54             
0027+  CE54             		; Если конец строки, выходим с флагами NZ, C
0028+  CE54 FE 0D       		cpi	0Dh
0029+  CE56 CA 8F CE    		jz	ora_a_stc_ret
0030+  CE59             
0031+  CE59             		; Если пробел или запятая, выходим с флагами NZ, NC
0032+  CE59 FE 2C       		cpi	','
0033+  CE5B CA 92 CE    		jz	ora_a_ret		
0034+  CE5E FE 20       		cpi	' '
0035+  CE60 CA 92 CE    		jz	ora_a_ret
0036+  CE63             
0037+  CE63             		; Если некорректный символ, выходим с флагами С,Z
0038+  CE63 D6 30       		sui	'0'
0039+  CE65 FA 89 CE    		jm	xra_a_stc_ret		
0040+  CE68             
0041+  CE68             		; Если это цифра
0042+  CE68 FE 0A       		cpi	10
0043+  CE6A FA 79 CE    		jm	strToHex_0
0044+  CE6D             
0045+  CE6D             		; Если некорректный символ, выходим с флагами С,Z
0046+  CE6D FE 11       		cpi	11h
0047+  CE6F FA 89 CE    		jm	xra_a_stc_ret
0048+  CE72 FE 17       		cpi	17h
0049+  CE74 F2 89 CE    		jp	xra_a_stc_ret
0050+  CE77             
0051+  CE77             		; Это буквы A..F
0052+  CE77 D6 07       		sui	'A'-'0'-10
0053+  CE79             
0054+  CE79             strToHex_0:	
0055+  CE79             		; hl *=	16
0056+  CE79 29          		dad	h
0057+  CE7A 29          		dad	h
0058+  CE7B 29          		dad	h
0059+  CE7C 29          		dad	h
0060+  CE7D             
0061+  CE7D             		; Если переполнение, выходим c флагами С,Z
0062+  CE7D DA 89 CE    		jc	xra_a_stc_ret
0063+  CE80             		
0064+  CE80             		; hl += bc
0065+  CE80 C5          		push b
0066+  CE81 06 00       		mvi  b, 0
0067+  CE83 4F          		mov  c, a
0068+  CE84 09          		dad  b
0069+  CE85 C1          		pop  b
0070+  CE86             
0071+  CE86 C3 52 CE    		jmp	strToHex_loop
0072+  CE89             
0073+  CE89             xra_a_stc_ret:	; Вывод знака вопроса
0074+  CE89 0E 3F               mvi	c, '?'
0075+  CE8B CD 37 C0            call	printChar
0076+  CE8E AF                  xra	a
0077+  CE8F             
0078+  CE8F             ora_a_stc_ret:
0079+  CE8F B7                  ora	a
0080+  CE90 37                  stc
0081+  CE91 C9                  ret
0082+  CE92             
0083+  CE92             ora_a_ret:
0084+  CE92 B7                  ora	a
0085+  CE93 C9                  ret
0221   CE94             #endif
0222   CE94             
0223   CE94             ; ---------------------------------------------------------------------------
0224   CE94             
0225   CE94 0A 42 41 44 aBadCommandOrFi:	.db 0Ah,"BAD COMMAND OR FILE NAME",0
0225   CE98 20 43 4F 4D 
0225   CE9C 4D 41 4E 44 
0225   CEA0 20 4F 52 20 
0225   CEA4 46 49 4C 45 
0225   CEA8 20 4E 41 4D 
0225   CEAC 45 00 
0226   CEAE 17 CB 17 CB v_drives:			.dw diskDriver, diskDriver, diskDriver, diskDriver  ; Addresses of drivers for 8 disks
0226   CEB2 17 CB 17 CB 
0227   CEB6 17 CB 17 CB 					.dw diskDriver, diskDriver, diskDriver, diskDriver  ; (initial value = diskDriver = C863h)
0227   CEBA 17 CB 17 CB 
0228   CEBE 00 00       v_findCluster:		.dw 0
0229   CEC0 01          v_drive:			.db 1
0230   CEC1 00 00       v_input_start:		.dw 0
0231   CEC3 00 00       v_createdFile:		.dw 0
0232   CEC5 00 00       v_foundedFile:		.dw 0
0233   CEC7 00 00       v_input_end:		.dw 0
0234   CEC9 00 00       v_batPtr:			.dw 0               ; aaddress of the buffer for BAT file content
0235   CECB FF FA       v_memTop:			.dw 0FAFFh          ; top memory address
0236   CECD             
0237   CECD 41 3A 4E 43 aANc_com:			.db "A:NC.COM",0
0237   CED1 2E 43 4F 4D 
0237   CED5 00 
0238   CED6 41 3A 41 55 aAAutoex_bat:		.db "A:AUTOEX.BAT",0
0238   CEDA 54 4F 45 58 
0238   CEDE 2E 42 41 54 
0238   CEE2 00 
0239   CEE3 42 41 54    aBat:				.db "BAT"
0240   CEE6 43 4F 4D    aCom:				.db "COM"
0241   CEE9 45 58 45    aExe:				.db "EXE"
0242   CEEC             
0243   CEEC FF FF FF FF v_fileName:			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0243   CEF0 FF FF 
0244   CEF2 FF FF FF    v_fileName_ext:		.db 0FFh, 0FFh, 0FFh
0245   CEF5 FF FF FF FF 					.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0245   CEF9 FF FF 
0246   CEFB FF          v_fileName_end:		.db 0FFh ; Copied including this unused byte
0247   CEFC FF FF FF    v_batFileName:		.db 0FFh, 0FFh,	0FFh
0248   CEFF FF FF FF FF 					.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0248   CF03 FF FF 
0249   CF05 FF          v_batFileN_end:		.db 0FFh ; Copied including this unused byte
0250   CF06             
0251   CF06             #if LOAD_FONT
0252   CF06             .include "font.inc"
0001+  CF06 21 38 C5    initFont:	lxi	h, reboot2
0002+  CF09 22 75 C4    		shld	onceInitFont+1
0003+  CF0C E5          		push	h
0004+  CF0D             
0005+  CF0D 21 19 CF    		lxi	h, font
0006+  CF10 11 19 D7    		lxi	d, fontEnd
0007+  CF13 01 00 E9    		lxi	b, FONT_ADDR
0008+  CF16 C3 2D C4    		jmp	memcpy_bc_hl
0009+  CF19             
0010+  CF19             font:
0011+  CF19 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 0
0011+  CF1D 00 00 00 00 
0012+  CF21 04 0E 15 04 	.db 004h,00Eh,015h,004h,015h,00Eh,004h,000h ; 1
0012+  CF25 15 0E 04 00 
0013+  CF29 00 00 04 0A 	.db 000h,000h,004h,00Ah,01Fh,000h,01Fh,000h ; 2
0013+  CF2D 1F 00 1F 00 
0014+  CF31 00 00 1F 0A 	.db 000h,000h,01Fh,00Ah,004h,000h,01Fh,000h ; 3
0014+  CF35 04 00 1F 00 
0015+  CF39 09 1B 2D 1B 	.db 009h,01Bh,02Dh,01Bh,009h,000h,000h,000h ; 4
0015+  CF3D 09 00 00 00 
0016+  CF41 24 36 2D 36 	.db 024h,036h,02Dh,036h,024h,000h,000h,000h ; 5
0016+  CF45 24 00 00 00 
0017+  CF49 1E 21 2D 29 	.db 01Eh,021h,02Dh,029h,02Dh,021h,01Eh,000h ; 6
0017+  CF4D 2D 21 1E 00 
0018+  CF51 10 18 17 15 	.db 010h,018h,017h,015h,017h,018h,010h,000h ; 7
0018+  CF55 17 18 10 00 
0019+  CF59 00 00 04 08 	.db 000h,000h,004h,008h,01Fh,008h,004h,000h ; 8
0019+  CF5D 1F 08 04 00 
0020+  CF61 00 00 14 12 	.db 000h,000h,014h,012h,01Fh,012h,014h,000h ; 9
0020+  CF65 1F 12 14 00 
0021+  CF69 13 12 13 1A 	.db 013h,012h,013h,01Ah,000h,01Fh,000h,000h ; 10
0021+  CF6D 00 1F 00 00 
0022+  CF71 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 11
0022+  CF75 00 00 00 00 
0023+  CF79 1C 18 14 02 	.db 01Ch,018h,014h,002h,001h,001h,001h,000h ; 12
0023+  CF7D 01 01 01 00 
0024+  CF81 1F 01 01 05 	.db 01Fh,001h,001h,005h,009h,01Fh,008h,004h ; 13
0024+  CF85 09 1F 08 04 
0025+  CF89 03 04 04 1C 	.db 003h,004h,004h,01Ch,03Ch,018h,000h,000h ; 14
0025+  CF8D 3C 18 00 00 
0026+  CF91 03 09 05 3F 	.db 003h,009h,005h,03Fh,005h,009h,003h,000h ; 15
0026+  CF95 05 09 03 00 
0027+  CF99 03 09 11 3F 	.db 003h,009h,011h,03Fh,011h,009h,003h,000h ; 16
0027+  CF9D 11 09 03 00 
0028+  CFA1 04 0A 11 0A 	.db 004h,00Ah,011h,00Ah,004h,000h,000h,000h ; 17
0028+  CFA5 04 00 00 00 
0029+  CFA9 11 11 11 11 	.db 011h,011h,011h,011h,011h,000h,011h,000h ; 18
0029+  CFAD 11 00 11 00 
0030+  CFB1 00 00 00 00 	.db 000h,000h,000h,000h,000h,011h,011h,000h ; 19
0030+  CFB5 00 11 11 00 
0031+  CFB9 00 08 00 08 	.db 000h,008h,000h,008h,000h,008h,000h,000h ; 20
0031+  CFBD 00 08 00 00 
0032+  CFC1 04 04 00 1F 	.db 004h,004h,000h,01Fh,000h,004h,004h,000h ; 21
0032+  CFC5 00 04 04 00 
0033+  CFC9 0F 08 08 08 	.db 00Fh,008h,008h,008h,008h,028h,010h,000h ; 22
0033+  CFCD 08 28 10 00 
0034+  CFD1 3F 00 00 00 	.db 03Fh,000h,000h,000h,000h,000h,000h,000h ; 23
0034+  CFD5 00 00 00 00 
0035+  CFD9 00 00 04 02 	.db 000h,000h,004h,002h,01Fh,002h,004h,000h ; 24
0035+  CFDD 1F 02 04 00 
0036+  CFE1 04 0E 15 04 	.db 004h,00Eh,015h,004h,004h,004h,004h,000h ; 25
0036+  CFE5 04 04 04 00 
0037+  CFE9 04 04 04 04 	.db 004h,004h,004h,004h,015h,00Eh,004h,000h ; 26
0037+  CFED 15 0E 04 00 
0038+  CFF1 1B 12 1A 12 	.db 01Bh,012h,01Ah,012h,01Bh,000h,01Fh,000h ; 27
0038+  CFF5 1B 00 1F 00 
0039+  CFF9 3F 01 00 00 	.db 03Fh,001h,000h,000h,000h,000h,000h,000h ; 28
0039+  CFFD 00 00 00 00 
0040+  D001 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 29
0040+  D005 00 00 00 00 
0041+  D009 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 30
0041+  D00D 00 00 00 00 
0042+  D011 1F 11 19 15 	.db 01Fh,011h,019h,015h,013h,011h,01Fh,000h ; 31
0042+  D015 13 11 1F 00 
0043+  D019 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 32
0043+  D01D 00 00 00 00 
0044+  D021 04 04 04 04 	.db 004h,004h,004h,004h,004h,000h,004h,000h ; 33
0044+  D025 04 00 04 00 
0045+  D029 0A 0A 0A 00 	.db 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
0045+  D02D 00 00 00 00 
0046+  D031 0A 0A 1F 0A 	.db 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
0046+  D035 1F 0A 0A 00 
0047+  D039 04 0F 14 0E 	.db 004h,00Fh,014h,00Eh,005h,01Eh,004h,000h ; 36
0047+  D03D 05 1E 04 00 
0048+  D041 10 11 02 04 	.db 010h,011h,002h,004h,008h,011h,001h,000h ; 37
0048+  D045 08 11 01 00 
0049+  D049 04 0A 0A 0C 	.db 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
0049+  D04D 15 12 0D 00 
0050+  D051 00 02 02 04 	.db 000h,002h,002h,004h,000h,000h,000h,000h ; 39
0050+  D055 00 00 00 00 
0051+  D059 02 04 08 08 	.db 002h,004h,008h,008h,008h,004h,002h,000h ; 40
0051+  D05D 08 04 02 00 
0052+  D061 08 04 02 02 	.db 008h,004h,002h,002h,002h,004h,008h,000h ; 41
0052+  D065 02 04 08 00 
0053+  D069 00 04 15 0E 	.db 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
0053+  D06D 15 04 00 00 
0054+  D071 00 04 04 1F 	.db 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
0054+  D075 04 04 00 00 
0055+  D079 00 00 00 00 	.db 000h,000h,000h,000h,000h,004h,004h,008h ; 44
0055+  D07D 00 04 04 08 
0056+  D081 00 00 00 1F 	.db 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
0056+  D085 00 00 00 00 
0057+  D089 00 00 00 00 	.db 000h,000h,000h,000h,000h,004h,004h,000h ; 46
0057+  D08D 00 04 04 00 
0058+  D091 00 01 02 04 	.db 000h,001h,002h,004h,008h,010h,000h,000h ; 47
0058+  D095 08 10 00 00 
0059+  D099 0E 11 13 15 	.db 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
0059+  D09D 19 11 0E 00 
0060+  D0A1 04 0C 04 04 	.db 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
0060+  D0A5 04 04 0E 00 
0061+  D0A9 0E 11 01 06 	.db 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
0061+  D0AD 08 10 1F 00 
0062+  D0B1 1F 01 02 06 	.db 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
0062+  D0B5 01 11 0E 00 
0063+  D0B9 02 06 0A 12 	.db 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
0063+  D0BD 1F 02 02 00 
0064+  D0C1 1F 10 1E 01 	.db 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
0064+  D0C5 01 11 0E 00 
0065+  D0C9 07 08 10 1E 	.db 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
0065+  D0CD 11 11 0E 00 
0066+  D0D1 1F 01 02 04 	.db 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
0066+  D0D5 08 08 08 00 
0067+  D0D9 0E 11 11 0E 	.db 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
0067+  D0DD 11 11 0E 00 
0068+  D0E1 0E 11 11 0F 	.db 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
0068+  D0E5 01 02 1C 00 
0069+  D0E9 00 04 04 00 	.db 000h,004h,004h,000h,000h,004h,004h,000h ; 58
0069+  D0ED 00 04 04 00 
0070+  D0F1 00 04 04 00 	.db 000h,004h,004h,000h,000h,004h,004h,008h ; 59
0070+  D0F5 00 04 04 08 
0071+  D0F9 02 04 08 10 	.db 002h,004h,008h,010h,008h,004h,002h,000h ; 60
0071+  D0FD 08 04 02 00 
0072+  D101 00 00 1F 00 	.db 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
0072+  D105 1F 00 00 00 
0073+  D109 08 04 02 01 	.db 008h,004h,002h,001h,002h,004h,008h,000h ; 62
0073+  D10D 02 04 08 00 
0074+  D111 0E 11 01 02 	.db 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
0074+  D115 04 00 04 00 
0075+  D119 0E 11 13 15 	.db 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
0075+  D11D 17 10 0E 00 
0076+  D121 04 0A 11 11 	.db 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
0076+  D125 1F 11 11 00 
0077+  D129 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
0077+  D12D 11 11 1E 00 
0078+  D131 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
0078+  D135 10 11 0E 00 
0079+  D139 1E 09 09 09 	.db 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
0079+  D13D 09 09 1E 00 
0080+  D141 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
0080+  D145 10 10 1F 00 
0081+  D149 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
0081+  D14D 10 10 10 00 
0082+  D151 0E 11 10 10 	.db 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
0082+  D155 13 11 0F 00 
0083+  D159 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
0083+  D15D 11 11 11 00 
0084+  D161 0E 04 04 04 	.db 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
0084+  D165 04 04 0E 00 
0085+  D169 01 01 01 01 	.db 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
0085+  D16D 11 11 0E 00 
0086+  D171 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 75
0086+  D175 14 12 11 00 
0087+  D179 10 10 10 10 	.db 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
0087+  D17D 10 11 1F 00 
0088+  D181 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
0088+  D185 11 11 11 00 
0089+  D189 11 11 19 15 	.db 011h,011h,019h,015h,013h,011h,011h,000h ; 78
0089+  D18D 13 11 11 00 
0090+  D191 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
0090+  D195 11 11 0E 00 
0091+  D199 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
0091+  D19D 10 10 10 00 
0092+  D1A1 0E 11 11 11 	.db 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
0092+  D1A5 15 12 0D 00 
0093+  D1A9 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
0093+  D1AD 14 12 11 00 
0094+  D1B1 0E 11 10 0E 	.db 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
0094+  D1B5 01 11 0E 00 
0095+  D1B9 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
0095+  D1BD 04 04 04 00 
0096+  D1C1 11 11 11 11 	.db 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
0096+  D1C5 11 11 0E 00 
0097+  D1C9 11 11 11 0A 	.db 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
0097+  D1CD 0A 04 04 00 
0098+  D1D1 11 11 11 15 	.db 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
0098+  D1D5 15 15 0A 00 
0099+  D1D9 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
0099+  D1DD 0A 11 11 00 
0100+  D1E1 11 11 0A 04 	.db 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
0100+  D1E5 04 04 04 00 
0101+  D1E9 1F 01 02 0E 	.db 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
0101+  D1ED 08 10 1F 00 
0102+  D1F1 0E 08 08 08 	.db 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
0102+  D1F5 08 08 0E 00 
0103+  D1F9 00 10 08 04 	.db 000h,010h,008h,004h,002h,001h,000h,000h ; 92
0103+  D1FD 02 01 00 00 
0104+  D201 0E 02 02 02 	.db 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
0104+  D205 02 02 0E 00 
0105+  D209 04 0A 11 00 	.db 004h,00Ah,011h,000h,000h,000h,000h,000h ; 94
0105+  D20D 00 00 00 00 
0106+  D211 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 95
0106+  D215 00 00 00 00 
0107+  D219 00 0F 00 06 	.db 000h,00Fh,000h,006h,009h,009h,006h,000h ; 96
0107+  D21D 09 09 06 00 
0108+  D221 00 00 0C 02 	.db 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 97
0108+  D225 0E 12 0D 00 
0109+  D229 08 08 08 0E 	.db 008h,008h,008h,00Eh,009h,009h,016h,000h ; 98
0109+  D22D 09 09 16 00 
0110+  D231 00 00 0E 11 	.db 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 99
0110+  D235 10 11 0E 00 
0111+  D239 02 02 02 0E 	.db 002h,002h,002h,00Eh,012h,012h,00Dh,000h ; 100
0111+  D23D 12 12 0D 00 
0112+  D241 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 101
0112+  D245 1F 10 0E 00 
0113+  D249 06 09 08 1C 	.db 006h,009h,008h,01Ch,008h,008h,008h,000h ; 102
0113+  D24D 08 08 08 00 
0114+  D251 00 00 0D 12 	.db 000h,000h,00Dh,012h,012h,00Eh,002h,01Ch ; 103
0114+  D255 12 0E 02 1C 
0115+  D259 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
0115+  D25D 11 11 11 00 
0116+  D261 00 10 00 10 	.db 000h,010h,000h,010h,010h,011h,00Eh,000h ; 105
0116+  D265 10 11 0E 00 
0117+  D269 00 01 00 01 	.db 000h,001h,000h,001h,001h,001h,011h,00Eh ; 106
0117+  D26D 01 01 11 0E 
0118+  D271 10 10 11 12 	.db 010h,010h,011h,012h,01Ch,012h,011h,000h ; 107
0118+  D275 1C 12 11 00 
0119+  D279 10 10 10 10 	.db 010h,010h,010h,010h,010h,011h,00Eh,000h ; 108
0119+  D27D 10 11 0E 00 
0120+  D281 00 00 1A 15 	.db 000h,000h,01Ah,015h,015h,015h,015h,000h ; 109
0120+  D285 15 15 15 00 
0121+  D289 00 00 16 19 	.db 000h,000h,016h,019h,011h,011h,011h,000h ; 110
0121+  D28D 11 11 11 00 
0122+  D291 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
0122+  D295 11 11 0E 00 
0123+  D299 00 00 16 09 	.db 000h,000h,016h,009h,009h,00Eh,008h,008h ; 112
0123+  D29D 09 0E 08 08 
0124+  D2A1 00 00 0D 12 	.db 000h,000h,00Dh,012h,012h,00Eh,002h,002h ; 113
0124+  D2A5 12 0E 02 02 
0125+  D2A9 00 00 16 09 	.db 000h,000h,016h,009h,008h,008h,008h,000h ; 114
0125+  D2AD 08 08 08 00 
0126+  D2B1 00 00 0E 10 	.db 000h,000h,00Eh,010h,00Eh,001h,00Eh,000h ; 115
0126+  D2B5 0E 01 0E 00 
0127+  D2B9 08 08 1C 08 	.db 008h,008h,01Ch,008h,008h,009h,006h,000h ; 116
0127+  D2BD 08 09 06 00 
0128+  D2C1 00 00 12 12 	.db 000h,000h,012h,012h,012h,012h,00Dh,000h ; 117
0128+  D2C5 12 12 0D 00 
0129+  D2C9 00 00 11 11 	.db 000h,000h,011h,011h,011h,00Ah,004h,000h ; 118
0129+  D2CD 11 0A 04 00 
0130+  D2D1 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,00Ah,000h ; 119
0130+  D2D5 15 15 0A 00 
0131+  D2D9 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
0131+  D2DD 04 0A 11 00 
0132+  D2E1 00 00 11 11 	.db 000h,000h,011h,011h,011h,00Fh,001h,00Eh ; 121
0132+  D2E5 11 0F 01 0E 
0133+  D2E9 00 00 1F 01 	.db 000h,000h,01Fh,001h,00Eh,010h,01Fh,000h ; 122
0133+  D2ED 0E 10 1F 00 
0134+  D2F1 03 04 04 18 	.db 003h,004h,004h,018h,004h,004h,003h,000h ; 123
0134+  D2F5 04 04 03 00 
0135+  D2F9 1F 11 11 11 	.db 01Fh,011h,011h,011h,011h,011h,01Fh,000h ; 124
0135+  D2FD 11 11 1F 00 
0136+  D301 18 04 04 03 	.db 018h,004h,004h,003h,004h,004h,018h,000h ; 125
0136+  D305 04 04 18 00 
0137+  D309 00 00 08 15 	.db 000h,000h,008h,015h,002h,000h,000h,000h ; 126
0137+  D30D 02 00 00 00 
0138+  D311 01 03 07 0F 	.db 001h,003h,007h,00Fh,007h,003h,001h,000h ; 127
0138+  D315 07 03 01 00 
0139+  D319 00 00 0A 1F 	.db 000h,000h,00Ah,01Fh,01Fh,00Eh,004h,000h ; 128
0139+  D31D 1F 0E 04 00 
0140+  D321 00 04 04 1F 	.db 000h,004h,004h,01Fh,004h,004h,01Bh,000h ; 129
0140+  D325 04 04 1B 00 
0141+  D329 04 0E 1F 1F 	.db 004h,00Eh,01Fh,01Fh,00Ah,004h,01Bh,000h ; 130
0141+  D32D 0A 04 1B 00 
0142+  D331 00 00 04 0E 	.db 000h,000h,004h,00Eh,01Fh,00Eh,004h,000h ; 131
0142+  D335 1F 0E 04 00 
0143+  D339 02 04 0A 15 	.db 002h,004h,00Ah,015h,011h,011h,00Eh,000h ; 132
0143+  D33D 11 11 0E 00 
0144+  D341 0E 04 1F 15 	.db 00Eh,004h,01Fh,015h,004h,00Ah,011h,000h ; 133
0144+  D345 04 0A 11 00 
0145+  D349 03 04 06 09 	.db 003h,004h,006h,009h,006h,002h,00Ch,000h ; 134
0145+  D34D 06 02 0C 00 
0146+  D351 07 03 05 0C 	.db 007h,003h,005h,00Ch,012h,012h,00Ch,000h ; 135
0146+  D355 12 12 0C 00 
0147+  D359 0E 11 11 0E 	.db 00Eh,011h,011h,00Eh,004h,00Eh,004h,000h ; 136
0147+  D35D 04 0E 04 00 
0148+  D361 00 17 14 1F 	.db 000h,017h,014h,01Fh,005h,01Dh,000h,000h ; 137
0148+  D365 05 1D 00 00 
0149+  D369 04 04 1F 04 	.db 004h,004h,01Fh,004h,014h,00Ch,006h,005h ; 138
0149+  D36D 14 0C 06 05 
0150+  D371 04 1F 04 0A 	.db 004h,01Fh,004h,00Ah,011h,01Fh,004h,000h ; 139
0150+  D375 11 1F 04 00 
0151+  D379 04 1F 05 0A 	.db 004h,01Fh,005h,00Ah,011h,01Fh,004h,000h ; 140
0151+  D37D 11 1F 04 00 
0152+  D381 04 04 1F 00 	.db 004h,004h,01Fh,000h,01Fh,004h,004h,000h ; 141
0152+  D385 1F 04 04 00 
0153+  D389 04 0E 0A 0A 	.db 004h,00Eh,00Ah,00Ah,00Ah,00Eh,004h,000h ; 142
0153+  D38D 0A 0E 04 00 
0154+  D391 04 06 01 06 	.db 004h,006h,001h,006h,001h,006h,004h,000h ; 143
0154+  D395 01 06 04 00 
0155+  D399 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 144
0155+  D39D 3F 00 00 00 
0156+  D3A1 30 30 30 30 	.db 030h,030h,030h,030h,030h,030h,030h,030h ; 145
0156+  D3A5 30 30 30 30 
0157+  D3A9 03 03 03 03 	.db 003h,003h,003h,003h,003h,003h,003h,003h ; 146
0157+  D3AD 03 03 03 03 
0158+  D3B1 30 30 30 3F 	.db 030h,030h,030h,03Fh,03Fh,030h,030h,030h ; 147
0158+  D3B5 3F 30 30 30 
0159+  D3B9 03 03 03 3F 	.db 003h,003h,003h,03Fh,03Fh,003h,003h,003h ; 148
0159+  D3BD 3F 03 03 03 
0160+  D3C1 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,030h,030h,030h ; 149
0160+  D3C5 3F 30 30 30 
0161+  D3C9 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,003h,003h,003h ; 150
0161+  D3CD 3F 03 03 03 
0162+  D3D1 03 03 03 3F 	.db 003h,003h,003h,03Fh,03Fh,000h,000h,000h ; 151
0162+  D3D5 3F 00 00 00 
0163+  D3D9 30 30 30 3F 	.db 030h,030h,030h,03Fh,03Fh,000h,000h,000h ; 152
0163+  D3DD 3F 00 00 00 
0164+  D3E1 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,018h,018h,018h ; 153
0164+  D3E5 3F 18 18 18 
0165+  D3E9 18 18 18 18 	.db 018h,018h,018h,018h,018h,018h,018h,018h ; 154
0165+  D3ED 18 18 18 18 
0166+  D3F1 18 18 18 3F 	.db 018h,018h,018h,03Fh,03Fh,000h,000h,000h ; 155
0166+  D3F5 3F 00 00 00 
0167+  D3F9 18 18 18 3F 	.db 018h,018h,018h,03Fh,03Fh,018h,018h,018h ; 156
0167+  D3FD 3F 18 18 18 
0168+  D401 00 00 01 02 	.db 000h,000h,001h,002h,014h,008h,000h,000h ; 157
0168+  D405 14 08 00 00 
0169+  D409 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 158
0169+  D40D 00 00 00 00 
0170+  D411 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 159
0170+  D415 00 00 00 00 
0171+  D419 02 02 0A 16 	.db 002h,002h,00Ah,016h,012h,012h,00Dh,000h ; 160
0171+  D41D 12 12 0D 00 
0172+  D421 06 09 0E 09 	.db 006h,009h,00Eh,009h,00Eh,008h,010h,000h ; 161
0172+  D425 0E 08 10 00 
0173+  D429 1F 11 11 10 	.db 01Fh,011h,011h,010h,010h,010h,010h,000h ; 162
0173+  D42D 10 10 10 00 
0174+  D431 0F 10 12 0A 	.db 00Fh,010h,012h,00Ah,00Ah,00Ah,011h,000h ; 163
0174+  D435 0A 0A 11 00 
0175+  D439 1F 08 04 02 	.db 01Fh,008h,004h,002h,004h,008h,01Fh,000h ; 164
0175+  D43D 04 08 1F 00 
0176+  D441 05 0A 10 1E 	.db 005h,00Ah,010h,01Eh,011h,011h,00Eh,000h ; 165
0176+  D445 11 11 0E 00 
0177+  D449 09 09 09 09 	.db 009h,009h,009h,009h,00Fh,009h,010h,000h ; 166
0177+  D44D 0F 09 10 00 
0178+  D451 08 14 04 02 	.db 008h,014h,004h,002h,006h,009h,011h,000h ; 167
0178+  D455 06 09 11 00 
0179+  D459 15 15 15 0E 	.db 015h,015h,015h,00Eh,004h,004h,004h,000h ; 168
0179+  D45D 04 04 04 00 
0180+  D461 0E 11 1B 1F 	.db 00Eh,011h,01Bh,01Fh,01Bh,011h,00Eh,000h ; 169
0180+  D465 1B 11 0E 00 
0181+  D469 0E 11 11 0E 	.db 00Eh,011h,011h,00Eh,004h,015h,01Bh,000h ; 170
0181+  D46D 04 15 1B 00 
0182+  D471 06 09 09 06 	.db 006h,009h,009h,006h,000h,000h,000h,000h ; 171
0182+  D475 00 00 00 00 
0183+  D479 0E 13 15 19 	.db 00Eh,013h,015h,019h,00Eh,000h,000h,000h ; 172
0183+  D47D 0E 00 00 00 
0184+  D481 02 06 02 02 	.db 002h,006h,002h,002h,007h,000h,000h,000h ; 173
0184+  D485 07 00 00 00 
0185+  D489 06 09 02 04 	.db 006h,009h,002h,004h,00Fh,000h,000h,000h ; 174
0185+  D48D 0F 00 00 00 
0186+  D491 0F 01 02 09 	.db 00Fh,001h,002h,009h,006h,000h,000h,000h ; 175
0186+  D495 06 00 00 00 
0187+  D499 0A 0A 0F 02 	.db 00Ah,00Ah,00Fh,002h,002h,000h,000h,000h ; 176
0187+  D49D 02 00 00 00 
0188+  D4A1 0E 08 0E 01 	.db 00Eh,008h,00Eh,001h,00Eh,000h,000h,000h ; 177
0188+  D4A5 0E 00 00 00 
0189+  D4A9 06 08 0E 09 	.db 006h,008h,00Eh,009h,006h,000h,000h,000h ; 178
0189+  D4AD 06 00 00 00 
0190+  D4B1 0F 01 02 04 	.db 00Fh,001h,002h,004h,004h,000h,000h,000h ; 179
0190+  D4B5 04 00 00 00 
0191+  D4B9 06 09 06 09 	.db 006h,009h,006h,009h,006h,000h,000h,000h ; 180
0191+  D4BD 06 00 00 00 
0192+  D4C1 06 09 07 01 	.db 006h,009h,007h,001h,006h,000h,000h,000h ; 181
0192+  D4C5 06 00 00 00 
0193+  D4C9 00 00 0E 13 	.db 000h,000h,00Eh,013h,015h,019h,00Eh,000h ; 182
0193+  D4CD 15 19 0E 00 
0194+  D4D1 00 00 02 06 	.db 000h,000h,002h,006h,002h,002h,007h,000h ; 183
0194+  D4D5 02 02 07 00 
0195+  D4D9 00 00 06 09 	.db 000h,000h,006h,009h,002h,004h,00Fh,000h ; 184
0195+  D4DD 02 04 0F 00 
0196+  D4E1 00 00 0F 01 	.db 000h,000h,00Fh,001h,002h,009h,006h,000h ; 185
0196+  D4E5 02 09 06 00 
0197+  D4E9 00 00 0A 0A 	.db 000h,000h,00Ah,00Ah,00Fh,002h,002h,000h ; 186
0197+  D4ED 0F 02 02 00 
0198+  D4F1 00 00 0E 08 	.db 000h,000h,00Eh,008h,00Eh,001h,00Eh,000h ; 187
0198+  D4F5 0E 01 0E 00 
0199+  D4F9 00 00 06 08 	.db 000h,000h,006h,008h,00Eh,009h,006h,000h ; 188
0199+  D4FD 0E 09 06 00 
0200+  D501 00 00 0F 01 	.db 000h,000h,00Fh,001h,002h,004h,004h,000h ; 189
0200+  D505 02 04 04 00 
0201+  D509 00 00 06 09 	.db 000h,000h,006h,009h,006h,009h,006h,000h ; 190
0201+  D50D 06 09 06 00 
0202+  D511 00 00 06 09 	.db 000h,000h,006h,009h,007h,001h,006h,000h ; 191
0202+  D515 07 01 06 00 
0203+  D519 00 00 12 15 	.db 000h,000h,012h,015h,01Dh,015h,012h,000h ; 192
0203+  D51D 1D 15 12 00 
0204+  D521 00 00 0C 02 	.db 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 193
0204+  D525 0E 12 0D 00 
0205+  D529 01 0E 10 1E 	.db 001h,00Eh,010h,01Eh,011h,011h,00Eh,000h ; 194
0205+  D52D 11 11 0E 00 
0206+  D531 00 00 12 12 	.db 000h,000h,012h,012h,012h,012h,00Fh,001h ; 195
0206+  D535 12 12 0F 01 
0207+  D539 0E 01 01 0F 	.db 00Eh,001h,001h,00Fh,011h,011h,00Eh,000h ; 196
0207+  D53D 11 11 0E 00 
0208+  D541 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 197
0208+  D545 1F 10 0E 00 
0209+  D549 00 00 0E 15 	.db 000h,000h,00Eh,015h,015h,00Eh,004h,004h ; 198
0209+  D54D 15 0E 04 04 
0210+  D551 00 00 0C 12 	.db 000h,000h,00Ch,012h,004h,009h,006h,000h ; 199
0210+  D555 04 09 06 00 
0211+  D559 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 200
0211+  D55D 04 0A 11 00 
0212+  D561 00 00 12 12 	.db 000h,000h,012h,012h,012h,012h,00Dh,000h ; 201
0212+  D565 12 12 0D 00 
0213+  D569 0C 00 12 12 	.db 00Ch,000h,012h,012h,012h,012h,00Dh,000h ; 202
0213+  D56D 12 12 0D 00 
0214+  D571 00 00 11 12 	.db 000h,000h,011h,012h,01Ch,012h,011h,000h ; 203
0214+  D575 1C 12 11 00 
0215+  D579 00 00 07 09 	.db 000h,000h,007h,009h,009h,009h,011h,000h ; 204
0215+  D57D 09 09 11 00 
0216+  D581 00 00 11 1B 	.db 000h,000h,011h,01Bh,015h,011h,011h,000h ; 205
0216+  D585 15 11 11 00 
0217+  D589 00 00 11 11 	.db 000h,000h,011h,011h,01Fh,011h,011h,000h ; 206
0217+  D58D 1F 11 11 00 
0218+  D591 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 207
0218+  D595 11 11 0E 00 
0219+  D599 00 00 1F 11 	.db 000h,000h,01Fh,011h,011h,011h,011h,000h ; 208
0219+  D59D 11 11 11 00 
0220+  D5A1 00 00 0F 11 	.db 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 209
0220+  D5A5 0F 09 11 00 
0221+  D5A9 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,01Eh,010h,000h ; 210
0221+  D5AD 11 1E 10 00 
0222+  D5B1 00 00 0E 11 	.db 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 211
0222+  D5B5 10 11 0E 00 
0223+  D5B9 00 00 1F 04 	.db 000h,000h,01Fh,004h,004h,004h,004h,000h ; 212
0223+  D5BD 04 04 04 00 
0224+  D5C1 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,001h,00Eh ; 213
0224+  D5C5 0F 01 01 0E 
0225+  D5C9 00 00 15 15 	.db 000h,000h,015h,015h,00Eh,015h,015h,000h ; 214
0225+  D5CD 0E 15 15 00 
0226+  D5D1 0C 14 18 1E 	.db 00Ch,014h,018h,01Eh,011h,011h,00Eh,000h ; 215
0226+  D5D5 11 11 0E 00 
0227+  D5D9 00 00 10 10 	.db 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 216
0227+  D5DD 1E 11 1E 00 
0228+  D5E1 00 00 11 11 	.db 000h,000h,011h,011h,01Dh,013h,01Dh,000h ; 217
0228+  D5E5 1D 13 1D 00 
0229+  D5E9 00 00 0E 11 	.db 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 218
0229+  D5ED 06 11 0E 00 
0230+  D5F1 00 00 11 15 	.db 000h,000h,011h,015h,015h,015h,01Fh,000h ; 219
0230+  D5F5 15 15 1F 00 
0231+  D5F9 00 00 1E 01 	.db 000h,000h,01Eh,001h,007h,001h,01Eh,000h ; 220
0231+  D5FD 07 01 1E 00 
0232+  D601 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,01Fh,001h ; 221
0232+  D605 15 15 1F 01 
0233+  D609 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,001h,000h ; 222
0233+  D60D 0F 01 01 00 
0234+  D611 00 00 18 08 	.db 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 223
0234+  D615 0E 09 0E 00 
0235+  D619 12 15 15 1D 	.db 012h,015h,015h,01Dh,015h,015h,012h,000h ; 224
0235+  D61D 15 15 12 00 
0236+  D621 0E 11 11 11 	.db 00Eh,011h,011h,011h,01Fh,011h,011h,000h ; 225
0236+  D625 1F 11 11 00 
0237+  D629 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 226
0237+  D62D 11 11 1E 00 
0238+  D631 12 12 12 12 	.db 012h,012h,012h,012h,012h,012h,01Fh,001h ; 227
0238+  D635 12 12 1F 01 
0239+  D639 06 0A 0A 0A 	.db 006h,00Ah,00Ah,00Ah,00Ah,01Fh,011h,000h ; 228
0239+  D63D 0A 1F 11 00 
0240+  D641 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 229
0240+  D645 10 10 1F 00 
0241+  D649 04 1F 15 15 	.db 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 230
0241+  D64D 1F 04 04 00 
0242+  D651 1F 11 10 10 	.db 01Fh,011h,010h,010h,010h,010h,010h,000h ; 231
0242+  D655 10 10 10 00 
0243+  D659 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 232
0243+  D65D 0A 11 11 00 
0244+  D661 11 11 13 15 	.db 011h,011h,013h,015h,019h,011h,011h,000h ; 233
0244+  D665 19 11 11 00 
0245+  D669 15 11 13 15 	.db 015h,011h,013h,015h,019h,011h,011h,000h ; 234
0245+  D66D 19 11 11 00 
0246+  D671 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 235
0246+  D675 14 12 11 00 
0247+  D679 07 09 09 09 	.db 007h,009h,009h,009h,009h,009h,019h,000h ; 236
0247+  D67D 09 09 19 00 
0248+  D681 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 237
0248+  D685 11 11 11 00 
0249+  D689 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 238
0249+  D68D 11 11 11 00 
0250+  D691 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 239
0250+  D695 11 11 0E 00 
0251+  D699 1F 11 11 11 	.db 01Fh,011h,011h,011h,011h,011h,011h,000h ; 240
0251+  D69D 11 11 11 00 
0252+  D6A1 0F 11 11 0F 	.db 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 241
0252+  D6A5 05 09 11 00 
0253+  D6A9 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 242
0253+  D6AD 10 10 10 00 
0254+  D6B1 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 243
0254+  D6B5 10 11 0E 00 
0255+  D6B9 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 244
0255+  D6BD 04 04 04 00 
0256+  D6C1 11 11 11 0A 	.db 011h,011h,011h,00Ah,004h,008h,010h,000h ; 245
0256+  D6C5 04 08 10 00 
0257+  D6C9 11 15 15 0E 	.db 011h,015h,015h,00Eh,015h,015h,011h,000h ; 246
0257+  D6CD 15 15 11 00 
0258+  D6D1 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 247
0258+  D6D5 11 11 1E 00 
0259+  D6D9 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 248
0259+  D6DD 11 11 1E 00 
0260+  D6E1 11 11 11 19 	.db 011h,011h,011h,019h,015h,015h,019h,000h ; 249
0260+  D6E5 15 15 19 00 
0261+  D6E9 0E 11 01 06 	.db 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 250
0261+  D6ED 01 11 0E 00 
0262+  D6F1 11 15 15 15 	.db 011h,015h,015h,015h,015h,015h,01Fh,000h ; 251
0262+  D6F5 15 15 1F 00 
0263+  D6F9 0E 11 01 07 	.db 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 252
0263+  D6FD 01 11 0E 00 
0264+  D701 15 15 15 15 	.db 015h,015h,015h,015h,015h,015h,01Fh,001h ; 253
0264+  D705 15 15 1F 01 
0265+  D709 11 11 11 0F 	.db 011h,011h,011h,00Fh,001h,001h,001h,000h ; 254
0265+  D70D 01 01 01 00 
0266+  D711 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,01Fh ; 255
0266+  D715 00 00 00 1F 
0267+  D719             fontEnd:
0268+  D719             
0253   D719~            #else
0254   D719~            notused:	.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0255   D719~            			.db 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0256   D719~            			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0257   D719~            			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0258   D719~            			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0259   D719~            			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0260   D719~            			.db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
0261   D719             #endif
0262   D719             
0263   D719             .end
tasm: Number of errors = 0
