  1   0000              ;----------------------------------------------------------------------------
  2   0000              ; MXOS - BIOS и DOS
  3   0000              ;
  4   0000              ; 2013-12-12 Дизассемблировано и доработано vinxru
  5   0000              ; 2022-01-31 Доработано SpaceEngineer
  6   0000              ;----------------------------------------------------------------------------
  7   0000
  8   0000                  INCLUDE "../include/mxos.inc"
  1+  0000              ;-----------------------------------------------------------------------
  2+  0000              ; MXOS
  3+  0000              ; Точки входа и настройки сборки MXOS
  4+  0000              ;
  5+  0000              ; Новая карта памяти:
  6+  0000              ;   8FDF-8FFF - [  32 B] Переменные
  7+  0000              ;   9000-BFFF - [12  KB] Экран
  8+  0000              ;   C000-D3FF - [5120 B] DOS.SYS
  9+  0000              ;   D400-DBFF - [2048 B] Свободно (2048 байт)
 10+  0000              ;   DC00-EDFF - [ 512 B] Драйвер магнитофона
 11+  0000              ;   DE00-DFFF - [ 512 B] Драйвер флеш-диска
 12+  0000              ;   E000-E7FF - [2048 B] Шрифт
 13+  0000              ;   E800-FAFF - [4864 B] Системные программы (NC.COM, E.COM, DL-RED.COM, FORMAT.COM, MON2.COM, ...)
 14+  0000              ;   FB00-FEFF - [1024 B] Дисковый кэш (fat + каталог)
 15+  0000              ;   FF00-FF81 - [ 130 B] Командная строка
 16+  0000              ;   FF82-FFBF - [  62 B] Стек
 17+  0000              ;   FFC0-FFEF - [  32 B] Непереключаемое ОЗУ, драйвер обмена с RAM диском
 18+  0000              ;   FFE0-FFFF - [  32 B] Оборудование
 19+  0000              ;
 20+  0000              ; Старая карта памяти:
 21+  0000              ;   8FDF-8FFF - [  32 B] Переменные
 22+  0000              ;   9000-BFFF - [12  KB] Экран
 23+  0000              ;   C000-CFFF - [4096 B] DOS.SYS
 24+  0000              ;   D000-E1FF - [4607 B] Системные программы (NC.COM, E.COM, DL-RED.COM)
 25+  0000              ;   E200-E5FF - [1024 B] Свободно (1024 байт)
 26+  0000              ;   E600-E7FF - [ 512 B] Драйвер магнитофона
 27+  0000              ;   E800-E8FF - [ 256 B] Свободно (256 байт)
 28+  0000              ;   E900-F0FF - [2048 B] Шрифт (можно отключить запуском ROMFNT.COM или опцией LOAD_FONT=0)
 29+  0000              ;   F100-F8FF - [2048 B] Системные программы (FORMAT.COM, MON2.COM, ...)
 30+  0000              ;   F900-F9FF - [ 256 B] Свободно (256 байт)
 31+  0000              ;   FA00-FAFF - [ 256 B] Драйвер флеш-диска
 32+  0000              ;   FB00-FEFF - [1024 B] Дисковый буфер (fat + каталог)
 33+  0000              ;   FF00-FF81 - [ 130 B] Командная строка
 34+  0000              ;   FF82-FFBF - [  62 B] Стек
 35+  0000              ;   FFC0-FFEF - [  32 B] Непереключаемое ОЗУ, драйвер обмена с RAM диском
 36+  0000              ;   FFE0-FFFF - [  32 B] Оборудование
 37+  0000              ;-----------------------------------------------------------------------
 38+  0000
 39+  0000
 40+  0000              ;-----------------------------------------------------------------------
 41+  0000              ; Конфигурация сборки
 42+  0000              ;-----------------------------------------------------------------------
 43+  0000
 44+  0000              NEW_MEMORY_MAP       =  1       ; Новая карта памяти
 45+  0000              RAMD_MAX_PAGE        =  16      ; Максимальное количество страниц RAM диска
 46+  0000              RAMD_PAGE_END        =  0FFBBh  ; Включить поддержку ДОЗУ большего чем 64 Кб
 47+  0000              ROM_64K              =  1       ; Включить поддержку ПЗУ 64 Кб Специалиста МХ2
 48+  0000              ENABLE_COLOR         =  1       ; Включить поддержку цвета
 49+  0000              EMBED_FONT           =  0       ; Встроить шрифт в программу (при запуске шрифт копируется на FONT_ADDR)
 50+  0000              LOAD_FONT            =  1       ; Загружать шрифт в ОЗУ
 51+  0000              COLOR_BIOS           =  0F0h    ; Цвет командной строки
 52+  0000              RAMFOS_COMPATIBILITY =  1       ; Совместимость с RAMFOS (WIP)
 53+  0000              BOOT_FROM_TAPE       =  0       ; Включить загрузку с ленты при нажатой клавише после сброса
 54+  0000
 55+  0000                  IF  NEW_MEMORY_MAP
 56+  0000              FONT_ADDR = 0E000h  ; Адрес шрфита
 57+  0000                  ELSE
 58+  0000 ~            FONT_ADDR = 0E900h  ; Адрес шрфита
 59+  0000                  ENDIF
 60+  0000
 61+  0000                  IF  LOAD_FONT
 62+  0000              FONT_ADDR_DIV_8 = FONT_ADDR/8
 63+  0000                  ELSE
 64+  0000 ~            FONT_ADDR_DIV_8 = -1
 65+  0000                  ENDIF
 66+  0000
 67+  0000              ;-----------------------------------------------------------------------
 68+  0000              ; Переменные ОС в подэкранном пространстве и их начальные значения
 69+  0000              ; Доступ к переменным из программ польователя:
 70+  0000              ; ld a, bios_vars.lastKey
 71+  0000              ;-----------------------------------------------------------------------
 72+  0000
 73+  0000                  STRUCT BIOS_VARIABLES
 74+  0000 ~            _reserv_1     DW      -1              ; 8FDFh -
 75+  0000 ~            tapeError     DW      0C800h          ; 8FE1h - Адрес, куда происходит переход при ошибке чтения с ленты
 76+  0000 ~            tapeAddr      DW      -1              ; 8FE3h - Адрес программы загруженной с ленты
 77+  0000 ~            _reserv_2     DW      -1              ; 8FE5h -
 78+  0000 ~            charGen       DW      FONT_ADDR_DIV_8 ; 8FE7h - Адрес альтернативного знакогенератора / 8
 79+  0000 ~            cursorCfg     DB       21h ; 0A9h     ; 8FE9h - Внешний вид курсора (биты: 7 - мигание (если 0), 654 - положение (Y) от низа строки, 3210 - размер по высоте)
 80+  0000 ~            koi7          DB       0   ; 0FFh     ; 8FEAh - 0FFh = включен KOI-7, 0 = включен KOI-8
 81+  0000 ~            escMode       DB      -1              ; 8FEBh - Обработка ESC-последовательности
 82+  0000 ~            keyLocks      DB      0BAh ; 3Ah      ; 8FECh - Caps Lock или Рус/Lat (3A - прописные анг, BA - строчные анг, BB - прописные рус, 3B - строчные рус)
 83+  0000 ~            _reserv_3     DW      -1              ; 8FEDh -
 84+  0000 ~            lastLastKey   DB      -1              ; 8FEFh - Предпоследняя нажатая клавиша
 85+  0000 ~            lastKey       DB      -1              ; 8FF0h - Последняя нажатая клавиша
 86+  0000 ~            beepFreq      DB       5Fh            ; 8FF1h - Частота звукового сигнала (также влияет на длительность)
 87+  0000 ~            beepDuration  DB       20h            ; 8FF2h - Длительность звукового сигнала (сколько раз повторять посылку)
 88+  0000 ~            tapeInverse   DB      0FFh            ; 8FF3h - Признак инверсии данных с ленты
 89+  0000 ~            cursorDelay   DB       20h            ; 8FF4h - Задержка мигания курсора
 90+  0000 ~            antiBsDelay   DB      0E0h            ; 8FF5h - Задержка защиты от дребезга контактов клавиш
 91+  0000 ~            oldSP         DW      -1              ; 8FF6h - Используется для сохранения SP некоторыми функциями
 92+  0000 ~            ramPageCount  DB      RAMD_MAX_PAGE   ; 8FF8h - Количество детектированных 64кб страниц RAM-диска
 93+  0000 ~            _reserv_4     DB       0              ; 8FF9h -
 94+  0000 ~            inverse       DW       0              ; 8FFAh - Инвертирование текста (0=нормальный текст, 0FFFFh=инверсный)
 95+  0000 ~            cursorY       DB      -1              ; 8FFCh - Положение курсора по вертикали в пикселях
 96+  0000 ~            cursorX       DB      -1              ; 8FFDh - Положение курсора по горизонтали в пикселях / 2
 97+  0000 ~            writeDelay    DB      28h             ; 8FFEh - Скорость при записи на ленту
 98+  0000 ~            readDelay     DB      3Ch             ; 8FFFh - Скорость при чтении с ленты
 99+  0000                  ENDS
100+  0000
101+  0000              ; Блок переменных BIOS начинается с адреса 8FDFh
102+  0000              bios_vars   BIOS_VARIABLES = 8FDFh
103+  0000
104+  0000              ;-----------------------------------------------------------------------
105+  0000              ; Стандартные точки входа ОС
106+  0000              ; Отмеченные [OLD] применять не рекомендуется
107+  0000              ; Отмеченные [MXOS2] - новые в MXOS 2
108+  0000              ;-----------------------------------------------------------------------
109+  0000
110+  0000              bios_init               = 0C000h ; Теплая перезагрузка
111+  0000
112+  0000              ; Устаревшие точки, лечше не применять
113+  0000              bios_keyScanOld         = 0C003h ; [OLD] Получить код нажатой клавиши, = bios_keyScan
114+  0000              bios_drawCursorOld      = 0C006h ; [OLD] Нарисовать/стереть курсор
115+  0000              bios_clearScreenOld     = 0C010h ; [OLD] Оистка экрана
116+  0000              bios_printCharOld       = 0C037h ; [OLD] Вывод символа на экран
117+  0000              bios_beep_Old           = 0C170h ; [OLD] Звуковой сигнал
118+  0000              bios_delay_l            = 0C18Fh ; [OLD] Задержка l циклов
119+  0000              bios_delay_b            = 0C190h ; [OLD] Задержка b циклов
120+  0000              bios_getchOld           = 0C337h ; [OLD] Ожидание ввода с клавиатуры
121+  0000              bios_tapeReadOld        = 0C377h ; [OLD] Чтение байта с магнитофона
122+  0000              bios_tapeWriteOld       = 0C3D0h ; [OLD] Запись байта на магнитофон
123+  0000              bios_cmp_hl_de          = 0C427h ; [OLD] Сравнить hl и de
124+  0000              bios_memcpy_bc_hl       = 0C42Dh ; [OLD] Скопировать блок памяти
125+  0000              bios_printStringOld     = 0C438h ; [OLD] Вывод строки на экран
126+  0000
127+  0000              ; Стандартные точки C800h
128+  0000              bios_reboot             = 0C800h ; Запустить NC.COM
129+  0000              bios_getch              = 0C803h ; Ожидание ввода с клавиатуры
130+  0000              bios_tapeRead           = 0C806h ; Чтение байта с магнитофона
131+  0000              bios_printChar          = 0C809h ; Вывод символа на экран
132+  0000              bios_tapeWrite          = 0C80Ch ; Запись байта на магнитофон
133+  0000              bios_input              = 0C80Fh ; Ввод строки с клавиатуры
134+  0000              bios_keyCheck           = 0C812h ; Получить код нажатой клавиши, = bios_keyScan
135+  0000              bios_printHexByte       = 0C815h ; Вывод HEX числа на экран (байт)
136+  0000              bios_printString        = 0C818h ; Вывод строки на экран
137+  0000              bios_keyScan            = 0C81Bh ; Получить код нажатой клавиши
138+  0000              bios_getCursorPos       = 0C81Eh ; Получить координаты курсора в hl (координаты в пикселях)
139+  0000              bios_setCursorPos       = 0C821h ; Установить координаты курсора из hl (координаты в пикселях)
140+  0000              bios_tapeLoad           = 0C824h ; Загрузить программу с магнитофона
141+  0000              bios_tapeSave           = 0C827h ; Сохранить программу на магнитофон
142+  0000              bios_calcCS             = 0C82Ah ; Расчет контрольной суммы
143+  0000              bios_printHexWord       = 0C82Dh ; Вывод HEX числа на экран (слово)
144+  0000              bios_getMemTop          = 0C830h ; Получить объем доступной памяти
145+  0000              bios_setMemTop          = 0C833h ; Установить объем доступной памяти
146+  0000              bios_printer            = 0C836h ; Напечатать байт на принтере
147+  0000                  IF RAMFOS_COMPATIBILITY
148+  0000              bios_strToHex           = 0C839h ; [MXOS2] Преобразвоние строки в HEX формате в число
149+  0000                  ELSE
150+  0000 ~            bios_rebootAlt          = 0C839h ; Запустить NC.COM
151+  0000                  ENDIF
152+  0000              bios_rebootAlt2         = 0C83Ch ; Запустить NC.COM
153+  0000              bios_fileList           = 0C83Fh ; Получить список файлов
154+  0000              bios_fileGetSetDrive    = 0C842h ; Получить/установить активное устройство
155+  0000              bios_fileCreate         = 0C845h ; Создать файл
156+  0000              bios_fileLoad           = 0C848h ; Загрузить файл по адресу из заголовка этого файла
157+  0000              bios_fileDelete         = 0C84Bh ; Удалить файл
158+  0000              bios_fileRename         = 0C84Eh ; Переименовать файл
159+  0000              bios_fileLoadInfo       = 0C851h ; Загрузить информацию о файле
160+  0000              bios_fileGetSetAddr     = 0C854h ; Получить/установить адрес загрузки файла
161+  0000              bios_fileGetSetAttr     = 0C857h ; Получить/установить атрибуты файла
162+  0000              bios_fileNamePrepare    = 0C85Ah ; Преобразовать имя файла во внутренний формат
163+  0000              bios_fileExec           = 0C85Dh ; Запустить файл
164+  0000              bios_installDriver      = 0C860h ; Установить драйвер накопителя
165+  0000              bios_diskDriver         = 0C863h ; Драйвер выбранного диска
166+  0000              bios_fileLoad2          = 0C866h ; Загрузить файл по адресу de
167+  0000
168+  0000              ; Новые точки C800h MXOS2
169+  0000              bios_printCharReal      = 0C869h ; [MXOS2] Вывод символа на экран (только реальные символы)
170+  0000              bios_printDecWord       = 0C86Ch ; [MXOS2] Вывод числа экран в десятичной форме
171+  0000              bios_setRAMDDriver      = 0C86Fh ; [MXOS2] Установить драйвр рам-диска
172+  0000              bios_getDriveFreeSpace  = 0C872h ; [MXOS2] Получить оставшийся свободный объем диска
173+  0000              bios_upperCase          = 0C875h ; [MXOS2] Перевод кода символа КОИ-8 в верхний регистр
174+  0000              bios_strcmp             = 0C878h ; [MXOS2] Сравнение строк, чувствительное к регистру
175+  0000              bios_stricmp            = 0C87Bh ; [MXOS2] Сравнение строк, нечувствительное к регистру
176+  0000              bios_sub_hl_de          = 0C87Eh ; [MXOS2] Вычитание hl и de: hl = hl - de
177+  0000              bios_div_hl_2           = 0C881h ; [MXOS2] Деление hl на 2: hl = hl / 2
178+  0000              bios_mul_hl_de          = 0C884h ; [MXOS2] Умножение hl на de: hl = hl * de
179+  0000              bios_div_hl_de          = 0C887h ; [MXOS2] Деление hl на de: hl = hl / de, de = hl % de
180+  0000
181+  0000              ;-----------------------------------------------------------------------
182+  0000              ; Адрес таблицы переходов драйвера магнитофона
183+  0000              ;-----------------------------------------------------------------------
184+  0000
185+  0000              TAPE_DRIVER_JUMPS = bios_tapeReadOld    ; размещается на месте бывшей п/п чтения байта
186+  0000
187+  0000              ;-----------------------------------------------------------------------
188+  0000              ; Непереключаемое ОЗУ ПК "Специалист-MX" (0FFC0h-0FFDF, 32 байта)
189+  0000              ;-----------------------------------------------------------------------
190+  0000
191+  0000              bios_RAMDRead   = 0FFC0h ; п/п чтения из ДОЗУ
192+  0000              bios_RAMDWrite  = 0FFD0h ; п/п записи в  ДОЗУ
193+  0000
194+  0000              ;-----------------------------------------------------------------------
195+  0000              ; Порты устройств ПК "Специалист-MX2" (0FFE0h-0FFFF, 32 байта)
196+  0000              ;-----------------------------------------------------------------------
197+  0000
198+  0000              IO_KEYB_A       =  0FFE0h   ; ВВ55 клавиатуры
199+  0000              IO_KEYB_B       =  0FFE1h
200+  0000              IO_KEYB_C       =  0FFE2h
201+  0000              IO_KEYB_MODE    =  0FFE3h
202+  0000              IO_PROG_A       =  0FFE4h   ; ВВ55 программатора/флеш диска
203+  0000              IO_PROG_B       =  0FFE5h
204+  0000              IO_PROG_C       =  0FFE6h
205+  0000              IO_PROG_MODE    =  0FFE7h
206+  0000              IO_FDD_CMD      =  0FFE8h   ; контроллер дисковода ВГ93
207+  0000              IO_FDD_TRACK    =  0FFE9h
208+  0000              IO_FDD_SECTOR   =  0FFEAh
209+  0000              IO_FDD_DATA     =  0FFEBh
210+  0000              IO_TIMER_CH0    =  0FFECh   ; таймер ВИ53
211+  0000              IO_TIMER_CH1    =  0FFEDh
212+  0000              IO_TIMER_CH2    =  0FFEEh
213+  0000              IO_TIMER_MODE   =  0FFEFh
214+  0000              IO_FDD_REQ      =  0FFF0h   ; контроллер дисковода
215+  0000              IO_FDD_MOTOR    =  0FFF1h
216+  0000              IO_FDD_SIDE     =  0FFF2h
217+  0000              IO_FDD_DRIVE    =  0FFF3h
218+  0000              IO_COLOR        =  0FFF8h   ; регистр цвета
219+  0000              IO_PAGE_RAM     =  0FFFCh   ; порт включения основного ОЗУ
220+  0000              IO_PAGE_RAMD    =  0FFFDh   ; порт включения ОЗУ RAM-дисков
221+  0000              IO_PAGE_ROM     =  0FFFEh   ; порт включения ПЗУ
222+  0000              IO_PAGE_STD     =  0FFFFh   ; порт включения STD режима
223+  0000
224+  0000              ;-----------------------------------------------------------------------
225+  0000              ; Структура файловой системы
226+  0000              ;-----------------------------------------------------------------------
227+  0000
228+  0000              ; Структура каталога
229+  0000              FILE_DESCR_SIZE  = 32   ; размер дескриптора файла в каталоге (байт)
230+  0000              FILE_NAME_LENGTH = 8    ; длина имени файла  (байт)
231+  0000              FAT_ITEM_SIZE    = 2    ; размер записи в таблице FAT (байт)
232+  0000
233+  0000              SECTOR_SIZE  = 00100h   ; размер сектора 256 байт
234+  0000              CLUSTER_SIZE = 00100h   ; размер кластера 256 байт
235+  0000
236+  0000              ; Специальные коды кластеров FAT
237+  0000              FAT12_BAD = 00FF7h  ; плохой кластер
238+  0000              FAT16_BAD = 0FFF7h
239+  0000              FAT12_EOC = 00FFFh  ; последний кластер файла
240+  0000              FAT16_EOC = 0FFFFh
241+  0000              FAT12_RES = 00FFFh  ; зарезервированный кластер
242+  0000              FAT16_RES = 0FFFFh
243+  0000
244+  0000              ;-----------------------------------------------------------------------
245+  0000              ; Десткриптор файла (одна запись в каталоге) FAT12/16/32
246+  0000              ;-----------------------------------------------------------------------
247+  0000
248+  0000                  STRUCT FILE_DESCRIPTOR  ; 32 байта
249+  0000 ~            name            BLOCK   FILE_NAME_LENGTH    ; смещение 00h, 8 байт  - имя файла
250+  0000 ~            ext             BLOCK   3                   ; смещение 08h, 3 байта - расширение имени файла
251+  0000 ~            attrib          BLOCK   1                   ; смещение 0Bh, 1 байт  - атрибуты файла
252+  0000 ~            ntReserved      BLOCK   1                   ; смещение 0Ch, 1 байт  - используются в Windows NT
253+  0000 ~            createTimeTenth BLOCK   1                   ; смещение 0Dh, 1 байт  - (только FAT32) время создания файла, десятки миллисекунд (0-199)
254+  0000 ~            createTime      BLOCK   2                   ; смещение 0Eh, 2 байта - (только FAT32) время создания файла, секунды*2 (0-43200)
255+  0000 ~            createDate      BLOCK   2                   ; смещение 10h, 2 байта - (только FAT32) дата  создания файла
256+  0000 ~            loadAddress     BLOCK   2  ; accDate        ; смещение 12h, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый (!!! временный костыль, в FAT32 это accDate - дата доступа к файлу !!!)
257+  0000 ~            firstClusterHi  BLOCK   2                   ; смещение 14h, 2 байта - номер первого кластера в FAT, старшее слово
258+  0000 ~            writeTime       BLOCK   2                   ; смещение 16h, 2 байта - время модификации файла, секунды*2 (0-43200)
259+  0000 ~            writeDate       BLOCK   2                   ; смещение 18h, 2 байта - дата  модификации файла
260+  0000 ~            firstCluster    BLOCK   2                   ; смещение 1Ah, 2 байта - номер первого кластера в FAT, младшее слово
261+  0000 ~            size            BLOCK   4                   ; смещение 1Ch, 4 байта - размер файла в байтах
262+  0000                  ENDS
263+  0000
264+  0000              ;-----------------------------------------------------------------------
265+  0000              ; Информация о файле (компактный вариант дескриптора)
266+  0000              ; Почти совместимо с дескриптором оригинального Коммандера
267+  0000              ;-----------------------------------------------------------------------
268+  0000
269+  0000              FILE_INFO_SIZE = 16     ; размер структуры (байт)
270+  0000
271+  0000                  STRUCT FILE_INFO    ; 16 байт
272+  0000 ~            name            BLOCK   FILE_NAME_LENGTH    ; смещение 00h, 8 байт  - имя файла
273+  0000 ~            ext             BLOCK   3                   ; смещение 08h, 3 байта - расширение имени файла
274+  0000 ~            attrib          BLOCK   1                   ; смещение 0Bh, 1 байт  - атрибуты файла
275+  0000 ~            loadAddress     BLOCK   2                   ; смещение 0Eh, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый
276+  0000 ~            size            BLOCK   2                   ; смещение 0Ch, 2 байта - размер файла в байтах
277+  0000                  ENDS
278+  0000
279+  0000              ;-----------------------------------------------------------------------
280+  0000              ; Информация о активном накопителе (диске)
281+  0000              ;-----------------------------------------------------------------------
282+  0000
283+  0000                  STRUCT DISK_INFO
284+  0000 ~            sectorSize          BLOCK   2   ; размер сектора, байт (256, 512, 1024)
285+  0000 ~            sectorsPerCluster   BLOCK   2   ; размер кластера, секторов (1, 2, 4, 8)
286+  0000 ~            resSectors          BLOCK   2   ; сколько секторов занимает зарезервированная область = первый сектор таблицы fat
287+  0000 ~            fatSectors          BLOCK   2   ; сколько секторов занимает таблица fat
288+  0000 ~            dirSectors          BLOCK   2   ; сколько секторов занимает корневой каталог
289+  0000 ~            totalSectors        BLOCK   2   ; сколько всего секторов на диске
290+  0000 ~            rootDirMaxFiles     BLOCK   2   ; максимум файлов в корневом каталоге
291+  0000 ~            descrPerSector      BLOCK   2   ; сколько дескрипторов файлов вмещается в один сектор
292+  0000 ~            fatNumCells         BLOCK   2   ; количество ячеек в таблице fat (= fatSectors * sectorSize / 2)
293+  0000 ~            dirStartSector      BLOCK   2   ; первый сектор корневого каталога
294+  0000 ~            dataStartSector     BLOCK   2   ; первый сектор области данных
295+  0000 ~            volumeLabel         BLOCK  12   ; метка тома и 0 в конце
296+  0000 ~            isValid             BLOCK   1   ; 0 = нет драйвера, 1 = диск не распознан, 2 = диск распознан, корректно отформатирован
297+  0000                  ENDS
298+  0000
299+  0000              DISK_NO_DRIVER = 0
300+  0000              DISK_INVALID   = 1
301+  0000              DISK_VALID     = 2
302+  0000
303+  0000              ;-----------------------------------------------------------------------
304+  0000              ; Буферы в памяти
305+  0000              ;-----------------------------------------------------------------------
306+  0000
307+  0000              ; Дисковый кэш
308+  0000              FAT_CACHE_ADDR = 0FB00h ; адрес кэша секторов fat в памяти
309+  0000              FAT_CACHE_SIZE = 1024   ; размер кэша в байтах
310+  0000              FAT_CACHE_CAPACITY = FAT_CACHE_SIZE / SECTOR_SIZE   ; сколько секторов вмещается в кэш
311+  0000
312+  0000              ; Буфер для загрузки BAT файла
313+  0000                  IF NEW_MEMORY_MAP
314+  0000              BAT_BUFFER = 0E800h
315+  0000                  ELSE
316+  0000 ~            BAT_BUFFER = 0FC00h
317+  0000                  ENDIF
318+  0000
319+  0000              ; Командная строка и стек
320+  0000              CMD_LINE   = 0FF00h  ; 192 байта, но в конце стек
321+  0000              STACK_ADDR = 0FFC0h  ; стек
322+  0000
323+  0000              ;-----------------------------------------------------------------------
324+  0000              ; Всякие полезности
325+  0000              ;-----------------------------------------------------------------------
326+  0000
327+  0000              ; Макрос для заполнения памяти от текущего адреса до указанного
328+  0000                  MACRO ORG_PAD adr
329+  0000 ~                     IF $ > adr
330+  0000 ~                       ; вывод сообщения об ошибке
331+  0000 ~                       ASSERT 0
332+  0000 ~                       DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
333+  0000 ~                     ELSE
334+  0000 ~                       ; заполнение памяти
335+  0000 ~                       BLOCK adr-$, 0FFh
336+  0000 ~                     ENDIF
337+  0000 ~                     ORG adr
338+  0000                  ENDM
339+  0000
340+  0000                  MACRO ORG_PAD0 adr
341+  0000 ~                     IF $ > adr
342+  0000 ~                       ; вывод сообщения об ошибке
343+  0000 ~                       ASSERT 0
344+  0000 ~                       DISPLAY /l, "Error! ORG_PAD0 failed! ", $, " is more than ", adr
345+  0000 ~                     ELSE
346+  0000 ~                       ; заполнение памяти
347+  0000 ~                       BLOCK adr-$, 0
348+  0000 ~                     ENDIF
349+  0000 ~                     ORG adr
350+  0000                  ENDM
351+  0000
352+  0000              ; Макросы для проверки текущего адреса
353+  0000                  MACRO ASSERT_EQUAL adr
354+  0000 ~                     IF $ != adr
355+  0000 ~                       ASSERT 0
356+  0000 ~                       DISPLAY /l, "Error! Entry point has been shifted (", $, " != ", adr, ")"
357+  0000 ~                     ENDIF
358+  0000                  ENDM
359+  0000
360+  0000                  MACRO ASSERT_DONT_FIT adr
361+  0000 ~                     IF $ > adr
362+  0000 ~                       ASSERT 0
363+  0000 ~                       DISPLAY /l, "Error! Image did not fit (", $, " > ", adr, ")"
364+  0000 ~                     ENDIF
365+  0000                  ENDM
366+  0000
367+  0000              ;-----------------------------------------------------------------------
368+  0000              ; Конец
369+  0000              ;-----------------------------------------------------------------------
370+  0000
  9   0000
 10   0000              ; -----------------------------------------------------------------------
 11   0000              ; Код
 12   0000              ; Стандартные подпрограммы должны иметь фиксированный адрес для
 13   0000              ; совместимости. Они начинаются с ORG_PAD xxxx. В случае, если
 14   0000              ; предыдущая продпрограмма залезает на эту, транслятор выдаст ошибку.
 15   0000              ; -----------------------------------------------------------------------
 16   0000
 17   0000              	ORG     0C000h
 18   C000              	INCLUDE "jmps_c000.inc"
  1+  C000              ;+---------------------------------------------------------------------------
  2+  C000              ; MXOS
  3+  C000              ; Стандартные точки входа C000
  4+  C000              ;
  5+  C000              ; 2013-12-12 Дизассемблировано vinxru
  6+  C000              ;----------------------------------------------------------------------------
  7+  C000
  8+  C000 C3 09 C0                 jp    reboot        ; C000: Теплая перезагрузка
  9+  C003 C3 BA C1     j_keyScan:  jp    keyScan2      ; C003: Получить код нажатой клавиши
 10+  C006 C3 4E C3                 jp    drawCursor3   ; C006: Нарисовать/стереть курсор
 11+  C009 31 C0 FF     reboot:     ld    sp, STACK_ADDR; C009: Теплая перезагрузка
 12+  C00C C3 34 C5                 jp    reboot1
 13+  C00F
 19   C00F
 20   C00F                  ORG_PAD 0C010h
 20   C00F             >         IF $ > 0C010h
 20   C00F ~           >           ; вывод сообщения об ошибке
 20   C00F ~           >           ASSERT 0
 20   C00F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 20   C00F             >         ELSE
 20   C00F             >           ; заполнение памяти
 20   C00F FF          >           BLOCK 0C010h-$, 0FFh
 20   C010             >         ENDIF
 20   C010             >         ORG 0C010h
 21   C010              	INCLUDE "clearScreen.inc"
  1+  C010              ;+---------------------------------------------------------------------------
  2+  C010              ; MXOS
  3+  C010              ; Очистить экран
  4+  C010              ;
  5+  C010              ; На выходе
  6+  C010              ;  bc, de, hl - сохраняются
  7+  C010              ;
  8+  C010              ; 2013-12-12 Дизассемблировано vinxru
  9+  C010              ;----------------------------------------------------------------------------
 10+  C010
 11+  C010              clearScreen:
 12+  C010                          ; bc, hl - сохраняем. de - не используется
 13+  C010 E5                       push  hl
 14+  C011 C5                       push  bc
 15+  C012
 16+  C012                          ; Сохранение sp
 17+  C012 21 00 00                 ld    hl, 0
 18+  C015 39                       add   hl,sp
 19+  C016 22 F6 8F                 ld    (bios_vars.oldSP), hl
 20+  C019
 21+  C019                          ; Устанавливаем sp в конец видеопамяти
 22+  C019 31 00 C0                 ld    sp, 0C000h
 23+  C01C
 24+  C01C                          ; Байт (слово) для заполнения памяти
 25+  C01C 2A FA 8F                 ld    hl, (bios_vars.inverse)
 26+  C01F
 27+  C01F                          ; Помещаем в стек 3000h байт
 28+  C01F 01 00 03                 ld    bc, 3000h / 16
 29+  C022              clearScreen_0:
 30+  C022 E5                       push      hl
 31+  C023 E5                       push      hl
 32+  C024 E5                       push      hl
 33+  C025 E5                       push      hl
 34+  C026 E5                       push      hl
 35+  C027 E5                       push      hl
 36+  C028 E5                       push      hl
 37+  C029 E5                       push      hl
 38+  C02A 0B                       dec bc
 39+  C02B 78                       ld  a, b
 40+  C02C B1                       or  c
 41+  C02D C2 22 C0                 jp nz,  clearScreen_0
 42+  C030
 43+  C030                          ; Восстанавливаем sp
 44+  C030 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 45+  C033 F9                       ld    sp, hl
 46+  C034
 47+  C034                          ; bc, hl были сохранены. de - не используется
 48+  C034 C1                       pop   bc
 49+  C035 E1                       pop   hl
 50+  C036 C9                       ret
 51+  C037
 22   C037
 23   C037                  ORG_PAD 0C037h
 23   C037             >         IF $ > 0C037h
 23   C037 ~           >           ; вывод сообщения об ошибке
 23   C037 ~           >           ASSERT 0
 23   C037 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 23   C037             >         ELSE
 23   C037             >           ; заполнение памяти
 23   C037             >           BLOCK 0C037h-$, 0FFh
 23   C037             >         ENDIF
 23   C037             >         ORG 0C037h
 24   C037              	INCLUDE "printChar.inc"
  1+  C037              ;+---------------------------------------------------------------------------
  2+  C037              ; MXOS
  3+  C037              ; Вывод символа на экран (или принтер)
  4+  C037              ;
  5+  C037              ; На входе
  6+  C037              ;  с - символ
  7+  C037              ;
  8+  C037              ; На выходе
  9+  C037              ;  Все регистры сохраняются
 10+  C037              ;
 11+  C037              ; 2013-12-12 Дизассемблировано vinxru
 12+  C037              ;----------------------------------------------------------------------------
 13+  C037
 14+  C037 F5           printChar:  push  af
 15+  C038 D5                       push  de
 16+  C039 C5                       push  bc
 17+  C03A E5                       push  hl
 18+  C03B CD E4 C5                 call  printChar2
 19+  C03E E1                       pop   hl
 20+  C03F C1                       pop   bc
 21+  C040 D1                       pop   de
 22+  C041 F1                       pop   af
 23+  C042 C9                       ret
 24+  C043
 25   C043
 26   C043                  ORG_PAD 0C045h
 26   C043             >         IF $ > 0C045h
 26   C043 ~           >           ; вывод сообщения об ошибке
 26   C043 ~           >           ASSERT 0
 26   C043 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 26   C043             >         ELSE
 26   C043             >           ; заполнение памяти
 26   C043 FF FF       >           BLOCK 0C045h-$, 0FFh
 26   C045             >         ENDIF
 26   C045             >         ORG 0C045h
 27   C045              	INCLUDE "printChar5.inc" ; Продолжается в drawChar
  1+  C045              ;+---------------------------------------------------------------------------
  2+  C045              ; MXOS
  3+  C045              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C045              ; Расчет адреса символа в знакогенераторе и адреса вывода на экран
  5+  C045              ;
  6+  C045              ; 2013-12-12 Дизассемблировано vinxru
  7+  C045              ;----------------------------------------------------------------------------
  8+  C045
  9+  C045              ; ---------------------------------------------------------------------------
 10+  C045              ; Обработка ESC+(. Включение KOI-7
 11+  C045
 12+  C045              printChar_e28:
 13+  C045 3E FF                    ld    a, 0FFh
 14+  C047 32 EA 8F                 ld    (bios_vars.koi7), a
 15+  C04A C9                       ret
 16+  C04B
 17+  C04B              ; ---------------------------------------------------------------------------
 18+  C04B              ; Обработка ESC+). Включение KOI-8
 19+  C04B
 20+  C04B              printChar_e29:
 21+  C04B AF                       xor   a
 22+  C04C 32 EA 8F                 ld    (bios_vars.koi7), a
 23+  C04F C9                       ret
 24+  C050
 25+  C050              ; ---------------------------------------------------------------------------
 26+  C050              ; Обработка кода 9. Табуляция
 27+  C050
 28+  C050              printChar_c9:
 29+  C050 3A FD 8F                 ld    a, (bios_vars.cursorX)
 30+  C053 C6 0C                    add   a, 12 ; 24
 31+  C055 32 FD 8F                 ld    (bios_vars.cursorX),a
 32+  C058 C9                       ret
 33+  C059
 34+  C059              ; ---------------------------------------------------------------------------
 35+  C059              ; Вывод символа С из знакогенартора по адресу hl*8 на экран в положение
 36+  C059              ; курсора. Курсор при этом перемещается
 37+  C059
 38+  C059              printChar_alt:
 39+  C059                          ; de = (hl+c) * 8
 40+  C059 06 00                    ld    b, 0
 41+  C05B 09                       add   hl, bc
 42+  C05C 29                       add   hl, hl
 43+  C05D 29                       add   hl, hl
 44+  C05E 29                       add   hl, hl
 45+  C05F EB                       ex    de, hl
 46+  C060
 47+  C060                          ; Продолжение в printChar_de
 48+  C060
 49+  C060              ; ---------------------------------------------------------------------------
 50+  C060              ; Вывод символа de на экран в положение курсора. Курсор при этом перемещается
 51+  C060              ; вправо.
 52+  C060
 53+  C060              printChar_de:
 54+  C060                          ; Рассчитываем адрес вывода (hl=v_cursorPos, a*256+l=адрес)
 55+  C060 CD 14 C3                 call  calcCursorAddr
 56+  C063
 57+  C063                          ; Перемещаем курсор вправо
 58+  C063 24                       inc   h
 59+  C064 24                       inc   h
 60+  C065 24                       inc   h
 61+  C066 22 FC 8F                 ld    (bios_vars.cursorY), hl
 62+  C069
 63+  C069                          ; Корректируем адрес вывода (bc = al - 7)
 64+  C069 47                       ld    b, a
 65+  C06A 7D                       ld    a, l
 66+  C06B D6 07                    sub   7
 67+  C06D 4F                       ld    c, a
 68+  C06E
 69+  C06E                          ; Продолжение в drawChar
 70+  C06E
 28   C06E              	INCLUDE "drawChar.inc"
  1+  C06E              ;+---------------------------------------------------------------------------
  2+  C06E              ; MXOS
  3+  C06E              ; Рисование символа на экране
  4+  C06E              ;
  5+  C06E              ; На входе
  6+  C06E              ;  bc - адрес символа
  7+  C06E              ;  de - адрес в видеопамяти
  8+  C06E              ;  h  - координата X в пикселях / 2
  9+  C06E              ;
 10+  C06E              ; 2013-12-12 Дизассемблировано vinxru
 11+  C06E              ;----------------------------------------------------------------------------
 12+  C06E
 13+  C06E                          ; Высота символа
 14+  C06E 2E 08                    ld    l, 8
 15+  C070
 16+  C070                          ; Переходим к одной из функций вывода
 17+  C070 7C                       ld    a, h
 18+  C071 E6 03                    and   3
 19+  C073 CA B5 C0                 jp z, drawChar0   ; a==0
 20+  C076 3D                       dec   a
 21+  C077 CA C5 C0                 jp z, drawChar1   ; a==1
 22+  C07A 3D                       dec   a
 23+  C07B CA 82 C0                 jp z, drawChar2   ; a==2
 24+  C07E 3D                       dec   a
 25+  C07F CA A3 C0                 jp z, drawChar3   ; a==3
 26+  C082                          ; Продолжение на drawChar2
 27+  C082
 28+  C082              ; ---------------------------------------------------------------------------
 29+  C082
 30+  C082 0A           drawChar2:  ld    a, (bc)
 31+  C083 E6 FC                    and   0FCh
 32+  C085 67                       ld    h, a
 33+  C086 1A                       ld    a, (de)
 34+  C087 0F                       rrca
 35+  C088 0F                       rrca
 36+  C089 0F                       rrca
 37+  C08A 0F                       rrca
 38+  C08B              drawChar2_cma:
 39+  C08B 2F                       cpl
 40+  C08C F5                       push  af
 41+  C08D E6 03                    and   3
 42+  C08F AC                       xor   h
 43+  C090 02                       ld    (bc), a
 44+  C091 04                       inc   b
 45+  C092 0A                       ld    a, (bc)
 46+  C093 E6 0F                    and   0Fh
 47+  C095 67                       ld    h, a
 48+  C096 F1                       pop   af
 49+  C097 E6 F0                    and   0F0h
 50+  C099 AC                       xor   h
 51+  C09A 02                       ld    (bc),a
 52+  C09B 05                       dec   b
 53+  C09C
 54+  C09C                          ; Цикл
 55+  C09C 03                       inc   bc
 56+  C09D 13                       inc   de
 57+  C09E 2D                       dec   l
 58+  C09F C2 82 C0                 jp nz,  drawChar2
 59+  C0A2 C9                       ret
 60+  C0A3
 61+  C0A3              ; ---------------------------------------------------------------------------
 62+  C0A3
 63+  C0A3 0A           drawChar3:  ld    a, (bc)
 64+  C0A4 E6 03                    and   3
 65+  C0A6 67                       ld    h, a
 66+  C0A7 1A                       ld    a, (de)
 67+  C0A8 07                       rlca
 68+  C0A9 07                       rlca
 69+  C0AA              drawChar3_xri:
 70+  C0AA EE FC                    xor   0FCh
 71+  C0AC AC                       xor   h
 72+  C0AD 02                       ld    (bc),a
 73+  C0AE
 74+  C0AE                          ; Цикл
 75+  C0AE 13                       inc   de
 76+  C0AF 03                       inc   bc
 77+  C0B0 2D                       dec   l
 78+  C0B1 C2 A3 C0                 jp nz,  drawChar3
 79+  C0B4 C9                       ret
 80+  C0B5
 81+  C0B5              ; ---------------------------------------------------------------------------
 82+  C0B5
 83+  C0B5 0A           drawChar0:  ld    a, (bc)
 84+  C0B6 E6 C0                    and   0C0h
 85+  C0B8 67                       ld    h, a
 86+  C0B9 1A                       ld    a, (de)
 87+  C0BA              drawChar0_xri:
 88+  C0BA EE 3F                    xor   3Fh
 89+  C0BC AC                       xor   h
 90+  C0BD 02                       ld    (bc),a
 91+  C0BE
 92+  C0BE                          ; Цикл
 93+  C0BE 13                       inc   de
 94+  C0BF 03                       inc   bc
 95+  C0C0 2D                       dec   l
 96+  C0C1 C2 B5 C0                 jp nz,  drawChar0
 97+  C0C4 C9                       ret
 98+  C0C5
 99+  C0C5              ; ---------------------------------------------------------------------------
100+  C0C5
101+  C0C5 0A           drawChar1:  ld    a, (bc)
102+  C0C6 E6 F0                    and   0F0h
103+  C0C8 67                       ld    h, a
104+  C0C9 1A                       ld    a, (de)
105+  C0CA 0F                       rrca
106+  C0CB 0F                       rrca
107+  C0CC              drawChar1_cma:
108+  C0CC 2F                       cpl
109+  C0CD E6 0F                    and   0Fh
110+  C0CF AC                       xor   h
111+  C0D0 02                       ld    (bc),a
112+  C0D1 04                       inc   b
113+  C0D2 0A                       ld    a, (bc)
114+  C0D3 E6 3F                    and   3Fh
115+  C0D5 67                       ld    h, a
116+  C0D6 1A                       ld    a, (de)
117+  C0D7 0F                       rrca
118+  C0D8 0F                       rrca
119+  C0D9              drawChar1_cma2:
120+  C0D9 2F                       cpl
121+  C0DA E6 C0                    and   0C0h
122+  C0DC AC                       xor   h
123+  C0DD 02                       ld    (bc),a
124+  C0DE 05                       dec   b
125+  C0DF
126+  C0DF                          ; Цикл
127+  C0DF 03                       inc   bc
128+  C0E0 13                       inc   de
129+  C0E1 2D                       dec   l
130+  C0E2 C2 C5 C0                 jp nz,  drawChar1
131+  C0E5 C9                       ret
132+  C0E6
133+  C0E6              ; ---------------------------------------------------------------------------
134+  C0E6              ; Вызывается из printChar_real2
135+  C0E6
136+  C0E6              normalVideo:
137+  C0E6                          ; Меняем CZ normalVideo на CNZ inverseVideo
138+  C0E6 21 02 C1                 ld    hl, inverseVideo
139+  C0E9 22 21 C6                 ld    (printChar_poly+1), hl
140+  C0EC 3E C4                    ld    a, 0C4h
141+  C0EE 32 20 C6                 ld    (printChar_poly),a
142+  C0F1
143+  C0F1                          ; Аргумент XRI
144+  C0F1 AF                       xor   a
145+  C0F2 32 BB C0                 ld    (drawChar0_xri+1),a
146+  C0F5 32 AB C0                 ld    (drawChar3_xri+1),a
147+  C0F8              normalVideo_1:
148+  C0F8                          ; Меняем CMA на NOP
149+  C0F8 32 8B C0                 ld    (drawChar2_cma),a
150+  C0FB 32 CC C0                 ld    (drawChar1_cma),a
151+  C0FE 32 D9 C0                 ld    (drawChar1_cma2),a
152+  C101 C9                       ret
153+  C102
154+  C102              ; ---------------------------------------------------------------------------
155+  C102              ; Вызывается из printChar_real2
156+  C102
157+  C102              inverseVideo:
158+  C102                          ; Меняем CNZ inverseVideo на CZ normalVideo
159+  C102 21 E6 C0                 ld    hl, normalVideo
160+  C105 22 21 C6                 ld    (printChar_poly+1), hl
161+  C108 3E CC                    ld    a, 0CCh
162+  C10A 32 20 C6                 ld    (printChar_poly),a
163+  C10D
164+  C10D                          ; Меняем аргумент XRI
165+  C10D 3E FC                    ld    a, 0FCh
166+  C10F 32 AB C0                 ld    (drawChar3_xri+1),a
167+  C112 3E 3F                    ld    a, 3Fh
168+  C114 32 BB C0                 ld    (drawChar0_xri+1),a
169+  C117
170+  C117                          ; Меняем NOP на CMA
171+  C117 3E 2F                    ld    a, 2Fh
172+  C119 C3 F8 C0                 jp    normalVideo_1
173+  C11C
 29   C11C              	INCLUDE "printChar3.inc"
  1+  C11C              ;+---------------------------------------------------------------------------
  2+  C11C              ; MXOS
  3+  C11C              ; Обработка служебных кодов при выводе символа
  4+  C11C              ;
  5+  C11C              ; На входе
  6+  C11C              ;  a - символ
  7+  C11C              ;
  8+  C11C              ; 2013-12-12 Дизассемблировано vinxru
  9+  C11C              ;----------------------------------------------------------------------------
 10+  C11C
 11+  C11C              printChar3: ; Код 7
 12+  C11C D6 07                    sub   7
 13+  C11E CA 70 C1                 jp z, beep
 14+  C121                          ; Код 8
 15+  C121 3D                       dec   a
 16+  C122 CA 4E C1                 jp z, printChar_c08
 17+  C125                          ; Код 10
 18+  C125 D6 02                    sub   2
 19+  C127 CA 96 C1                 jp z, printChar_c0A
 20+  C12A                          ; Код 12
 21+  C12A D6 02                    sub   2
 22+  C12C CA 46 C1                 jp z, printChar_c0C
 23+  C12F                          ; Код 13
 24+  C12F 3D                       dec   a
 25+  C130 CA 48 C1                 jp z, printChar_c0D
 26+  C133                          ; Код 24
 27+  C133 D6 0B                    sub   11
 28+  C135 CA 64 C1                 jp z, printChar_c18
 29+  C138                          ; Код 25
 30+  C138 3D                       dec   a
 31+  C139 CA 59 C1                 jp z, printChar_c19
 32+  C13C                          ; Код 26
 33+  C13C 3D                       dec   a
 34+  C13D CA 98 C1                 jp z, printChar_c1A
 35+  C140                          ; Продолжение, если код 1Fh (31)
 36+  C140 D6 05                    sub   5
 37+  C142 C0                       ret nz
 38+  C143                          ; Код  1Fh (31) очищает экран
 39+  C143 CD 10 C0                 call  clearScreen
 40+  C146
 41+  C146                          ; Продолжение в printChar_c0C
 42+  C146
 43+  C146              ; ---------------------------------------------------------------------------
 44+  C146              ; Обработка кода 0Ch. Курсор в левый верхний угол экрана
 45+  C146
 46+  C146              printChar_c0C:
 47+  C146                          ; bios_vars.cursorY = 8
 48+  C146 2E 08                    ld    l, 8
 49+  C148
 50+  C148                          ; Продолжение в printChar_c0D
 51+  C148
 52+  C148              ; ---------------------------------------------------------------------------
 53+  C148              ; Обработка кода 0Dh. Курсор в начало строки
 54+  C148
 55+  C148              printChar_c0D:
 56+  C148                          ; bios_vars.cursorX = 0
 57+  C148 AF                       xor   a
 58+  C149              saveVCursorHA:
 59+  C149 67                       ld    h, a
 60+  C14A              saveVCursor:
 61+  C14A 22 FC 8F                 ld    (bios_vars.cursorY), hl
 62+  C14D C9                       ret
 63+  C14E
 64+  C14E              ; ---------------------------------------------------------------------------
 65+  C14E              ; Обработка кода 8h. Влево
 66+  C14E
 67+  C14E              printChar_c08:    ; cursorX -= 3
 68+  C14E 7C                       ld    a, h
 69+  C14F D6 03                    sub   3
 70+  C151
 71+  C151                          ; Если нет переноса, сохранить положение курсора и выйти
 72+  C151 D2 49 C1                 jp nc,  saveVCursorHA
 73+  C154
 74+  C154                          ; cursorX = 189
 75+  C154 26 BD                    ld    h, 189
 76+  C156 22 FC 8F                 ld    (bios_vars.cursorY), hl
 77+  C159
 78+  C159                          ; Продолжение в printChar_c19
 79+  C159
 80+  C159              ; ---------------------------------------------------------------------------
 81+  C159              ; Обработка кода 19h. Вверх
 82+  C159
 83+  C159              printChar_c19:    ; Если cursorY < 18, то выйти. Иначе cursorY -= 10
 84+  C159 7D                       ld    a, l
 85+  C15A D6 0A                    sub   0Ah
 86+  C15C D8                       ret c
 87+  C15D FE 08                    cp    8
 88+  C15F D8                       ret c
 89+  C160
 90+  C160              saveVCursorLA:    ; Сохранить положение курсора и выйти
 91+  C160 6F                       ld    l, a
 92+  C161 C3 4A C1                 jp    saveVCursor
 93+  C164
 94+  C164              ; ---------------------------------------------------------------------------
 95+  C164              ; Обработка кода 18h. Вправо
 96+  C164
 97+  C164              printChar_c18:    ; Если cursorX+3 >= 192, то перейти на printChar_c0A
 98+  C164                          ; Иначе cursorX += 3
 99+  C164 7C                       ld    a, h
100+  C165 C6 03                    add   a,3
101+  C167 FE C0                    cp    0C0h
102+  C169 DA 49 C1                 jp c, saveVCursorHA
103+  C16C C3 96 C1                 jp    printChar_c0A
104+  C16F
 30   C16F
 31   C16F                  ORG_PAD 0C170h
 31   C16F             >         IF $ > 0C170h
 31   C16F ~           >           ; вывод сообщения об ошибке
 31   C16F ~           >           ASSERT 0
 31   C16F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 31   C16F             >         ELSE
 31   C16F             >           ; заполнение памяти
 31   C16F FF          >           BLOCK 0C170h-$, 0FFh
 31   C170             >         ENDIF
 31   C170             >         ORG 0C170h
 32   C170              	INCLUDE "beep.inc"
  1+  C170              ;+---------------------------------------------------------------------------
  2+  C170              ; MXOS
  3+  C170              ; Звуковой сигнал (вызывается при выводе кода 7)
  4+  C170              ;
  5+  C170              ; Все регистры сохраняются
  6+  C170              ;
  7+  C170              ; 2013-12-12 Дизассемблировано vinxru
  8+  C170              ;----------------------------------------------------------------------------
  9+  C170
 10+  C170              beep:       ; Сохраняем все регистры. de не используется ниже
 11+  C170 F5                       push  af
 12+  C171 C5                       push  bc
 13+  C172 E5                       push  hl
 14+  C173
 15+  C173                          ; Частота и длительность сигнала
 16+  C173 2A F1 8F                 ld    hl, (bios_vars.beepFreq)
 17+  C176
 18+  C176              beep_0:     ; Единицу на динамик
 19+  C176 3E 0B                    ld    a, 0Bh
 20+  C178 32 E3 FF                 ld    (IO_KEYB_MODE),a
 21+  C17B
 22+  C17B                          ; Задержка l тактов
 23+  C17B CD 8F C1                 call  delay_l
 24+  C17E
 25+  C17E                          ; Ноль на динамик
 26+  C17E 3E 0A                    ld    a, 0Ah
 27+  C180 32 E3 FF                 ld    (IO_KEYB_MODE),a
 28+  C183
 29+  C183                          ; Задержка l тактов
 30+  C183 CD 8F C1                 call  delay_l
 31+  C186
 32+  C186                          ; Повторяем h раз
 33+  C186 25                       dec   h
 34+  C187 C2 76 C1                 jp nz,  beep_0
 35+  C18A
 36+  C18A                          ; Ничего не делаем
 37+  C18A 00                       nop
 38+  C18B
 39+  C18B                          ; Восстаналиваем все регистры и выходим. de не используется
 40+  C18B E1                       pop   hl
 41+  C18C C1                       pop   bc
 42+  C18D F1                       pop   af
 43+  C18E C9                       ret
 44+  C18F
 33   C18F
 34   C18F                  ORG_PAD 0C18Fh
 34   C18F             >         IF $ > 0C18Fh
 34   C18F ~           >           ; вывод сообщения об ошибке
 34   C18F ~           >           ASSERT 0
 34   C18F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 34   C18F             >         ELSE
 34   C18F             >           ; заполнение памяти
 34   C18F             >           BLOCK 0C18Fh-$, 0FFh
 34   C18F             >         ENDIF
 34   C18F             >         ORG 0C18Fh
 35   C18F              	INCLUDE "delay_l.inc"
  1+  C18F              ;+---------------------------------------------------------------------------
  2+  C18F              ; MXOS
  3+  C18F              ; Задержка
  4+  C18F              ;
  5+  C18F              ; На входе
  6+  C18F              ;  l - задержка
  7+  C18F              ;
  8+  C18F              ; На выходе
  9+  C18F              ;  b - 0
 10+  C18F              ;
 11+  C18F              ; 2013-12-12 Дизассемблировано vinxru
 12+  C18F              ;----------------------------------------------------------------------------
 13+  C18F
 14+  C18F 45           delay_l:    ld      b, l
 15+  C190 05           delay_b:    dec     b       ; адрес этой инструкци должен быть 0C190h
 16+  C191 C2 90 C1                 jp nz,  delay_b
 17+  C194 C9                       ret
 18+  C195
 36   C195
 37   C195                  ORG_PAD 0C196h
 37   C195             >         IF $ > 0C196h
 37   C195 ~           >           ; вывод сообщения об ошибке
 37   C195 ~           >           ASSERT 0
 37   C195 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 37   C195             >         ELSE
 37   C195             >           ; заполнение памяти
 37   C195 FF          >           BLOCK 0C196h-$, 0FFh
 37   C196             >         ENDIF
 37   C196             >         ORG 0C196h
 38   C196              	INCLUDE "printChar4.inc" ; Продолжается в scrollUp
  1+  C196              ;+---------------------------------------------------------------------------
  2+  C196              ; MXOS
  3+  C196              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C196              ;
  5+  C196              ; 2013-12-12 Дизассемблировано vinxru
  6+  C196              ;----------------------------------------------------------------------------
  7+  C196
  8+  C196              ; ---------------------------------------------------------------------------
  9+  C196              ; Обработка кода 0Ah. Перевод строки
 10+  C196
 11+  C196              printChar_c0A:    ; cursorX = 0
 12+  C196 26 00                    ld    h, 0
 13+  C198
 14+  C198                          ; Продолжение в printChar_c1A
 15+  C198
 16+  C198              ; ---------------------------------------------------------------------------
 17+  C198              ; Обработка кода 1Ah. Вниз
 18+  C198
 19+  C198              printChar_c1A:    ; Если cursorY < 246, то cursorY += 10 и выход
 20+  C198 7D                       ld    a, l
 21+  C199 C6 0A                    add   a,10
 22+  C19B D2 60 C1                 jp nc,  saveVCursorLA
 23+  C19E
 24+  C19E                          ; Сохраняем положение курсора (изменен только cursorX)
 25+  C19E 22 FC 8F                 ld    (bios_vars.cursorY), hl
 26+  C1A1
 27+  C1A1                          ; Далее прокрутка экрана вверх
 28+  C1A1
 39   C1A1              	INCLUDE "scrollUp.inc"
  1+  C1A1              ;+---------------------------------------------------------------------------
  2+  C1A1              ; MXOS
  3+  C1A1              ; Прокрутка экрана вверх
  4+  C1A1              ;
  5+  C1A1              ; На выходе
  6+  C1A1              ;   af, bc - сохраняются
  7+  C1A1              ;
  8+  C1A1              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1A1              ;----------------------------------------------------------------------------
 10+  C1A1
 11+  C1A1                          ; Сохраняем регистры
 12+  C1A1 C5                       push  bc
 13+  C1A2 F5                       push  af
 14+  C1A3
 15+  C1A3                          ; Сохраняем sp
 16+  C1A3 21 00 00                 ld    hl, 0
 17+  C1A6 39                       add   hl,sp
 18+  C1A7 22 F6 8F                 ld    (bios_vars.oldSP), hl
 19+  C1AA
 20+  C1AA                          ; Прокрутка экрана вверх
 21+  C1AA 31 0A 90                 ld    sp, 900Ah   ; Откуда
 22+  C1AD 26 90                    ld    h, 90h      ; Куда
 23+  C1AF 06 30                    ld    b, 48       ; Столбцов
 24+  C1B1 C3 99 C7                 jp    scrollUp2
 25+  C1B4
 40   C1B4              	INCLUDE "keyScan.inc"
  1+  C1B4              ;+---------------------------------------------------------------------------
  2+  C1B4              ; MXOS
  3+  C1B4              ; Получить код нажатой клавиши
  4+  C1B4              ;
  5+  C1B4              ; На выходе
  6+  C1B4              ;  a - код
  7+  C1B4              ;
  8+  C1B4              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1B4              ;----------------------------------------------------------------------------
 10+  C1B4
 11+  C1B4              setKeybMode83:
 12+  C1B4 3E 83                    ld      a, 83h
 13+  C1B6 32 E3 FF                 ld      (IO_KEYB_MODE),a
 14+  C1B9 C9                       ret
 15+  C1BA
 16+  C1BA              ; ---------------------------------------------------------------------------
 17+  C1BA
 18+  C1BA              keyScan2:   ; Режим чтения ряда
 19+  C1BA CD 43 C2                 call    setKeybMode82
 20+  C1BD
 21+  C1BD                          ; Одним чтением првоеряем все клавиши
 22+  C1BD 3A E1 FF                 ld      a, (IO_KEYB_B)
 23+  C1C0
 24+  C1C0                          ; Эти биты не используются в сканировании
 25+  C1C0 F6 03                    or      3
 26+  C1C2
 27+  C1C2                          ; Ни одна клавиша не нажата
 28+  C1C2 FE FF                    cp      0FFh
 29+  C1C4 C8                       ret z
 30+  C1C5
 31+  C1C5                          ; Сохраняем регистры
 32+  C1C5 E5                       push    hl
 33+  C1C6 C5                       push    bc
 34+  C1C7 D5                       push    de
 35+  C1C8
 36+  C1C8                          ; Перебираем 12 столбцов кнопок
 37+  C1C8 21 FE 0F                 ld      hl, 0FFEh
 38+  C1CB 11 A7 C4                 ld      de, v_keybTbl + 11
 39+  C1CE 06 FF                    ld      b, 0FFh
 40+  C1D0 7C           loc_C1DD:   ld      a, h
 41+  C1D1 32 E2 FF                 ld      (IO_KEYB_C),a
 42+  C1D4 7D                       ld      a, l
 43+  C1D5 32 E0 FF                 ld      (IO_KEYB_A),a
 44+  C1D8 0F                       rrca
 45+  C1D9 2F                       cpl
 46+  C1DA E6 04                    and     4
 47+  C1DC 4F                       ld      c, a
 48+  C1DD 3A E1 FF                 ld      a, (IO_KEYB_B)
 49+  C1E0 B1                       or      c
 50+  C1E1
 51+  C1E1                          ; Перебираем 6 кнопок в столбце
 52+  C1E1 0E 06                    ld      c, 6
 53+  C1E3 0F                       rrca
 54+  C1E4 0F                       rrca
 55+  C1E5 0F           loc_C1F2:   rrca
 56+  C1E6 D4 FF C1                 call    nc,    keybScan3
 57+  C1E9 0D                       dec     c
 58+  C1EA C2 E5 C1                 jp nz,  loc_C1F2
 59+  C1ED
 60+  C1ED                          ; Цикл
 61+  C1ED 1B                       dec     de
 62+  C1EE 29                       add     hl, hl
 63+  C1EF 23                       inc     hl
 64+  C1F0 7C                       ld      a, h
 65+  C1F1 C6 F0                    add     0F0h
 66+  C1F3 67                       ld      h, a
 67+  C1F4 DA D0 C1                 jp c,   loc_C1DD
 68+  C1F7
 69+  C1F7                          ; Режим ВВ55 по уполчанию
 70+  C1F7 CD 43 C2                 call    setKeybMode82
 71+  C1FA
 72+  C1FA                          ; Результат
 73+  C1FA 78                       ld      a, b
 74+  C1FB
 75+  C1FB                          ; Восстаналвиаем регистры
 76+  C1FB D1                       pop     de
 77+  C1FC C1                       pop     bc
 78+  C1FD E1                       pop     hl
 79+  C1FE C9                       ret
 80+  C1FF
 81+  C1FF              ;----------------------------------------------------------------------------
 82+  C1FF
 83+  C1FF D5           keybScan3:  push    de
 84+  C200 F5                       push    af
 85+  C201 3E 06                    ld      a, 6    ; e += (6 - c) * 16
 86+  C203 91                       sub     c
 87+  C204 87                       add     a, a
 88+  C205 87                       add     a, a
 89+  C206 87                       add     a, a
 90+  C207 87                       add     a, a
 91+  C208 83                       add     a, e
 92+  C209 5F                       ld      e, a
 93+  C20A 1A                       ld      a, (de) ; b = *de;
 94+  C20B 47                       ld      b, a
 95+  C20C F1                       pop     af
 96+  C20D D1                       pop     de
 97+  C20E C9                       ret
 98+  C20F
 41   C20F              	INCLUDE "getch2.inc"
  1+  C20F              ;----------------------------------------------------------------------------
  2+  C20F              ; MXOS
  3+  C20F              ; Ожидание ввода с клавиатуры
  4+  C20F              ;
  5+  C20F              ; На выходе
  6+  C20F              ;  ? - код
  7+  C20F              ;
  8+  C20F              ; 2013-12-12 Дизассемблировано vinxru
  9+  C20F              ;----------------------------------------------------------------------------
 10+  C20F
 11+  C20F              getch2:     ; Сохраняем регистры
 12+  C20F E5                       push    hl
 13+  C210 C5                       push    bc
 14+  C211 D5                       push    de
 15+  C212
 16+  C212                          ; Получаем код нажатой клавиши и сохраняем его в bios_vars.lastKey
 17+  C212 CD BA C1                 call    keyScan2
 18+  C215 32 F0 8F                 ld      (bios_vars.lastKey),a
 19+  C218
 20+  C218              getch_retry:
 21+  C218                          ; Тут будет признак, нарисован курсор или нет
 22+  C218 0E 01                    ld      c, 1
 23+  C21A
 24+  C21A              loc_C227:   ; Рисуем курсор
 25+  C21A CD 4D C3                 call    drawCursor2
 26+  C21D
 27+  C21D                          ; Задержка
 28+  C21D 3A F4 8F                 ld      a, (bios_vars.cursorDelay)
 29+  C220 06 40        loc_C22D:   ld      b, 40h
 30+  C222 CD 90 C1                 call    delay_b
 31+  C225 3D                       dec     a
 32+  C226 C2 20 C2                 jp nz,  loc_C22D
 33+  C229
 34+  C229              loc_C236:   ; Рисуем/стираем курсор
 35+  C229 CD 48 C3                 call    drawCursor
 36+  C22C
 37+  C22C                          ; Задержка мерцания курсора
 38+  C22C 11 00 05                 ld      de, 500h
 39+  C22F
 40+  C22F              loc_C23C:   ; Получаем код нажатой клавиши
 41+  C22F CD BA C1                 call    keyScan2
 42+  C232                          ;cp      80h         ; х.з.
 43+  C232 FE FF                    cp      0FFh
 44+  C234 C2 4F C2                 jp nz,  getch2_pressed
 45+  C237
 46+  C237                          ; Записываем bios_vars.lastKey=0FFh
 47+  C237 32 F0 8F                 ld      (bios_vars.lastKey),a
 48+  C23A
 49+  C23A                          ; Повторяем 500h раз
 50+  C23A 1B                       dec     de
 51+  C23B 7A                       ld      a, d
 52+  C23C B3                       or      e
 53+  C23D C2 2F C2                 jp nz,  loc_C23C
 54+  C240
 55+  C240                          ; Повтор всего
 56+  C240 C3 29 C2                 jp      loc_C236
 57+  C243
 58+  C243              ; ---------------------------------------------------------------------------
 59+  C243
 60+  C243              ;    DB 0FFh, 0FFh
 61+  C243
 62+  C243              ; ---------------------------------------------------------------------------
 63+  C243
 64+  C243              setKeybMode82:
 65+  C243 3E 82                    ld      a, 82h
 66+  C245 32 E3 FF                 ld      (IO_KEYB_MODE),a
 67+  C248 C9                       ret
 68+  C249
 69+  C249              ; ---------------------------------------------------------------------------
 70+  C249
 71+  C249              setKeybMode91:
 72+  C249 3E 91                    ld      a, 91h
 73+  C24B 32 E3 FF                 ld      (IO_KEYB_MODE),a
 74+  C24E C9                       ret
 75+  C24F
 76+  C24F              ; ---------------------------------------------------------------------------
 77+  C24F              ; Была нажата клавиша
 78+  C24F
 79+  C24F              getch2_pressed:
 80+  C24F                          ; Сохраняем код
 81+  C24F 47                       ld      b, a
 82+  C250
 83+  C250                          ; Если нарисован курсор, стираем его
 84+  C250 79                       ld      a, c
 85+  C251 0F                       rrca
 86+  C252 DA 58 C2                 jp c,   loc_C269
 87+  C255 CD 4D C3                 call    drawCursor2
 88+  C258              loc_C269:
 89+  C258 2A EF 8F                 ld      hl, (bios_vars.lastLastKey)   ; h = bios_vars.lastKey, l = bios_vars.lastLastKey
 90+  C25B 78                       ld      a, b        ; a = b = код нажатой клавиши
 91+  C25C BC                       cp      h
 92+  C25D C2 7C C2                 jp nz,    loc_C28D    ; Код нажатой клавиши изменился
 93+  C260 BD                       cp      l
 94+  C261 CA 84 C2                 jp z,   loc_C295
 95+  C264
 96+  C264                          ; Рисуем курсор
 97+  C264 CD 48 C3                 call    drawCursor
 98+  C267
 99+  C267                          ; Ждем, пока отпустят клавишу
100+  C267 3A F5 8F                 ld      a, (bios_vars.antiBsDelay)
101+  C26A 57                       ld      d, a
102+  C26B CD BA C1     loc_C27C:   call    keyScan2
103+  C26E BC                       cp      h
104+  C26F C2 1A C2                 jp nz,  loc_C227    ; Быстро нажали другую клавишу
105+  C272 15                       dec     d
106+  C273 C2 6B C2                 jp nz,  loc_C27C
107+  C276
108+  C276                          ; Долго держали
109+  C276
110+  C276                          ; Стираем курсор
111+  C276 CD 48 C3                 call    drawCursor
112+  C279
113+  C279 C3 7F C2                 jp      loc_C290
114+  C27C              ; ---------------------------------------------------------------------------
115+  C27C
116+  C27C              loc_C28D:   ; Звуковой сигнал
117+  C27C CD 70 C1                 call    beep
118+  C27F
119+  C27F 6C           loc_C290:   ld      l, h
120+  C280 60                       ld      h, b  ; код нажатой и предыдущей клавиши сохраняем в bios_vars.lastKey
121+  C281 22 EF 8F                 ld      (bios_vars.lastLastKey), hl
122+  C284
123+  C284              loc_C295:   ; Не служебные клавиши CAPS LOCK, SHIFT и РУС/LAT не влияют
124+  C284 78                       ld      a, b
125+  C285 FE 21                    cp      21h
126+  C287 DA FC C2                 jp c,   getch_noShift
127+  C28A                          ; На клавиши c кодами 21h-3Fh влияет SHIFT
128+  C28A FE 40                    cp      40h
129+  C28C DA EA C2                 jp c,   getch_shift
130+  C28F                          ; На символьные клавиши (40h-7Eh) влияют CAPS LOCK, SHIFT и РУС/LAT
131+  C28F FE 7F                    cp      7Fh
132+  C291 DA CA C2                 jp c,   getch_chars
133+  C294                          ; Не служебные клавиши (7Fh+) CAPS LOCK, SHIFT и РУС/LAT не влияют
134+  C294 CA FC C2                 jp z,   getch_noShift
135+  C297
136+  C297                          ; ...
137+  C297                          ;nop
138+  C297                          ;nop
139+  C297
140+  C297                          ; Переходим, если код клавиши не 81h
141+  C297 FE 81                    cp      81h
142+  C299 C2 FC C2                 jp nz,  getch_noShift
143+  C29C
144+  C29C                          ; Код клавиши 81h
145+  C29C
146+  C29C                          ; Если шифт не нажат
147+  C29C 3A E1 FF                 ld      a, (IO_KEYB_B)
148+  C29F E6 02                    and     2
149+  C2A1 C2 85 C5                 jp nz,  getch3
150+  C2A4
151+  C2A4                          ; Код клавиши 81h с шифтом
152+  C2A4
153+  C2A4                          ; Звуковой сигнал
154+  C2A4 CD 70 C1                 call    beep
155+  C2A7
156+  C2A7                          ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
157+  C2A7 C3 C7 C5                 jp      getch_rc
158+  C2AA
159+  C2AA              ; ---------------------------------------------------------------------------
160+  C2AA              ; Нажата комбинация Shift + РУС/LAT
161+  C2AA
162+  C2AA              getch_RusLat:
163+  C2AA                          ; на входе a = bios_vars.keyLocks
164+  C2AA EE 81                    xor     81h ; инверируем сарший и младший биты
165+  C2AC 32 EC 8F                 ld      (bios_vars.keyLocks), a
166+  C2AF
167+  C2AF                          ; Особый звуковой сигнал
168+  C2AF 3A F1 8F                 ld      a, (bios_vars.beepFreq)
169+  C2B2 F5                       push    af
170+  C2B3 3E 4F                    ld      a, 4Fh
171+  C2B5 32 F1 8F                 ld      (bios_vars.beepFreq), a
172+  C2B8 CD 70 C1                 call    beep
173+  C2BB 3E 5F                    ld      a, 5Fh
174+  C2BD 32 F1 8F                 ld      (bios_vars.beepFreq), a
175+  C2C0 CD 70 C1                 call    beep
176+  C2C3 F1                       pop     af
177+  C2C4 32 F1 8F                 ld      (bios_vars.beepFreq), a
178+  C2C7
179+  C2C7                          ; ...
180+  C2C7                          ;nop
181+  C2C7
182+  C2C7 C3 18 C2                 jp      getch_retry
183+  C2CA
184+  C2CA              ; ---------------------------------------------------------------------------
185+  C2CA              ; Включаем кирилицу или строчные буквы
186+  C2CA
187+  C2CA              getch_chars:
188+  C2CA                          ; Если не нажат CAPS LOCK, пропускаем код ниже
189+  C2CA 3A EC 8F                 ld      a, (bios_vars.keyLocks)
190+  C2CD 4F                       ld      c, a
191+  C2CE A7                       and     a
192+  C2CF FA D6 C2                 jp M,   loc_C2EA    ; CAPS LOCK
193+  C2D2
194+  C2D2                          ; Превращаем заглавные в строчные
195+  C2D2 78                       ld      a, b
196+  C2D3 EE 20                    xor     20h
197+  C2D5 47                       ld      b, a
198+  C2D6
199+  C2D6              loc_C2EA:   ; Если зафиксирвоан ли РУС/ЛАТ, помещаем в c=1
200+  C2D6 79                       ld      a, c
201+  C2D7 E6 01                    and     1
202+  C2D9 4F                       ld      c, a
203+  C2DA
204+  C2DA                          ; Если шифт нажат, помещаем в a=0
205+  C2DA 3A E1 FF                 ld      a, (IO_KEYB_B)
206+  C2DD E6 02                    and     2
207+  C2DF 0F                       rrca    ; ! Как на счет флага c ?
208+  C2E0
209+  C2E0                          ; Превращаем английские символы в русские если a^c==0
210+  C2E0 A9                       xor     c
211+  C2E1 78                       ld      a, b
212+  C2E2 C2 D4 C5                 jp nz,  loc_C5A8
213+  C2E5 C6 80                    add     80h
214+  C2E7 C3 D4 C5                 jp      loc_C5A8
215+  C2EA
216+  C2EA              ; ---------------------------------------------------------------------------
217+  C2EA              ; Меняем цифры на символы
218+  C2EA
219+  C2EA              getch_shift:
220+  C2EA                          ; Если не нажат шифт, пропускаем код ниже
221+  C2EA 3A E1 FF                 ld      a, (IO_KEYB_B)
222+  C2ED E6 02                    and     2
223+  C2EF 78                       ld      a, b
224+  C2F0 C2 D4 C5                 jp nz,  loc_C5A8
225+  C2F3
226+  C2F3                          ; Меняем цифры на символы
227+  C2F3 EE 10                    xor     10h
228+  C2F5
229+  C2F5                          ; Одно исключение 30h должен меняться на 5Fh
230+  C2F5 FE 20                    cp      20h
231+  C2F7 C2 FC C2                 jp nz,  getch_noShift
232+  C2FA 3E 5F                    ld      a, 5Fh
233+  C2FC
234+  C2FC                          ; Прододжение getch_noShift
235+  C2FC
236+  C2FC              ; ---------------------------------------------------------------------------
237+  C2FC              ; Символы без изменений
238+  C2FC
239+  C2FC              getch_noShift:
240+  C2FC                          ; Сохраняем код нажатой клавиши в b
241+  C2FC 47                       ld      b, a
242+  C2FD
243+  C2FD CD B4 C1     loc_C311:   call    setKeybMode83
244+  C300 3E F7                    ld      a, 0F7h
245+  C302 32 E0 FF                 ld      (IO_KEYB_A),a
246+  C305 3A E1 FF                 ld      a, (IO_KEYB_B)
247+  C308 2F                       cpl
248+  C309 0F                       rrca
249+  C30A 0F                       rrca
250+  C30B 0F                       rrca
251+  C30C CD 43 C2                 call    setKeybMode82
252+  C30F
253+  C30F                          ;nop
254+  C30F
255+  C30F                          ; Восстаналиваем код нажатой клавиши
256+  C30F 78                       ld      a, b
257+  C310
258+  C310              popa_ret_2: ; Восстаналиваем регистры и выходим
259+  C310 D1                       pop     de
260+  C311 C1                       pop     bc
261+  C312 E1                       pop     hl
262+  C313 C9                       ret
263+  C314
 42   C314              	INCLUDE "calcCursorAddr.inc"
  1+  C314              ;+---------------------------------------------------------------------------
  2+  C314              ; MXOS
  3+  C314              ; Расчет адреса курсора в видеопамяти. И перевод строки, если курсор был
  4+  C314              ; за правым краем экрана.
  5+  C314              ;
  6+  C314              ; На выходе
  7+  C314              ;  hl - координаты курсора
  8+  C314              ;  a * 256 + l - адрес в видеопамяти
  9+  C314              ;
 10+  C314              ; 2013-12-12 Дизассемблировано vinxru
 11+  C314              ;----------------------------------------------------------------------------
 12+  C314
 13+  C314              calcCursorAddr:   ; В hl положение курсора
 14+  C314 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 15+  C317
 16+  C317                          ; Если cursorX >= 190, то перевод строки (вывод кода 10)
 17+  C317                          ; Иначе рассчитываем адрес старшего байта a = cursorX / 4 + 90h
 18+  C317 7C                       ld    a, h
 19+  C318 FE BE                    cp    190
 20+  C31A DA 41 C3                 jp c, calcCursorAd_1
 21+  C31D 0E 0A                    ld    c, 10
 22+  C31F C3 3A C3                 jp    calcCursorAd_0
 23+  C322
 43   C322
 44   C322                  ; тут есть место 15 байт
 45   C322
 46   C322                  ORG_PAD 0C337h
 46   C322             >         IF $ > 0C337h
 46   C322 ~           >           ; вывод сообщения об ошибке
 46   C322 ~           >           ASSERT 0
 46   C322 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 46   C322             >         ELSE
 46   C322             >           ; заполнение памяти
 46   C322 FF FF FF... >           BLOCK 0C337h-$, 0FFh
 46   C326             >         ENDIF
 46   C337             >         ORG 0C337h
 47   C337              	INCLUDE "getch.inc"
  1+  C337              ;----------------------------------------------------------------------------
  2+  C337              ; MXOS
  3+  C337              ; Ожидание ввода с клавиатуры
  4+  C337              ;
  5+  C337              ; На выходе
  6+  C337              ;  ? - код
  7+  C337              ;
  8+  C337              ; 2013-12-12 Дизассемблировано vinxru
  9+  C337              ;----------------------------------------------------------------------------
 10+  C337
 11+  C337 C3 0F C2     getch:            jp    getch2
 12+  C33A
 48   C33A              	INCLUDE "calcCursorAddr2.inc"
  1+  C33A              ;+---------------------------------------------------------------------------
  2+  C33A              ; MXOS
  3+  C33A              ; Расчет адреса курсора в видеопамяти (продолжение);
  4+  C33A              ;
  5+  C33A              ; 2013-12-12 Дизассемблировано vinxru
  6+  C33A              ;----------------------------------------------------------------------------
  7+  C33A
  8+  C33A              calcCursorAd_0:   ; Перевод строки (на входе c=10)
  9+  C33A CD 37 C0                 call  printChar
 10+  C33D
 11+  C33D                          ; Восстановление регистров после printChar (хотя он не портит регистры)
 12+  C33D 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 13+  C340 7C                       ld    a, h
 14+  C341
 15+  C341              calcCursorAd_1:   ; Расчет старшего байта адреса
 16+  C341                          ; a = cursorX / 4 + 90h
 17+  C341 0F                       rrca
 18+  C342 0F                       rrca
 19+  C343 E6 3F                    and   3Fh
 20+  C345 C6 90                    add   a,90h
 21+  C347 C9                       ret
 22+  C348
 49   C348              	INCLUDE "drawCursor.inc"
  1+  C348              ;+---------------------------------------------------------------------------
  2+  C348              ; MXOS
  3+  C348              ; Рисование курсора на экране
  4+  C348              ;
  5+  C348              ; На выходе
  6+  C348              ;  bc, de, hl - сохраняются
  7+  C348              ;
  8+  C348              ; 2013-12-12 Дизассемблировано vinxru
  9+  C348              ;----------------------------------------------------------------------------
 10+  C348
 11+  C348              drawCursor: ; Если установлен 7-ой бит bios_vars.cursorCfg & 0x80, выходим
 12+  C348 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 13+  C34B A7                       and   a
 14+  C34C F8                       ret m
 15+  C34D
 16+  C34D              drawCursor2:      ; Курсор нарисован/стерт
 17+  C34D 0C                       inc   c
 18+  C34E
 19+  C34E              drawCursor3:      ; Сохраняем регистры
 20+  C34E E5                       push  hl
 21+  C34F C5                       push  bc
 22+  C350 D5                       push  de
 23+  C351
 24+  C351                          ; Рассчитываем адрес на экране
 25+  C351 CD 14 C3                 call  calcCursorAddr
 26+  C354 57                       ld    d, a
 27+  C355
 28+  C355                          ; Положение курсора от +2 до -5 (при битах 654 от 0 до 7)
 29+  C355                          ; b = bios_vars.cursorCfg
 30+  C355                          ; e = ~((bios_vars.cursorCfg / 16) % 8 - 3) + l
 31+  C355 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 32+  C358 47                       ld    b, a
 33+  C359 0F                       rrca
 34+  C35A 0F                       rrca
 35+  C35B 0F                       rrca
 36+  C35C 0F                       rrca
 37+  C35D E6 07                    and   7
 38+  C35F D6 03                    sub   3
 39+  C361 2F                       cpl
 40+  C362 85                       add   a, l
 41+  C363 5F                       ld    e, a
 42+  C364
 43+  C364                          ; Рассчитыаем маску курсора
 44+  C364                          ;  hl = 011111100b << (((~h) % 4 +1)*2)
 45+  C364 7C                       ld    a, h
 46+  C365 2F                       cpl
 47+  C366 E6 03                    and   3
 48+  C368 21 FC 00                 ld    hl, 011111100b ; FCh
 49+  C36B 3C                       inc   a
 50+  C36C 29           drawCursor_0:     add   hl, hl
 51+  C36D 29                       add   hl, hl
 52+  C36E C3 43 C4                 jp    drawCursor_1
 53+  C371
 50   C371
 51   C371                  ; тут есть место 6 байт
 52   C371
 53   C371                  ORG_PAD 0C377h
 53   C371             >         IF $ > 0C377h
 53   C371 ~           >           ; вывод сообщения об ошибке
 53   C371 ~           >           ASSERT 0
 53   C371 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 53   C371             >         ELSE
 53   C371             >           ; заполнение памяти
 53   C371 FF FF FF... >           BLOCK 0C377h-$, 0FFh
 53   C375             >         ENDIF
 53   C377             >         ORG 0C377h
 54   C377                  INCLUDE "tape.inc"
  1+  C377              ;----------------------------------------------------------------------------
  2+  C377              ; MXOS
  3+  C377              ; Таблица перехвата вызовов драйвера магнитофона
  4+  C377              ;
  5+  C377              ; Изначально все функции просто перезапускают систему.
  6+  C377              ; Адреса заменяются на реальные при установке драйвера.
  7+  C377              ;
  8+  C377              ; 2022-02-03 SpaceEngineer
  9+  C377              ;----------------------------------------------------------------------------
 10+  C377
 11+  C377 C3 00 C8     t_tapeRead:      jp bios_reboot
 12+  C37A C3 00 C8     t_tapeWrite:     jp bios_reboot
 13+  C37D C3 00 C8     t_tapeLoad:      jp bios_reboot
 14+  C380 C3 00 C8     t_tapeSave:      jp bios_reboot
 15+  C383 C3 00 C8     t_tapeLoadInt:   jp bios_reboot
 16+  C386 C3 00 C8     t_tapeReadError: jp bios_reboot
 17+  C389
 55   C389              	INCLUDE "cmp_hl_de_2.inc"
  1+  C389              ;+---------------------------------------------------------------------------
  2+  C389              ; MXOS
  3+  C389              ; Сравнить hl и de
  4+  C389              ;
  5+  C389              ; 2013-12-12 Дизассемблировано vinxru
  6+  C389              ;----------------------------------------------------------------------------
  7+  C389
  8+  C389              cmp_hl_de_2:
  9+  C389 7C                   ld    a, h
 10+  C38A BA                   cp    d
 11+  C38B D8                   ret   c
 12+  C38C C0                   ret   nz
 13+  C38D 7D                   ld    a, l
 14+  C38E BB                   cp    e
 15+  C38F C9                   ret
 16+  C390
 56   C390              	INCLUDE "sbb_de_hl_to_hl.inc"
  1+  C390              ;+---------------------------------------------------------------------------
  2+  C390              ; MXOS
  3+  C390              ; hl = de - hl
  4+  C390              ;
  5+  C390              ; 2013-12-12 Дизассемблировано vinxru
  6+  C390              ;----------------------------------------------------------------------------
  7+  C390
  8+  C390              sbb_de_hl_to_hl:
  9+  C390 7B                       ld    a, e
 10+  C391 95                       sub   l
 11+  C392 6F                       ld    l, a
 12+  C393 7A                       ld    a, d
 13+  C394 9C                       sbc   h
 14+  C395 67                       ld    h, a
 15+  C396 C9                       ret
 16+  C397
 57   C397              	INCLUDE "memmove_bc_hl.inc"
  1+  C397              ;+---------------------------------------------------------------------------
  2+  C397              ; MXOS
  3+  C397              ; Копирование накладывающихся блоков памяти (с ошибкой)
  4+  C397              ;
  5+  C397              ; На входе
  6+  C397              ;  hl - откуда
  7+  C397              ;  de - откуда, конечный адрес не включая
  8+  C397              ;  bc - куда, с увеличением адресов
  9+  C397              ;
 10+  C397              ; 2013-12-12 Дизассемблировано vinxru
 11+  C397              ;----------------------------------------------------------------------------
 12+  C397
 13+  C397              memmove_bc_hl:
 14+  C397                          ; Сохраняем регистры
 15+  C397 E5                       push    hl
 16+  C398 C5                       push    bc
 17+  C399 D5                       push    de
 18+  C39A
 19+  C39A                          ; Если b<h или c<l, то
 20+  C39A 78                       ld      a, b
 21+  C39B BC                       cp      h
 22+  C39C DA B9 C3                 jp c,   memcpy_bc_hl2
 23+  C39F
 24+  C39F                          ; Тут не хватает jnz
 25+  C39F
 26+  C39F 79                       ld      a, c
 27+  C3A0 BD                       cp      l
 28+  C3A1 DA B9 C3                 jp c,   memcpy_bc_hl2
 29+  C3A4
 30+  C3A4                          ; bc = bc + de - hl
 31+  C3A4 E5                       push    hl
 32+  C3A5 CD 90 C3                 call    sbb_de_hl_to_hl
 33+  C3A8 09                       add     hl, bc
 34+  C3A9 44                       ld      b, h
 35+  C3AA 4D                       ld      c, l
 36+  C3AB E1                       pop     hl
 37+  C3AC
 38+  C3AC              memcpyb_bc_de:
 39+  C3AC                          ; Копируем из de в bc с уменьшением адресов, пока hl не равно de
 40+  C3AC 1A                       ld      a, (de)
 41+  C3AD 02                       ld      (bc), a
 42+  C3AE CD 89 C3                 call    cmp_hl_de_2
 43+  C3B1 1B                       dec     de
 44+  C3B2 0B                       dec     bc
 45+  C3B3 C2 AC C3                 jp nz,  memcpyb_bc_de
 46+  C3B6
 47+  C3B6                          ; Восстановление регистров и выход
 48+  C3B6 C3 C3 C3                 jp      popDBH_ret2
 49+  C3B9
 50+  C3B9              memcpy_bc_hl2:
 51+  C3B9                          ; Копируем из hl в bc с увеличением адресов, пока hl не равно de
 52+  C3B9 7E                       ld      a, (hl)
 53+  C3BA 02                       ld      (bc),a
 54+  C3BB CD 89 C3                 call    cmp_hl_de_2
 55+  C3BE 23                       inc     hl
 56+  C3BF 03                       inc     bc
 57+  C3C0 C2 B9 C3                 jp nz,  memcpy_bc_hl2
 58+  C3C3
 59+  C3C3              popDBH_ret2:
 60+  C3C3                          ; Восстановление регистров и выход
 61+  C3C3 D1                       pop     de
 62+  C3C4 C1                       pop     bc
 63+  C3C5 E1                       pop     hl
 64+  C3C6 C9                       ret
 65+  C3C7
 58   C3C7              	INCLUDE "memset_de_20_b.inc"
  1+  C3C7              ;+---------------------------------------------------------------------------
  2+  C3C7              ; MXOS
  3+  C3C7              ; Заполнить память пробелами
  4+  C3C7              ;
  5+  C3C7              ; На входе
  6+  C3C7              ;  de - адрес
  7+  C3C7              ;  b  - длина (0 считается за 256)
  8+  C3C7              ;
  9+  C3C7              ; 2013-12-12 Дизассемблировано vinxru
 10+  C3C7              ;----------------------------------------------------------------------------
 11+  C3C7
 12+  C3C7              memset_de_20_b:
 13+  C3C7 3E 20                    ld      a, ' '
 14+  C3C9              memset_de_a_b:
 15+  C3C9 12                       ld      (de), a
 16+  C3CA 13                       inc     de
 17+  C3CB 05                       dec     b
 18+  C3CC C2 C9 C3                 jp nz,  memset_de_a_b
 19+  C3CF C9                       ret
 20+  C3D0
 59   C3D0
 60   C3D0                  ORG_PAD 0C3D0h
 60   C3D0             >         IF $ > 0C3D0h
 60   C3D0 ~           >           ; вывод сообщения об ошибке
 60   C3D0 ~           >           ASSERT 0
 60   C3D0 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 60   C3D0             >         ELSE
 60   C3D0             >           ; заполнение памяти
 60   C3D0             >           BLOCK 0C3D0h-$, 0FFh
 60   C3D0             >         ENDIF
 60   C3D0             >         ORG 0C3D0h
 61   C3D0 C3 7A C3         jp  t_tapeWrite
 62   C3D3
 63   C3D3                  IF RAMFOS_COMPATIBILITY
 64   C3D3              	INCLUDE "strToHex.inc"
  1+  C3D3              ;+---------------------------------------------------------------------------
  2+  C3D3              ; MXOS
  3+  C3D3              ; Преобразвоние строки в 16-ричное число
  4+  C3D3              ; Заимствовано из RAMFOS
  5+  C3D3              ;
  6+  C3D3              ; На входе
  7+  C3D3              ;  de - Строка
  8+  C3D3              ;
  9+  C3D3              ; На выходе
 10+  C3D3              ;  bc       - Сохраняется
 11+  C3D3              ;  de       - Следующий символ за запятой или концом строки
 12+  C3D3              ;  jz       - Ошибка
 13+  C3D3              ;  jnz, jc  - Конец строки
 14+  C3D3              ;  jnz, jnc - Пробел или запятая
 15+  C3D3              ;  hl       - Число
 16+  C3D3              ;
 17+  C3D3              ; 2013-11-01 Дизассемблировано vinxru
 18+  C3D3              ;----------------------------------------------------------------------------
 19+  C3D3
 20+  C3D3              strToHex:
 21+  C3D3 21 00 00                 ld  hl, 0
 22+  C3D6
 23+  C3D6              strToHex_loop:    ; Чтение символа
 24+  C3D6 1A                       ld    a, (de)
 25+  C3D7 13                       inc   de
 26+  C3D8
 27+  C3D8                          ; Если конец строки, выходим с флагами NZ, c
 28+  C3D8 FE 0D                    cp    0Dh
 29+  C3DA CA 13 C4                 jp z, ora_a_stc_ret
 30+  C3DD
 31+  C3DD                          ; Если пробел или запятая, выходим с флагами NZ, NC
 32+  C3DD FE 2C                    cp    ','
 33+  C3DF CA 16 C4                 jp z, ora_a_ret
 34+  C3E2 FE 20                    cp    ' '
 35+  C3E4 CA 16 C4                 jp z, ora_a_ret
 36+  C3E7
 37+  C3E7                          ; Если некорректный символ, выходим с флагами С,Z
 38+  C3E7 D6 30                    sub   '0'
 39+  C3E9 FA 0D C4                 jp M, xra_a_stc_ret
 40+  C3EC
 41+  C3EC                          ; Если это цифра
 42+  C3EC FE 0A                    cp    10
 43+  C3EE FA FD C3                 jp M, strToHex_0
 44+  C3F1
 45+  C3F1                          ; Если некорректный символ, выходим с флагами С,Z
 46+  C3F1 FE 11                    cp    11h
 47+  C3F3 FA 0D C4                 jp M, xra_a_stc_ret
 48+  C3F6 FE 17                    cp    17h
 49+  C3F8 F2 0D C4                 jp p, xra_a_stc_ret
 50+  C3FB
 51+  C3FB                          ; Это буквы A..F
 52+  C3FB D6 07                    sub   'A'-'0'-10
 53+  C3FD
 54+  C3FD              strToHex_0:
 55+  C3FD                          ; hl *= 16
 56+  C3FD 29                       add   hl, hl
 57+  C3FE 29                       add   hl, hl
 58+  C3FF 29                       add   hl, hl
 59+  C400 29                       add   hl, hl
 60+  C401
 61+  C401                          ; Если переполнение, выходим c флагами С,Z
 62+  C401 DA 0D C4                 jp c, xra_a_stc_ret
 63+  C404
 64+  C404                          ; hl += bc
 65+  C404 C5                       push bc
 66+  C405 06 00                    ld   b, 0
 67+  C407 4F                       ld   c, a
 68+  C408 09                       add  hl, bc
 69+  C409 C1                       pop  bc
 70+  C40A
 71+  C40A C3 D6 C3                 jp    strToHex_loop
 72+  C40D
 73+  C40D              xra_a_stc_ret:    ; Вывод знака вопроса
 74+  C40D 0E 3F                    ld  c, '?'
 75+  C40F CD 37 C0                 call      printChar
 76+  C412 AF                       xor a
 77+  C413
 78+  C413              ora_a_stc_ret:
 79+  C413 B7                       or  a
 80+  C414 37                       scf
 81+  C415 C9                       ret
 82+  C416
 83+  C416              ora_a_ret:
 84+  C416 B7                       or  a
 85+  C417 C9                       ret
 86+  C418
 65   C418                  ENDIF
 66   C418
 67   C418                  ; тут есть место 15 байт
 68   C418
 69   C418                  ORG_PAD 0C427h
 69   C418             >         IF $ > 0C427h
 69   C418 ~           >           ; вывод сообщения об ошибке
 69   C418 ~           >           ASSERT 0
 69   C418 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 69   C418             >         ELSE
 69   C418             >           ; заполнение памяти
 69   C418 FF FF FF... >           BLOCK 0C427h-$, 0FFh
 69   C41C             >         ENDIF
 69   C427             >         ORG 0C427h
 70   C427              	INCLUDE "cmp_hl_de.inc"
  1+  C427              ;+---------------------------------------------------------------------------
  2+  C427              ; MXOS
  3+  C427              ; Сравнить hl и de
  4+  C427              ;
  5+  C427              ; 2013-12-12 Дизассемблировано vinxru
  6+  C427              ;----------------------------------------------------------------------------
  7+  C427
  8+  C427              cmp_hl_de:
  9+  C427 7C                   ld    a, h
 10+  C428 BA                   cp    d
 11+  C429 C0                   ret   nz
 12+  C42A 7D                   ld    a, l
 13+  C42B BB                   cp    e
 14+  C42C C9                   ret
 15+  C42D
 71   C42D
 72   C42D                  ORG_PAD 0C42Dh
 72   C42D             >         IF $ > 0C42Dh
 72   C42D ~           >           ; вывод сообщения об ошибке
 72   C42D ~           >           ASSERT 0
 72   C42D ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 72   C42D             >         ELSE
 72   C42D             >           ; заполнение памяти
 72   C42D             >           BLOCK 0C42Dh-$, 0FFh
 72   C42D             >         ENDIF
 72   C42D             >         ORG 0C42Dh
 73   C42D              	INCLUDE "memcpy_bc_hl.inc"
  1+  C42D              ;+---------------------------------------------------------------------------
  2+  C42D              ; MXOS
  3+  C42D              ; Скопировать блок памяти
  4+  C42D              ;
  5+  C42D              ; На входе
  6+  C42D              ;  hl - откуда начало
  7+  C42D              ;  de - откуда конец + 1
  8+  C42D              ;  (de-hl) - длина
  9+  C42D              ;  bc - куда
 10+  C42D              ;
 11+  C42D              ; На выходе
 12+  C42D              ;  de - сохраняется
 13+  C42D              ;
 14+  C42D              ; 2013-12-12 Дизассемблировано vinxru
 15+  C42D              ;----------------------------------------------------------------------------
 16+  C42D
 17+  C42D              memcpy_bc_hl:
 18+  C42D 7E                       ld      a, (hl)
 19+  C42E 02                       ld      (bc),a
 20+  C42F 23                       inc     hl
 21+  C430 03                       inc     bc
 22+  C431 CD 27 C4                 call    cmp_hl_de
 23+  C434 C2 2D C4                 jp nz,  memcpy_bc_hl
 24+  C437 C9                       ret
 25+  C438
 74   C438
 75   C438                  ORG_PAD 0C438h
 75   C438             >         IF $ > 0C438h
 75   C438 ~           >           ; вывод сообщения об ошибке
 75   C438 ~           >           ASSERT 0
 75   C438 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 75   C438             >         ELSE
 75   C438             >           ; заполнение памяти
 75   C438             >           BLOCK 0C438h-$, 0FFh
 75   C438             >         ENDIF
 75   C438             >         ORG 0C438h
 76   C438              	INCLUDE "printString1.inc"
  1+  C438              ;+---------------------------------------------------------------------------
  2+  C438              ; MXOS
  3+  C438              ; Вывод строки на экран
  4+  C438              ;
  5+  C438              ; На входе
  6+  C438              ;  hl - строка
  7+  C438              ;
  8+  C438              ; На выходе
  9+  C438              ;  af, bc, de - сохраняются
 10+  C438              ;
 11+  C438              ; 2013-12-12 Дизассемблировано vinxru
 12+  C438              ;----------------------------------------------------------------------------
 13+  C438
 14+  C438 C3 22 C5     printString1:     jp    printString
 15+  C43B
 77   C43B              	INCLUDE "printChar6.inc"
  1+  C43B              ;+---------------------------------------------------------------------------
  2+  C43B              ; MXOS
  3+  C43B              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C43B              ;
  5+  C43B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C43B              ;----------------------------------------------------------------------------
  7+  C43B
  8+  C43B              ; ---------------------------------------------------------------------------
  9+  C43B              ; Обработка ESC+F
 10+  C43B
 11+  C43B 3E 80        printChar_eF:   ld    a, 80h
 12+  C43D 32 EB 8F                     ld    (bios_vars.escMode), a
 13+  C440 C9                           ret
 14+  C441
 78   C441
 79   C441                  ORG_PAD 0C443h
 79   C441             >         IF $ > 0C443h
 79   C441 ~           >           ; вывод сообщения об ошибке
 79   C441 ~           >           ASSERT 0
 79   C441 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 79   C441             >         ELSE
 79   C441             >           ; заполнение памяти
 79   C441 FF FF       >           BLOCK 0C443h-$, 0FFh
 79   C443             >         ENDIF
 79   C443             >         ORG 0C443h
 80   C443                  INCLUDE "drawCursor2.inc"
  1+  C443              ;+---------------------------------------------------------------------------
  2+  C443              ; MXOS
  3+  C443              ; Рисование курсора на экране (продолжение)
  4+  C443              ;
  5+  C443              ; 2013-12-12 Дизассемблировано vinxru
  6+  C443              ;----------------------------------------------------------------------------
  7+  C443
  8+  C443              drawCursor_1:     ; Цикл
  9+  C443 3D                       dec   a
 10+  C444 C2 6C C3                 jp nz,  drawCursor_0
 11+  C447
 12+  C447                          ; b = vars.cursorCfg & 0xF
 13+  C447 78                       ld    a, b
 14+  C448 E6 0F                    and   0Fh
 15+  C44A 47                       ld    b, a
 16+  C44B
 17+  C44B                          ; Вывод курсора (b - высота, de - адрес на экране, hl - курсор)
 18+  C44B
 19+  C44B              drawCursor_2:     ; Повторить код ниже b раз
 20+  C44B 05                       dec   b
 21+  C44C FA 10 C3                 jp M, popa_ret_2
 22+  C44F
 23+  C44F                          ; *de--     ^= hl;
 24+  C44F 1A                       ld    a, (de)
 25+  C450 AC                       xor   h
 26+  C451 12                       ld    (de),a
 27+  C452 14                       inc   d
 28+  C453 1A                       ld    a, (de)
 29+  C454 AD                       xor   l
 30+  C455 12                       ld    (de),a
 31+  C456 15                       dec   d
 32+  C457 1D                       dec   e
 33+  C458 C3 4B C4                 jp    drawCursor_2
 34+  C45B
 81   C45B
 82   C45B                  ; тут есть место 29 байт
 83   C45B
 84   C45B                  ORG_PAD 0C478h
 84   C45B             >         IF $ > 0C478h
 84   C45B ~           >           ; вывод сообщения об ошибке
 84   C45B ~           >           ASSERT 0
 84   C45B ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 84   C45B             >         ELSE
 84   C45B             >           ; заполнение памяти
 84   C45B FF FF FF... >           BLOCK 0C478h-$, 0FFh
 84   C45F             >         ENDIF
 84   C478             >         ORG 0C478h
 85   C478 C3 86 C3         jp  t_tapeReadError
 86   C47B
 87   C47B              ;---------------------------------------------------------------------------
 88   C47B              ; Константы и Переменные
 89   C47B              ;---------------------------------------------------------------------------
 90   C47B
 91   C47B              ; Начальные значения переменных хранятся здесь, и при сбросе
 92   C47B              ; копируются на адрес bios_vars (=8FDFh) функцией reboot1
 93   C47B FF FF 00 C8  initVars        BIOS_VARIABLES
 93   C47F FF FF FF FF
 93   C483 00 1C 21 00
 93   C487 FF BA FF FF
 93   C48B FF FF 5F 20
 93   C48F FF 20 E0 FF
 93   C493 FF 10 00 00
 93   C497 00 FF FF 28
 93   C49B 3C
 94   C49C              initVarsEnd:
 95   C49C
 96   C49C              ; Таблица кодов клавиш
 97   C49C              v_keybTbl:
 98   C49C 81 0C 19 1A      DB 81h, 0Ch, 19h, 1Ah, 09h, 1Bh, 20h, 08h, 80h, 18h, 0Ah, 0Dh, 0, 0, 0, 0
 98   C4A0 09 1B 20 08
 98   C4A4 80 18 0A 0D
 98   C4A8 00 00 00 00
 99   C4AC 71 7E 73 6D      DB 71h, 7Eh, 73h, 6Dh, 69h, 74h, 78h, 62h, 60h, 2Ch, 2Fh, 7Fh, 0, 0, 0, 0
 99   C4B0 69 74 78 62
 99   C4B4 60 2C 2F 7F
 99   C4B8 00 00 00 00
100   C4BC 66 79 77 61      DB 66h, 79h, 77h, 61h, 70h, 72h, 6Fh, 6Ch, 64h, 76h, 7Ch, 2Eh, 0, 0, 0, 0
100   C4C0 70 72 6F 6C
100   C4C4 64 76 7C 2E
100   C4C8 00 00 00 00
101   C4CC 6A 63 75 6B      DB 6Ah, 63h, 75h, 6Bh, 65h, 6Eh, 67h, 7Bh, 7Dh, 7Ah, 68h, 3Ah, 0, 0, 0, 0
101   C4D0 65 6E 67 7B
101   C4D4 7D 7A 68 3A
101   C4D8 00 00 00 00
102   C4DC 3B 31 32 33      DB 3Bh, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh, 0, 0, 0, 0
102   C4E0 34 35 36 37
102   C4E4 38 39 30 2D
102   C4E8 00 00 00 00
103   C4EC 00 01 02 03      DB 00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 8Ah, 8Bh, 8Ch, 1Fh, 0, 0, 0, 0
103   C4F0 04 05 06 07
103   C4F4 8A 8B 8C 1F
103   C4F8 00 00 00 00
104   C4FC
105   C4FC              ;---------------------------------------------------------------------------
106   C4FC              ; Код
107   C4FC              ;---------------------------------------------------------------------------
108   C4FC
109   C4FC                  ;ORG_PAD 0C500h
110   C4FC              	INCLUDE "printer.inc"
  1+  C4FC              ;+---------------------------------------------------------------------------
  2+  C4FC              ; MXOS
  3+  C4FC              ; Вывод байта на принтер
  4+  C4FC              ;
  5+  C4FC              ; На входе
  6+  C4FC              ;   c - байт
  7+  C4FC              ;
  8+  C4FC              ; На выходе
  9+  C4FC              ;   af, bc, de, hl - cохраняются
 10+  C4FC              ;
 11+  C4FC              ; 2013-12-12 Дизассемблировано vinxru
 12+  C4FC              ;----------------------------------------------------------------------------
 13+  C4FC
 14+  C4FC              printer:    ; Сохраняем регистры
 15+  C4FC F5                       push  af
 16+  C4FD
 17+  C4FD                          ; Режим порта расширения
 18+  C4FD 3E 90                    ld    a, 90h
 19+  C4FF 32 E7 FF                 ld    (IO_PROG_MODE), a
 20+  C502
 21+  C502                          ; Выводим байт на принтер
 22+  C502 79                       ld    a, c
 23+  C503 2F                       cpl
 24+  C504 32 E5 FF                 ld    (IO_PROG_B), a
 25+  C507
 26+  C507              printer_loop:     ; Выход     при нажатии любой клавиши
 27+  C507 3A E1 FF                 ld    a, (IO_KEYB_B)
 28+  C50A E6 02                    and   2
 29+  C50C CA 20 C5                 jp z, printer_ret
 30+  C50F
 31+  C50F                          ; Ждем пока принтер не будет готов
 32+  C50F 3A E4 FF                 ld    a, (IO_PROG_A)
 33+  C512 E6 40                    and   40h
 34+  C514 C2 07 C5                 jp nz,  printer_loop
 35+  C517
 36+  C517                          ; Строб
 37+  C517 3E 03                    ld    a, 3
 38+  C519 32 E6 FF                 ld    (IO_PROG_C), a
 39+  C51C AF                       xor   a
 40+  C51D 32 E6 FF                 ld    (IO_PROG_C), a
 41+  C520
 42+  C520              printer_ret:      ; Восстаналвиаем регистры
 43+  C520 F1                       pop   af
 44+  C521 C9                       ret
 45+  C522
111   C522              	INCLUDE "printString.inc"
  1+  C522              ;+---------------------------------------------------------------------------
  2+  C522              ; MXOS
  3+  C522              ; Вывод строки на экран
  4+  C522              ;
  5+  C522              ; На входе
  6+  C522              ;  hl - строка
  7+  C522              ;
  8+  C522              ; На выходе
  9+  C522              ;  af, bc, de - сохраняются
 10+  C522              ;
 11+  C522              ; 2013-12-12 Дизассемблировано vinxru
 12+  C522              ;----------------------------------------------------------------------------
 13+  C522
 14+  C522              printString:      ; Сохраняем регистры
 15+  C522 C5                       push  bc
 16+  C523 F5                       push  af
 17+  C524
 18+  C524              printString_1:    ; Читаем очередной байт
 19+  C524 7E                       ld  a, (hl)
 20+  C525
 21+  C525                          ; Если прочитан 0, выходим
 22+  C525 B7                       or    a
 23+  C526 CA 31 C5                 jp z, printString_2
 24+  C529
 25+  C529                          ; Выводим байт на экран
 26+  C529 4F                       ld    c, a
 27+  C52A CD 37 C0                 call  printChar
 28+  C52D
 29+  C52D                          ; Следующий байт
 30+  C52D 23                       inc   hl
 31+  C52E C3 24 C5                 jp    printString_1
 32+  C531
 33+  C531              ; ---------------------------------------------------------------------------
 34+  C531
 35+  C531              printString_2:    ; Восстанавливаем регистры
 36+  C531 F1                       pop   af
 37+  C532 C1                       pop   bc
 38+  C533 C9                       ret
 39+  C534
112   C534              	INCLUDE "reboot1.inc"
  1+  C534              ;+---------------------------------------------------------------------------
  2+  C534              ; MXOS
  3+  C534              ; Перезагрузка (продолжение)
  4+  C534              ;
  5+  C534              ; 2013-12-12 Дизассемблировано vinxru
  6+  C534              ;----------------------------------------------------------------------------
  7+  C534
  8+  C534              reboot1:    ; Для выключения звука
  9+  C534 3E 36                    ld    a, 36h
 10+  C536
 11+  C536                          ; Включаем ОЗУ
 12+  C536 32 FC FF                 ld    (IO_PAGE_RAM), a
 13+  C539
 14+  C539                          ; Выключаем звук
 15+  C539 32 EF FF                 ld    (IO_TIMER_MODE), a
 16+  C53C
 17+  C53C                          ; Инициализация переменных
 18+  C53C 21 7B C4                 ld    hl, initVars      ; Откуда
 19+  C53F 11 9C C4                 ld    de, initVarsEnd   ; Конец
 20+  C542 01 DF 8F                 ld    bc, bios_vars     ; Куда
 21+  C545 CD 2D C4                 call  memcpy_bc_hl
 22+  C548
 23+  C548                          ; Инициализация кэша fat
 24+  C548 CD 47 CC                 call  resetSectorCache
 25+  C54B
 26+  C54B                          ; Установка цвета
 27+  C54B                  IF ENABLE_COLOR
 28+  C54B 3E F0                    ld    a, COLOR_BIOS
 29+  C54D 32 F8 FF                 ld    (IO_COLOR), a
 30+  C550                  ELSE
 31+  C550 ~                        ld    a, 0Fh
 32+  C550 ~                        ld    (IO_KEYB_MODE), a
 33+  C550                  ENDIF
 34+  C550
 35+  C550                          ; Очищаем экран
 36+  C550 CD 10 C0                 call    clearScreen
 37+  C553
 38+  C553                  IF LOAD_FONT
 39+  C553              onceInitFont:
 40+  C553 C3 C3 D3                 jp    initFont
 41+  C556                  ELSE
 42+  C556 ~                        jp    reboot2
 43+  C556                  ENDIF
 44+  C556
113   C556              	INCLUDE "reboot2.inc"
  1+  C556              ;+---------------------------------------------------------------------------
  2+  C556              ; MXOS
  3+  C556              ; Перезагрузка (продолжение)
  4+  C556              ;
  5+  C556              ; 2013-12-12 Дизассемблировано vinxru
  6+  C556              ;----------------------------------------------------------------------------
  7+  C556
  8+  C556              reboot2:
  9+  C556
 10+  C556                  IF BOOT_FROM_TAPE
 11+  C556 ~                        ; Проверяем, нажата ли какая нибудь клавиша
 12+  C556 ~                        call    j_keyScan
 13+  C556 ~                        push    af
 14+  C556                  ENDIF
 15+  C556
 16+  C556                          ; Выводим версию ОС на экран
 17+  C556 21 24 D3                 ld      hl, txtBiosVer
 18+  C559 CD 38 C4                 call    printString1
 19+  C55C
 20+  C55C                          ; Определяем размер ДОЗУ
 21+  C55C 21 BB FF                 ld      hl, RAMD_PAGE_END
 22+  C55F 3A F8 8F                 ld      a, (bios_vars.ramPageCount)
 23+  C562 CD CB C7                 call    checkRAMD
 24+  C565
 25+  C565                          ; Выводим объем ДОЗУ на экран
 26+  C565 21 30 D3                 ld      hl, txtRAM
 27+  C568 CD 38 C4                 call    printString1
 28+  C56B
 29+  C56B                          ; Вычисляем объем ДОЗУ в байтах
 30+  C56B 3A F8 8F                 ld      a, (bios_vars.ramPageCount)
 31+  C56E 26 00                    ld      h, 0
 32+  C570 6F                       ld      l, a    ; hl = объём в страницах
 33+  C571 2C                       inc     l       ; +1 страница - основная память
 34+  C572 11 40 00                 ld      de, 64
 35+  C575 CD 3C D2                 call    mul_hl_de  ; hl = hl * 64
 36+  C578 EB                       ex      hl, de
 37+  C579 CD E9 D1                 call    printDecWord
 38+  C57C
 39+  C57C 21 37 D3                 ld      hl, txtKB
 40+  C57F CD 38 C4                 call    printString1
 41+  C582
 42+  C582                      IF BOOT_FROM_TAPE==0
 43+  C582
 44+  C582                          ; Продолжаем загрузку системы
 45+  C582 C3 00 C8                 jp      j_reboot3
 46+  C585
 47+  C585                      ELSE
 48+  C585 ~
 49+  C585 ~                        ; Если не нажата ни одна клавиша, продолжаем загрузку системы
 50+  C585 ~                        pop     af
 51+  C585 ~                        inc     a
 52+  C585 ~                        jp z,   j_reboot3
 53+  C585 ~
 54+  C585 ~                        ; Загружаем драйвер магнитофона
 55+  C585 ~                        ld      hl, aATape_com
 56+  C585 ~                        call    fileExec
 57+  C585 ~
 58+  C585 ~                        ; Загружаем программу с ленты (без контроля КС) и запускаем
 59+  C585 ~                        ld      hl, txtLoadingFromTape
 60+  C585 ~                        call    printString1
 61+  C585 ~                        call    t_tapeLoadInt
 62+  C585 ~                        ld      hl, (bios_vars.tapeAddr)
 63+  C585 ~                        jp      (hl)
 64+  C585 ~
 65+  C585                      ENDIF
 66+  C585
114   C585              	INCLUDE "getch3.inc"
  1+  C585              ;----------------------------------------------------------------------------
  2+  C585              ; MXOS
  3+  C585              ; Ожидание ввода с клавиатуры (продолжение)
  4+  C585              ;
  5+  C585              ; На выходе
  6+  C585              ;  ? - код
  7+  C585              ;
  8+  C585              ; 2013-12-12 Дизассемблировано vinxru
  9+  C585              ;----------------------------------------------------------------------------
 10+  C585
 11+  C585              getch3:     ; Если нажат лишь РУС/LAT - то обрабатываем его как CAPS LOCK,
 12+  C585                          ; если нажат Shit+РУС/LAT - то переключаем режим КОИ
 13+  C585 CD 49 C2                 call    setKeybMode91
 14+  C588 3E F8                    ld      a, 0F8h
 15+  C58A 32 E1 FF                 ld      (IO_KEYB_B), a
 16+  C58D 3A E0 FF                 ld      a, (IO_KEYB_A)
 17+  C590 F5                       push    af
 18+  C591 CD 43 C2                 call    setKeybMode82
 19+  C594 F1                       pop     af
 20+  C595 E6 08                    and     8
 21+  C597 C2 B1 C5                 jp nz,  getch_capsLock
 22+  C59A
 23+  C59A                          ; Меняем KOI-7 / KOI-8
 24+  C59A 3A EA 8F                 ld      a, (bios_vars.koi7)
 25+  C59D 2F                       cpl
 26+  C59E 32 EA 8F                 ld      (bios_vars.koi7), a
 27+  C5A1
 28+  C5A1                          ;ld      a, 3Ah  ; включаем прописные английские
 29+  C5A1 3E BA                    ld      a, 0BAh  ; включаем строчные английские
 30+  C5A3 32 EC 8F                 ld      (bios_vars.keyLocks), a
 31+  C5A6
 32+  C5A6                          ; Звуковой сигнал
 33+  C5A6 CD 70 C1                 call    beep
 34+  C5A9
 35+  C5A9                          ; Меняем частоту
 36+  C5A9 3E 5F                    ld      a, 5Fh
 37+  C5AB 32 F1 8F                 ld      (bios_vars.beepFreq),a
 38+  C5AE
 39+  C5AE C3 18 C2                 jp      getch_retry
 40+  C5B1
 41+  C5B1              ; ---------------------------------------------------------------------------
 42+  C5B1              ; CAPS LOCK для KOI-7
 43+  C5B1
 44+  C5B1              getch_capsLock:
 45+  C5B1                          ; Переключаем capsLock
 46+  C5B1 3A EC 8F                 ld      a, (bios_vars.keyLocks)
 47+  C5B4 EE 80                    xor     80h
 48+  C5B6 32 EC 8F                 ld      (bios_vars.keyLocks), a
 49+  C5B9
 50+  C5B9                          ; Меняем частоту
 51+  C5B9 3A F1 8F                 ld      a, (bios_vars.beepFreq)
 52+  C5BC EE 10                    xor     10h
 53+  C5BE 32 F1 8F                 ld      (bios_vars.beepFreq),a
 54+  C5C1
 55+  C5C1                          ; Чтобы был двойной звуковой сигнал, на строй и новой частоте
 56+  C5C1 CD 70 C1                 call    beep
 57+  C5C4
 58+  C5C4                          ; Ждем следующую клавишу
 59+  C5C4 C3 18 C2                 jp      getch_retry
 60+  C5C7
 61+  C5C7              ; ---------------------------------------------------------------------------
 62+  C5C7              ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
 63+  C5C7
 64+  C5C7              getch_rc:   ; В режиме KOI-8 мы переключаем кодировку
 65+  C5C7 3A EA 8F                 ld    a, (bios_vars.koi7)
 66+  C5CA 3C                       inc   a
 67+  C5CB
 68+  C5CB 3A EC 8F                 ld    a, (bios_vars.keyLocks) ; Требуется в getch_RusLat
 69+  C5CE C2 AA C2                 jp nz,  getch_RusLat
 70+  C5D1
 71+  C5D1                          ; В режиме KOI-7 мы перключаем регистр
 72+  C5D1 C3 B1 C5                 jp    getch_capsLock
 73+  C5D4
 74+  C5D4              ; ---------------------------------------------------------------------------
 75+  C5D4
 76+  C5D4              loc_C5A8:   ; Включен KOI-7
 77+  C5D4 47                       ld    b, a
 78+  C5D5
 79+  C5D5 3A E1 FF                 ld    a, (IO_KEYB_B)
 80+  C5D8 E6 02                    and   2
 81+  C5DA C2 FD C2                 jp nz,  loc_C311
 82+  C5DD
 83+  C5DD 3E A0                    ld    a, 0A0h
 84+  C5DF A8                       xor   b
 85+  C5E0 47                       ld    b, a
 86+  C5E1
 87+  C5E1 C3 FD C2                 jp    loc_C311
 88+  C5E4
115   C5E4              	INCLUDE "printChar2.inc"	; Продолжается в scrollDown
  1+  C5E4              ;+---------------------------------------------------------------------------
  2+  C5E4              ; MXOS
  3+  C5E4              ; Вывод символа на экран (или принтер)
  4+  C5E4              ;
  5+  C5E4              ; На входе
  6+  C5E4              ;  с - символ
  7+  C5E4              ;
  8+  C5E4              ; На выходе
  9+  C5E4              ;  регистры не сохраняются
 10+  C5E4              ;
 11+  C5E4              ; 2013-12-12 Дизассемблировано vinxru
 12+  C5E4              ;----------------------------------------------------------------------------
 13+  C5E4
 14+  C5E4              printChar2:
 15+  C5E4                          ; Помещаем в hl координаты курсора
 16+  C5E4 2A FC 8F                 ld  hl, (bios_vars.cursorY)
 17+  C5E7
 18+  C5E7                          ; Продолжаем, если не включен режим обработки ESC последовательности (bios_vars.escMode==0FFh)
 19+  C5E7 3A EB 8F                 ld  a, (bios_vars.escMode)
 20+  C5EA 3C                       inc a
 21+  C5EB C2 89 C6                 jp  nz,  printChar_esc
 22+  C5EE
 23+  C5EE                          ; Тут bios_vars.escMode==0FFh
 24+  C5EE
 25+  C5EE                          ; Если это печатные символы (>=20h), переходим к печати
 26+  C5EE 79                       ld  a, c
 27+  C5EF FE 20                    cp  ' '
 28+  C5F1 D2 03 C6                 jp  nc, printChar_real
 29+  C5F4
 30+  C5F4                          ; Это табуляция
 31+  C5F4 FE 09                    cp  9
 32+  C5F6 CA 50 C0                 jp  z, printChar_c9      ; там bios_vars.cursorX+=24 и ret
 33+  C5F9
 34+  C5F9                          ; Любой символ кроме ESC
 35+  C5F9 FE 1B                    cp  1Bh
 36+  C5FB C2 1C C1                 jp  nz, printChar3
 37+  C5FE
 38+  C5FE                          ; Далее ESC. Включаем режим обработки ESC последовательности (bios_vars.escMode=0)
 39+  C5FE AF                       xor a
 40+  C5FF 32 EB 8F                 ld  (bios_vars.escMode),a
 41+  C602 C9                       ret
 42+  C603
 43+  C603              ; ---------------------------------------------------------------------------
 44+  C603              ; Преобразование символа из KOI-7 в KOI-8 и вывод на экран (служебные коды
 45+  C603              ; также будут выводится)
 46+  C603
 47+  C603              printChar_real:
 48+  C603                          ; Символ для печати
 49+  C603 4F                       ld  c, a
 50+  C604
 51+  C604                          ; Переходим к печати, если включен режим KOI-8 (bios_vars.koi7 == 0)
 52+  C604 3A EA 8F                 ld  a, (bios_vars.koi7)
 53+  C607 3C                       inc a
 54+  C608 C2 1C C6                 jp  nz, printChar_real2
 55+  C60B
 56+  C60B                          ; Включен режим KOI-7 (bios_vars.koi7 == 0FFh), надо
 57+  C60B                          ; перекодировать символы для знакогнератора.
 58+  C60B
 59+  C60B                          ; Если символ больше или равен 0C0h просто выходим
 60+  C60B 79                       ld  a, c
 61+  C60C FE C0                    cp  0C0h
 62+  C60E D0                       ret nc
 63+  C60F
 64+  C60F                          ; Если символ находится в пределах 60h ... 7Fh, увеличиваем его код на 80h
 65+  C60F FE 60                    cp  60h
 66+  C611 DA 1C C6                 jp  c, printChar_real2
 67+  C614 FE 80                    cp  80h
 68+  C616 D2 1C C6                 jp  nc,  printChar_real2
 69+  C619 C6 80                    add a, 80h
 70+  C61B 4F                       ld  c, a
 71+  C61C
 72+  C61C              ; ---------------------------------------------------------------------------
 73+  C61C              ; Вывод символа на экран в KOI-8 (служебные коды так же будут выводится)
 74+  C61C
 75+  C61C              printChar_real2:
 76+  C61C                          ; Тут полиморфизм
 77+  C61C 3A FA 8F                 ld    a, (bios_vars.inverse)
 78+  C61F A7                       and   a
 79+  C620
 80+  C620              printChar_poly:
 81+  C620 CC E6 C0                 call z, normalVideo
 82+  C623
 83+  C623                          ; Если bios_vars.charGen не равен 0FFFFh, то используется знакогнератор по адресу bios_vars.charGen*8
 84+  C623 2A E7 8F                 ld    hl, (bios_vars.charGen)
 85+  C626 7C                       ld    a, h
 86+  C627 3C                       inc   a
 87+  C628 C2 59 C0                 jp nz,  printChar_alt
 88+  C62B 7D                       ld    a, l
 89+  C62C 3C                       inc   a
 90+  C62D C2 59 C0                 jp nz,  printChar_alt
 91+  C630
 92+  C630                          ; Иначе используем символы из ПЗУ.
 93+  C630                          ; Адрес символа в ПЗУ (de = 0x800 + c*8)
 94+  C630 21 00 01                 ld    hl, 100h
 95+  C633 06 00                    ld    b,  0
 96+  C635 09                       add   hl, bc
 97+  C636 29                       add   hl, hl
 98+  C637 29                       add   hl, hl
 99+  C638 29                       add   hl, hl
100+  C639 EB                       ex    de, hl
101+  C63A
102+  C63A                          ; Промежуточное место для символа
103+  C63A 21 B6 D3                 ld    hl, v_char
104+  C63D E5                       push  hl
105+  C63E
106+  C63E                          ; Копируем 8 байт из ПЗУ
107+  C63E 32 FE FF                 ld    (IO_PAGE_ROM),a
108+  C641 1A                       ld    a, (de)
109+  C642 77                       ld    (hl), a
110+  C643 23                       inc   hl
111+  C644 13                       inc   de
112+  C645 1A                       ld    a, (de)
113+  C646 77                       ld    (hl), a
114+  C647 23                       inc   hl
115+  C648 13                       inc   de
116+  C649 1A                       ld    a, (de)
117+  C64A 77                       ld    (hl), a
118+  C64B 23                       inc   hl
119+  C64C 13                       inc   de
120+  C64D 1A                       ld    a, (de)
121+  C64E 77                       ld    (hl), a
122+  C64F 23                       inc   hl
123+  C650 13                       inc   de
124+  C651 1A                       ld    a, (de)
125+  C652 77                       ld    (hl), a
126+  C653 23                       inc   hl
127+  C654 13                       inc   de
128+  C655 1A                       ld    a, (de)
129+  C656 77                       ld    (hl), a
130+  C657 23                       inc   hl
131+  C658 13                       inc   de
132+  C659 1A                       ld    a, (de)
133+  C65A 77                       ld    (hl), a
134+  C65B 23                       inc   hl
135+  C65C 13                       inc   de
136+  C65D 1A                       ld    a, (de)
137+  C65E 77                       ld    (hl), a
138+  C65F 32 FC FF                 ld    (IO_PAGE_RAM),a
139+  C662
140+  C662                          ; Вывод символа
141+  C662 D1                       pop   de
142+  C663 C3 60 C0                 jp    printChar_de
143+  C666
144+  C666              ; ---------------------------------------------------------------------------
145+  C666              ; Обработка режима ESC+F
146+  C666
147+  C666              printChar_esc80:; Если символ с кодом 0, выключаем режим обработки ESC
148+  C666 79                       ld    a, c
149+  C667 B7                       or    a
150+  C668 CA 84 C6                 jp z, printChar_esc80_exit
151+  C66B
152+  C66B                          ; Обработка кодов < 20h
153+  C66B FE 20                    cp    20h
154+  C66D DA 1C C1                 jp c, printChar3
155+  C670
156+  C670                          ; Если код >= 80h, выйти
157+  C670 FE 80                    cp    80h
158+  C672 D0                       ret nc
159+  C673
160+  C673                          ; Если c >= 40h, вывести на экран c+40h
161+  C673 FE 40                    cp    40h
162+  C675 D2 7E C6                 jp nc,  printChar_esc80_2
163+  C678
164+  C678                          ; Иначе вывести c - 20h
165+  C678 D6 20                    sub   20h ; ' '
166+  C67A 4F                       ld    c, a
167+  C67B C3 1C C6                 jp    printChar_real2
168+  C67E
169+  C67E              ; ---------------------------------------------------------------------------
170+  C67E
171+  C67E              printChar_esc80_2:
172+  C67E                          ; Если c >= 40h, вывести на экран c+40h
173+  C67E C6 40                    add   a,40h
174+  C680 4F                       ld    c, a
175+  C681 C3 1C C6                 jp    printChar_real2
176+  C684
177+  C684              ; ---------------------------------------------------------------------------
178+  C684
179+  C684              printChar_esc80_exit:
180+  C684 3D                       dec   a
181+  C685 32 EB 8F                 ld    (bios_vars.escMode),a
182+  C688 C9                       ret
183+  C689
184+  C689              ; ---------------------------------------------------------------------------
185+  C689              ; Печать символа в ESC-режиме
186+  C689
187+  C689              printChar_esc:    ; Перейти если bios_vars.escMode=80h
188+  C689 3A EB 8F                 ld    a, (bios_vars.escMode)
189+  C68C FE 80                    cp    80h
190+  C68E CA 66 C6                 jp z, printChar_esc80
191+  C691
192+  C691                          ; Выключить режим обработки ESC последовательности
193+  C691 F5                       push  af
194+  C692 3E FF                    ld    a, 0FFh
195+  C694 32 EB 8F                 ld    (bios_vars.escMode),a
196+  C697 F1                       pop   af
197+  C698
198+  C698                          ; Перейти если bios_vars.escMode==0
199+  C698 B7                       or    a
200+  C699 CA D3 C6                 jp z, printChar_esc0
201+  C69C
202+  C69C                          ; Перейти если обработка ESC+Y (bios_vars.escMode==1)
203+  C69C 3D                       dec   a
204+  C69D CA A9 C6                 jp z, printChar_esc1
205+  C6A0
206+  C6A0                          ; Перейти если bios_vars.escMode==2
207+  C6A0 3D                       dec   a
208+  C6A1 CA C5 C6                 jp z, printChar_esc2
209+  C6A4
210+  C6A4                          ; Перейти если bios_vars.escMode==3
211+  C6A4 3D                       dec   a
212+  C6A5 CA 39 C7                 jp z, printChar_esc3
213+  C6A8
214+  C6A8                          ; Выйти
215+  C6A8 C9                       ret
216+  C6A9
217+  C6A9              ; ---------------------------------------------------------------------------
218+  C6A9              ; Обработка ESC+Y
219+  C6A9
220+  C6A9              printChar_esc1:   ; Если код меньше 20h или больше 20h + 24, то пропускаем установку Y
221+  C6A9 79                       ld    a, c
222+  C6AA FE 39                    cp    20h + 25
223+  C6AC D2 BF C6                 jp nc,  loc_C693
224+  C6AF D6 20                    sub   20h
225+  C6B1 DA BF C6                 jp c, loc_C693
226+  C6B4
227+  C6B4                          ; cursorY = 8 + a*10
228+  C6B4 87                       add   a, a
229+  C6B5 4F                       ld    c, a
230+  C6B6 81                       add   a, c
231+  C6B7 81                       add   a, c
232+  C6B8 81                       add   a, c
233+  C6B9 81                       add   a, c
234+  C6BA C6 08                    add   a,8
235+  C6BC 32 FC 8F                 ld    (bios_vars.cursorY),a
236+  C6BF
237+  C6BF              loc_C693:   ; Следующий символ будет обработан в printChar_esc2
238+  C6BF 3E 02                    ld    a, 2
239+  C6C1 32 EB 8F                 ld    (bios_vars.escMode),a
240+  C6C4 C9                       ret
241+  C6C5
242+  C6C5              ; ---------------------------------------------------------------------------
243+  C6C5              ; Обработка ESC+Y
244+  C6C5
245+  C6C5              printChar_esc2:   ; Если код меньше 20h или больше 20h + 63, то пропускаем установку X
246+  C6C5 79                       ld    a, c
247+  C6C6 FE 60                    cp    60h
248+  C6C8 D0                       ret nc
249+  C6C9 D6 20                    sub   20h
250+  C6CB D8                       ret c
251+  C6CC
252+  C6CC                          ; cursorX = c*3;
253+  C6CC 4F                       ld    c, a
254+  C6CD 87                       add   a, a
255+  C6CE 81                       add   a, c
256+  C6CF 32 FD 8F                 ld    (bios_vars.cursorX),a
257+  C6D2 C9                       ret
258+  C6D3
259+  C6D3              ; ---------------------------------------------------------------------------
260+  C6D3              ; Обработка первого символа ESC последовательности
261+  C6D3
262+  C6D3              printChar_esc0:   ; Если код больше 20h
263+  C6D3 79                       ld    a, c
264+  C6D4 FE 28                    cp    '(' ; 28h
265+  C6D6 CA 45 C0                 jp z, printChar_e28
266+  C6D9 FE 29                    cp    ')' ; 29h
267+  C6DB CA 4B C0                 jp z, printChar_e29
268+  C6DE FE 50                    cp    'P' ; 50h
269+  C6E0 CA 29 C7                 jp z, printChar_eP
270+  C6E3 D6 41                    sub   'A' ; 41h
271+  C6E5 CA 2F C7                 jp z, printChar19
272+  C6E8 3D                       dec   a ; 'b' 42h
273+  C6E9 CA 34 C7                 jp z, printChar1A
274+  C6EC 3D                       dec   a ; 'c' 43h
275+  C6ED CA 15 C7                 jp z, printChar18
276+  C6F0 3D                       dec   a ; 'd' 44h
277+  C6F1 CA 1A C7                 jp z, printChar08
278+  C6F4 3D                       dec   a ; 'e' 45h
279+  C6F5 CA 1F C7                 jp z, printChar1F
280+  C6F8 3D                       dec   a ; 'F' 46h
281+  C6F9 CA 3B C4                 jp z, printChar_eF
282+  C6FC 3D                       dec   a
283+  C6FD 3D                       dec   a ; 'h' 48h
284+  C6FE CA 24 C7                 jp z, printChar0C
285+  C701 3D                       dec   a ; 'I' 49h
286+  C702 CA 53 C7                 jp z, printChar_eI
287+  C705 3D                       dec   a
288+  C706 3D                       dec   a
289+  C707 D6 0E                    sub   14 ; 'Y' 59h
290+  C709 CA 0F C7                 jp z, setEscMode_eY
291+  C70C
292+  C70C                          ; Вывод символа
293+  C70C C3 E4 C5                 jp    printChar2
294+  C70F
295+  C70F              ; ---------------------------------------------------------------------------
296+  C70F              ; Обработка ESC+Y.
297+  C70F
298+  C70F              setEscMode_eY:    ; Следующий символ будет обработан в printChar_esc1
299+  C70F 3E 01                    ld    a, 1
300+  C711 32 EB 8F                 ld    (bios_vars.escMode),a
301+  C714 C9                       ret
302+  C715
303+  C715              ; ---------------------------------------------------------------------------
304+  C715
305+  C715              printChar18:
306+  C715 0E 18                    ld    c, 18h
307+  C717 C3 E4 C5                 jp    printChar2
308+  C71A
309+  C71A              ; ---------------------------------------------------------------------------
310+  C71A
311+  C71A              printChar08:
312+  C71A 0E 08                    ld    c, 8
313+  C71C C3 E4 C5                 jp    printChar2
314+  C71F
315+  C71F              ; ---------------------------------------------------------------------------
316+  C71F
317+  C71F 0E 1F        printChar1F:      ld    c, 1Fh
318+  C721 C3 E4 C5                 jp    printChar2
319+  C724
320+  C724              ; ---------------------------------------------------------------------------
321+  C724
322+  C724              printChar0C:
323+  C724 0E 0C                    ld    c, 0Ch
324+  C726 C3 E4 C5                 jp    printChar2
325+  C729
326+  C729              ; ---------------------------------------------------------------------------
327+  C729              ; Обработка ESP+P. Вклчюение режима эхопечати на принтере
328+  C729
329+  C729              printChar_eP:
330+  C729 3E 03                    ld    a, 3
331+  C72B 32 EB 8F                 ld    (bios_vars.escMode),a
332+  C72E C9                       ret
333+  C72F
334+  C72F              ; ---------------------------------------------------------------------------
335+  C72F
336+  C72F              printChar19:
337+  C72F 0E 19                    ld    c, 19h
338+  C731 C3 E4 C5                 jp    printChar2
339+  C734
340+  C734              ; ---------------------------------------------------------------------------
341+  C734
342+  C734              printChar1A:
343+  C734 0E 1A                    ld    c, 1Ah
344+  C736 C3 E4 C5                 jp    printChar2
345+  C739
346+  C739              ; ---------------------------------------------------------------------------
347+  C739              ; Режим эхопечати на принтере. Включается ESC+P
348+  C739
349+  C739              printChar_esc3:
350+  C739                          ; Выходим, из режима, если код нулевой
351+  C739 79                       ld    a, c
352+  C73A B7                       or    a
353+  C73B C8                       ret z
354+  C73C
355+  C73C                          ; Печать на принтере
356+  C73C CD FC C4                 call  printer
357+  C73F
358+  C73F                          ; Печать на экране
359+  C73F CD E4 C5                 call  printChar2
360+  C742
361+  C742                          ; Находимся в этом режиме до кода 0 или ESC
362+  C742 3E 03                    ld    a, 3
363+  C744 32 EB 8F                 ld    (bios_vars.escMode),a
364+  C747 C9                       ret
365+  C748
366+  C748              ; ---------------------------------------------------------------------------
367+  C748              ; Продолжение обработки ESC+I. Перемещение курсора вверх с прокруткой экрана
368+  C748
369+  C748              printChar_eI_2:
370+  C748                          ; Если cursorY > 18, перемещаем курсор вверх и выходим
371+  C748 FE 13                    cp    19
372+  C74A D2 E4 C5                 jp nc,  printChar2
373+  C74D
374+  C74D                          ; Устанаваливаем bios_vars.cursorY=8
375+  C74D 3E 08                    ld    a, 8
376+  C74F 32 FC 8F                 ld    (bios_vars.cursorY),a
377+  C752 C9                       ret
378+  C753
379+  C753              ; ---------------------------------------------------------------------------
380+  C753              ; Обработка ESC+I. Перемещение курсора вверх с прокруткой экрана
381+  C753
382+  C753              printChar_eI:
383+  C753                          ; Используется дальше функцией printChar2
384+  C753 0E 19                    ld    c, 19h
385+  C755
386+  C755                          ; Прокручиваем экран вних, только если bios_vars.cursorY == 8.
387+  C755                          ; иначе переходим на printChar_eI_2
388+  C755 3A FC 8F                 ld    a, (bios_vars.cursorY)
389+  C758 FE 08                    cp    8
390+  C75A C2 48 C7                 jp nz,  printChar_eI_2
391+  C75D
116   C75D              	INCLUDE "scrollDown.inc"
  1+  C75D              ;+---------------------------------------------------------------------------
  2+  C75D              ; MXOS
  3+  C75D              ; Прокрутка экрана вниз
  4+  C75D              ;
  5+  C75D              ; На выходе
  6+  C75D              ;   af, bc - сохраняются
  7+  C75D              ;
  8+  C75D              ; 2013-12-12 Дизассемблировано vinxru
  9+  C75D              ;----------------------------------------------------------------------------
 10+  C75D
 11+  C75D                          ; Сохраняем регистры
 12+  C75D C5                       push    bc
 13+  C75E F5                       push    af
 14+  C75F 21 00 00                 ld      hl, 0
 15+  C762 39                       add     hl,sp
 16+  C763 22 F6 8F                 ld      (bios_vars.oldSP), hl
 17+  C766
 18+  C766                          ; Подготовка переменных
 19+  C766 31 00 C0                 ld      sp, 0C000h    ; Куда
 20+  C769 26 BF                    ld      h, 0BFh       ; Откуда
 21+  C76B 06 30                    ld      b, 48         ; Столбцов
 22+  C76D 0E 29        loc_C741:   ld      c, 246 / 6    ; 246 строк
 23+  C76F 2E F5                    ld      l, 245        ; Начинаем с 245 строки
 24+  C771
 25+  C771              loc_C745:   ; Копируем 6 байт из hl в sp
 26+  C771 56                       ld      d, (hl)
 27+  C772 2B                       dec     hl
 28+  C773 5E                       ld      e, (hl)
 29+  C774 2B                       dec     hl
 30+  C775 D5                       push    de
 31+  C776 56                       ld      d, (hl)
 32+  C777 2B                       dec     hl
 33+  C778 5E                       ld      e, (hl)
 34+  C779 2B                       dec     hl
 35+  C77A D5                       push    de
 36+  C77B 56                       ld      d, (hl)
 37+  C77C 2B                       dec     hl
 38+  C77D 5E                       ld      e, (hl)
 39+  C77E 2B                       dec     hl
 40+  C77F D5                       push    de
 41+  C780
 42+  C780                          ; Цикл
 43+  C780 0D                       dec     c
 44+  C781 C2 71 C7                 jp nz,  loc_C745
 45+  C784
 46+  C784                          ; Сохраняем h
 47+  C784 7C                       ld      a, h
 48+  C785
 49+  C785                          ; Очищаем верхние 10 строк
 50+  C785 2A FA 8F                 ld      hl, (bios_vars.inverse)
 51+  C788 E5                       push    hl
 52+  C789 E5                       push    hl
 53+  C78A E5                       push    hl
 54+  C78B E5                       push    hl
 55+  C78C E5                       push    hl
 56+  C78D
 57+  C78D                          ; Восстанавливаем h
 58+  C78D 67                       ld      h, a
 59+  C78E
 60+  C78E                          ; Следующий столбец
 61+  C78E 05                       dec     b
 62+  C78F C2 6D C7                 jp nz,  loc_C741
 63+  C792
 64+  C792                          ; Восстанавлиаем регистры и выходим
 65+  C792 2A F6 8F                 ld      hl, (bios_vars.oldSP)
 66+  C795 F9                       ld      sp, hl
 67+  C796 F1                       pop     af
 68+  C797 C1                       pop     bc
 69+  C798 C9                       ret
 70+  C799
117   C799              	INCLUDE "scrollUp2.inc"
  1+  C799              ;+---------------------------------------------------------------------------
  2+  C799              ; MXOS
  3+  C799              ; Прокрутка экрана вверх (продолжение)
  4+  C799              ;
  5+  C799              ; 2013-12-12 Дизассемблировано vinxru
  6+  C799              ;----------------------------------------------------------------------------
  7+  C799
  8+  C799              scrollUp2:  ; Копируем 246 байт из sp в H0
  9+  C799 0E 29                    ld    c, 246 / 6
 10+  C79B 2E 00                    ld    l, 0
 11+  C79D
 12+  C79D              scrollUp2_0:      ; Копирование 6 байт из sp в hl
 13+  C79D D1                       pop   de
 14+  C79E 73                       ld  (hl), e
 15+  C79F 23                       inc   hl
 16+  C7A0 72                       ld  (hl), d
 17+  C7A1 23                       inc   hl
 18+  C7A2 D1                       pop   de
 19+  C7A3 73                       ld  (hl), e
 20+  C7A4 23                       inc   hl
 21+  C7A5 72                       ld  (hl), d
 22+  C7A6 23                       inc   hl
 23+  C7A7 D1                       pop   de
 24+  C7A8 73                       ld  (hl), e
 25+  C7A9 23                       inc   hl
 26+  C7AA 72                       ld  (hl), d
 27+  C7AB 23                       inc   hl
 28+  C7AC
 29+  C7AC                          ; Цикл
 30+  C7AC 0D                       dec   c
 31+  C7AD C2 9D C7                 jp nz,  scrollUp2_0
 32+  C7B0
 33+  C7B0                          ; Сохраняем h
 34+  C7B0 7C                       ld    a, h
 35+  C7B1
 36+  C7B1                          ; Заполняем 10 байт
 37+  C7B1 2A FA 8F                 ld    hl, (bios_vars.inverse)
 38+  C7B4 E5                       push  hl
 39+  C7B5 E5                       push  hl
 40+  C7B6 E5                       push  hl
 41+  C7B7 E5                       push  hl
 42+  C7B8 E5                       push  hl
 43+  C7B9
 44+  C7B9                          ; Следующий столбец (sp += 20)
 45+  C7B9 21 14 00                 ld    hl, 14h
 46+  C7BC 39                       add   hl,sp
 47+  C7BD F9                       ld    sp, hl
 48+  C7BE
 49+  C7BE                          ; Восстанавливаем h
 50+  C7BE 67                       ld    h, a
 51+  C7BF
 52+  C7BF                          ; Следующий столбец
 53+  C7BF 24                       inc   h
 54+  C7C0
 55+  C7C0                          ; Цикл
 56+  C7C0 05                       dec   b
 57+  C7C1 C2 99 C7                 jp nz,  scrollUp2
 58+  C7C4
 59+  C7C4                          ; Восстановление регистров и выход
 60+  C7C4 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 61+  C7C7 F9                       ld    sp, hl
 62+  C7C8 F1                       pop   af
 63+  C7C9 C1                       pop   bc
 64+  C7CA C9                       ret
 65+  C7CB
118   C7CB              	INCLUDE "checkRAMD.inc"
  1+  C7CB              ;+---------------------------------------------------------------------------
  2+  C7CB              ; MXOS
  3+  C7CB              ; Исправленная функция определения размера ДОЗУ
  4+  C7CB              ; Заимствовано из RAMFOS
  5+  C7CB              ;
  6+  C7CB              ; На входе
  7+  C7CB              ;  а  = максимальный номер страницы, константа MAX_ARAM_PAGE
  8+  C7CB              ;  hl = адрес в странице ДОЗУ для записи тестового байта
  9+  C7CB              ;
 10+  C7CB              ; На выходе
 11+  C7CB              ;  bios_vars.ramPageCount = максимальный номер страницы
 12+  C7CB              ;  NZ - ДОЗУ найдено (наоборот относительно стандратной функции Ramfos)
 13+  C7CB              ;   Z - ДОЗУ не найдено
 14+  C7CB              ;
 15+  C7CB              ; 2013-11-01 Разработано vinxru
 16+  C7CB              ; 2022-02-02 Доработано SpaceEnigneer
 17+  C7CB              ;----------------------------------------------------------------------------
 18+  C7CB
 19+  C7CB              checkRAMD:  ; Устанавливаем побайтовый драйвер.
 20+  C7CB                          ; Восстанавливать блочный драйвер не надо,
 21+  C7CB                          ; т.к. он будет установлен в reboot3
 22+  C7CB 06 01                    ld      b, 1
 23+  C7CD CD 8E CA                 call    setRAMDDriver
 24+  C7D0
 25+  C7D0                          ; Записываем во все страницы порядковые номера от большей к меньшей
 26+  C7D0              checkRAMD_0:
 27+  C7D0 4F                       ld      c, a
 28+  C7D1 0C                       inc     c
 29+  C7D2 CD D0 FF                 call    bios_RAMDWrite
 30+  C7D5 3D                       dec     a
 31+  C7D6 F2 D0 C7                 jp p,   checkRAMD_0
 32+  C7D9
 33+  C7D9                          ; Читаем номера. Если номер прочитан корректно, значит есть такая страница
 34+  C7D9                          ; a = -1
 35+  C7D9
 36+  C7D9              checkRAMD_1:
 37+  C7D9                          ; Читаем следующую страницу
 38+  C7D9 3C                       inc     a
 39+  C7DA CD C0 FF                 call    bios_RAMDRead
 40+  C7DD
 41+  C7DD                           ; Должен быть записан номер страницы + 1, если нет, то выходим
 42+  C7DD 0D                       dec     c
 43+  C7DE B9                       cp      c
 44+  C7DF C2 EC C7                 jp nz,  checkRAMD_2
 45+  C7E2
 46+  C7E2                          ; Сохраняем номер последней страницы + 1
 47+  C7E2 3C                       inc     a
 48+  C7E3 32 F8 8F                 ld      (bios_vars.ramPageCount), a
 49+  C7E6 3D                       dec     a
 50+  C7E7
 51+  C7E7                          ; Это максимум, выходим
 52+  C7E7 FE 10                    cp      RAMD_MAX_PAGE          ; RAMD_MAX_PAGE не может быть нулем!
 53+  C7E9 C2 D9 C7                 jp nz,  checkRAMD_1
 54+  C7EC
 55+  C7EC              checkRAMD_2:
 56+  C7EC                          ; Если ДОЗУ найдено, выходим c флагом NZ
 57+  C7EC B7                       or      a
 58+  C7ED C0                       ret nz
 59+  C7EE
 60+  C7EE                          ; В случае ошибки заносим в ramPageCount ноль и выходим с флагом Z
 61+  C7EE 32 F8 8F                 ld      (bios_vars.ramPageCount), a
 62+  C7F1 C9                       ret
 63+  C7F2
119   C7F2
120   C7F2                  ; тут есть место 17 байт
121   C7F2
122   C7F2              ;---------------------------------------------------------------------------
123   C7F2              ; Точки входа 0C800h
124   C7F2              ;---------------------------------------------------------------------------
125   C7F2
126   C7F2              	ORG_PAD 0C800h
126   C7F2             >         IF $ > 0C800h
126   C7F2 ~           >           ; вывод сообщения об ошибке
126   C7F2 ~           >           ASSERT 0
126   C7F2 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
126   C7F2             >         ELSE
126   C7F2             >           ; заполнение памяти
126   C7F2 FF FF FF... >           BLOCK 0C800h-$, 0FFh
126   C7F6             >         ENDIF
126   C800             >         ORG 0C800h
127   C800              	INCLUDE "jmps_c800.inc"
  1+  C800              ;+---------------------------------------------------------------------------
  2+  C800              ; MXOS
  3+  C800              ; Стандартные точки входа C800
  4+  C800              ;
  5+  C800              ; 2013-12-12 Дизассемблировано vinxru
  6+  C800              ;---------------------------------------------------------------------------
  7+  C800
  8+  C800 C3 7B C9     j_reboot3:      jp  reboot3             ; C800: Запустить NC.COM
  9+  C803 C3 37 C3     j_getch:        jp  getch               ; C803: Ожидание ввода с клавиатуры
 10+  C806 C3 77 C3     j_tapeRead:     jp  t_tapeRead          ; C806: Чтение байта с магнитофона
 11+  C809 C3 37 C0     j_printChar:    jp  printChar           ; C809: Вывод символа на экран
 12+  C80C C3 7A C3     j_tapeWrite:    jp  t_tapeWrite         ; C80C: Запись байта на магнитофон
 13+  C80F C3 CC C8                     jp  input               ; C80F: Ввод строки с клавиатуры
 14+  C812 C3 03 C0                     jp  j_keyScan           ; C812: Получить код нажатой клавиши
 15+  C815 C3 AC C8                     jp  printHexByte        ; C815: Вывести 16-ричное число (байт)
 16+  C818 C3 38 C4     j_printString:  jp  printString1        ; C818: Вывести строку на экран
 17+  C81B C3 03 C0                     jp  j_keyScan           ; C81B: Получить код нажатой клавиши
 18+  C81E C3 8D C8                     jp  getCursorPos        ; C81E: Получить координаты курсора в hl (координаты в пикселях)
 19+  C821 C3 8A C8                     jp  setCursorPos        ; C821: Установить координаты курсора из hl (координаты в пикселях)
 20+  C824 C3 7D C3                     jp  t_tapeLoad          ; C824: Загрузить программу с магнитофона
 21+  C827 C3 80 C3                     jp  t_tapeSave          ; C827: Сохранить программу на магнитофон
 22+  C82A C3 64 C9                     jp  calcCS              ; C82A: Расчет контрольной суммы
 23+  C82D C3 A1 C8                     jp  printHexWord        ; C82D: Вывести 16-ричное число (слово)
 24+  C830 C3 9D C8                     jp  getMemTop           ; C830: Получить объем доступной памяти
 25+  C833 C3 91 C8                     jp  setMemTop           ; C833: Установить объем доступной памяти
 26+  C836 C3 FC C4                     jp  printer             ; C836: Напечатать байт на принтере
 27+  C839                  IF RAMFOS_COMPATIBILITY
 28+  C839 C3 D3 C3                     jp  strToHex            ; C839: [MXOS2] Преобразвоние строки в HEX формате в число
 29+  C83C                  ELSE
 30+  C83C ~                            jp  j_reboot3           ; C839: Запустить NC.COM
 31+  C83C                  ENDIF
 32+  C83C C3 7B C9                     jp  reboot3             ; C83C: Запустить NC.COM
 33+  C83F C3 C4 D0                     jp  fileList            ; C83F: Получить список файлов
 34+  C842 C3 A9 CB                     jp  fileGetSetDrive     ; C842: Получить/установить активное устройство
 35+  C845 C3 A5 CE                     jp  fileCreate          ; C845: Создать файл
 36+  C848 C3 BC CF                     jp  fileLoad            ; C848: Загрузить файл по адресу из заголовка этого файла
 37+  C84B C3 23 D0                     jp  fileDelete          ; C84B: Удалить файл
 38+  C84E C3 55 D0                     jp  fileRename          ; C84E: Переименовать файл
 39+  C851 C3 05 D0                     jp  fileLoadInfo        ; C851: Загрузить информацию о файле
 40+  C854 C3 9F D0                     jp  fileGetSetAddr      ; C854: Получить/установить адрес загрузки файла
 41+  C857 C3 7A D0                     jp  fileGetSetAttr      ; C857: Получить/установить атрибуты файла
 42+  C85A C3 4F D1                     jp  fileNamePrepare     ; C85A: Преобразовать имя файла во внутренний формат
 43+  C85D C3 20 CA                     jp  fileExec            ; C85D: Запустить файл
 44+  C860 C3 92 CB                     jp  installDriver       ; C860: Установить драйвер накопителя
 45+  C863 C3 F0 CA     j_diskDriver:   jp  diskDriver          ; C863: Драйвер выбранного диска
 46+  C866 C3 B2 CF                     jp  fileLoad2           ; C866: Загрузить файл по адресу de
 47+  C869 C3 03 C6                     jp  printChar_real      ; C869: [MXOS2] Вывод символа на экран (только реальные символы)
 48+  C86C C3 E9 D1                     jp  printDecWord        ; C86C: [MXOS2] Вывод числа экран в десятичной форме
 49+  C86F C3 8E CA                     jp  setRAMDDriver       ; C86F: [MXOS2] Установить драйвер доступа к ДОЗУ
 50+  C872 C3 D0 CD                     jp  getDriveFreeSpace   ; C872: [MXOS2] Получить оставшийся свободный объем диска
 51+  C875 C3 FB CB                     jp  upperCase           ; C875: [MXOS2] Перевод кода символа КОИ-8 в верхний регистр
 52+  C878 C3 DB CB                     jp  strcmp              ; C878: [MXOS2] Сравнение строк, чувствительное к регистру
 53+  C87B C3 E5 CB                     jp  stricmp             ; C87B: [MXOS2] Сравнение строк, нечувствительное к регистру
 54+  C87E C3 2D D2                     jp  sub_hl_de           ; C87E: [MXOS2] Вычитание hl и de: hl = hl - de
 55+  C881 C3 34 D2                     jp  div_hl_2            ; C881: [MXOS2] Деление hl на 2: hl = hl / 2
 56+  C884 C3 3C D2                     jp  mul_hl_de           ; C884: [MXOS2] Умножение hl на de: hl = hl * de
 57+  C887 C3 61 D2                     jp  div_hl_de           ; C887: [MXOS2] Деление hl на de: hl = hl / de, de = hl % de
 58+  C88A
128   C88A              	INCLUDE "setGetCursorPos.inc"
  1+  C88A              ;+---------------------------------------------------------------------------
  2+  C88A              ; MXOS
  3+  C88A              ; Установить положение курсора
  4+  C88A              ;
  5+  C88A              ; На входе
  6+  C88A              ;  h - координата X в пикселях / 2
  7+  C88A              ;  l - координата Y в пикселях
  8+  C88A              ;
  9+  C88A              ; На выходе
 10+  C88A              ;  af, bc, de, hl - Сохраняются
 11+  C88A              ;
 12+  C88A              ; 2013-12-12 Дизассемблировано vinxru
 13+  C88A              ;----------------------------------------------------------------------------
 14+  C88A
 15+  C88A 22 FC 8F     setCursorPos:     ld    (bios_vars.cursorY), hl
 16+  C88D
 17+  C88D              ;----------------------------------------------------------------------------
 18+  C88D              ; Получить положение курсора
 19+  C88D              ;
 20+  C88D              ; На выходе
 21+  C88D              ;  af, bc, de - Сохраняются
 22+  C88D              ;  h - координата X в пикселях / 2
 23+  C88D              ;  l - координата Y в пикселях
 24+  C88D              ;----------------------------------------------------------------------------
 25+  C88D
 26+  C88D 2A FC 8F     getCursorPos:     ld    hl, (bios_vars.cursorY)
 27+  C890 C9                       ret
 28+  C891
129   C891              	INCLUDE "setGetMemTop.inc"
  1+  C891              ;+---------------------------------------------------------------------------
  2+  C891              ; MXOS
  3+  C891              ; Установить объем доступной памяти
  4+  C891              ;
  5+  C891              ; На входе
  6+  C891              ;  hl - доступная память. Если меньше 0D000h, то значение не изменяется.
  7+  C891              ;
  8+  C891              ; На выходе
  9+  C891              ;  все регистры сохраняются
 10+  C891              ;
 11+  C891              ; 2013-12-12 Дизассемблировано vinxru
 12+  C891              ;----------------------------------------------------------------------------
 13+  C891
 14+  C891 F5           setMemTop:  push  af
 15+  C892 7C                       ld    a, h
 16+  C893 FE D0                    cp    0D0h
 17+  C895 DA 9B C8                 jp c, setMemTop_0
 18+  C898 22 A9 D2                   ld  (v_memTop), hl
 19+  C89B F1           setMemTop_0:      pop   af
 20+  C89C C9                       ret
 21+  C89D
 22+  C89D              ;----------------------------------------------------------------------------
 23+  C89D              ; Получить объем доступной памяти
 24+  C89D              ;
 25+  C89D              ; На выходе
 26+  C89D              ;  hl - доступная память
 27+  C89D              ;
 28+  C89D              ; На выходе
 29+  C89D              ;  все регистры сохраняются
 30+  C89D              ;----------------------------------------------------------------------------
 31+  C89D
 32+  C89D 2A A9 D2     getMemTop:  ld    hl, (v_memTop)
 33+  C8A0 C9                       ret
 34+  C8A1
130   C8A1              	INCLUDE "printHex.inc"
  1+  C8A1              ;+---------------------------------------------------------------------------
  2+  C8A1              ; MXOS
  3+  C8A1              ; Вывод 16-ричного числа на экран (слово)
  4+  C8A1              ;
  5+  C8A1              ; На входе
  6+  C8A1              ;  hl - число
  7+  C8A1              ;
  8+  C8A1              ; На выходе
  9+  C8A1              ;  все регистры сохраняются
 10+  C8A1              ;
 11+  C8A1              ; 2013-12-12 Дизассемблировано vinxru
 12+  C8A1              ;----------------------------------------------------------------------------
 13+  C8A1
 14+  C8A1              printHexWord:     ; Сохраняем регистры
 15+  C8A1 F5                       push  af
 16+  C8A2
 17+  C8A2                          ; Старший байт
 18+  C8A2 7C                       ld    a, h
 19+  C8A3 CD AC C8                 call  printHexByte
 20+  C8A6
 21+  C8A6                          ; Младшйи байт
 22+  C8A6 7D                       ld    a, l
 23+  C8A7 CD AC C8                 call  printHexByte
 24+  C8AA
 25+  C8AA                          ; Восстаналиваем регистры
 26+  C8AA F1                       pop   af
 27+  C8AB C9                       ret
 28+  C8AC
 29+  C8AC              ;----------------------------------------------------------------------------
 30+  C8AC              ; Вывод 16-ричного числа на экран (байт)
 31+  C8AC              ;
 32+  C8AC              ; На входе
 33+  C8AC              ;  a - число
 34+  C8AC              ;
 35+  C8AC              ; На выходе
 36+  C8AC              ;  все регистры сохраняются
 37+  C8AC              ;----------------------------------------------------------------------------
 38+  C8AC
 39+  C8AC              printHexByte:     ; Сохраняем регистры
 40+  C8AC C5                       push  bc
 41+  C8AD F5                       push  af
 42+  C8AE
 43+  C8AE                          ; Сохраняем a для вывода второй цифры
 44+  C8AE 47                       ld    b, a
 45+  C8AF
 46+  C8AF                          ; Первая цифра - старшие 4 бита
 47+  C8AF 07                       rlca
 48+  C8B0 07                       rlca
 49+  C8B1 07                       rlca
 50+  C8B2 07                       rlca
 51+  C8B3 CD BD C8                 call  printHexNibble
 52+  C8B6
 53+  C8B6                          ; Вторая цифра - младщие 4 бита
 54+  C8B6 78                       ld    a, b
 55+  C8B7 CD BD C8                 call  printHexNibble
 56+  C8BA
 57+  C8BA                          ; Восстаналиваем регистры
 58+  C8BA F1                       pop   af
 59+  C8BB C1                       pop   bc
 60+  C8BC C9                       ret
 61+  C8BD
 62+  C8BD              ;----------------------------------------------------------------------------
 63+  C8BD              ; Вывод 16-ричного числа на экран (цифра)
 64+  C8BD              ;
 65+  C8BD              ; На входе
 66+  C8BD              ;  a - число, используются младшие 4 бита
 67+  C8BD              ;
 68+  C8BD              ; На выходе
 69+  C8BD              ;  c, a - изменяются, остальные регистры сохраняются
 70+  C8BD              ;----------------------------------------------------------------------------
 71+  C8BD
 72+  C8BD E6 0F        printHexNibble:   and   0Fh
 73+  C8BF C6 30                    add   a, '0'
 74+  C8C1 FE 3A                    cp    '9'+1
 75+  C8C3 DA C8 C8                 jp c, printHexNib_0
 76+  C8C6 C6 07                      add a, 'A'-'0'-10
 77+  C8C8 4F           printHexNib_0:    ld    c, a
 78+  C8C9 C3 09 C8                 jp    j_printChar
 79+  C8CC
131   C8CC              	INCLUDE "input.inc"
  1+  C8CC              ;+---------------------------------------------------------------------------
  2+  C8CC              ; MXOS
  3+  C8CC              ; Ввод строки
  4+  C8CC              ;
  5+  C8CC              ; На входе
  6+  C8CC              ;  hl - начало буфера
  7+  C8CC              ;  de - конец буфера
  8+  C8CC              ;
  9+  C8CC              ; На выходе
 10+  C8CC              ;  bc, de, hl - сохраняются
 11+  C8CC              ;
 12+  C8CC              ; 2013-12-12 Дизассемблировано vinxru
 13+  C8CC              ;----------------------------------------------------------------------------
 14+  C8CC
 15+  C8CC              input:      ; Сохраняем регистры
 16+  C8CC E5                       push  hl
 17+  C8CD C5                       push  bc
 18+  C8CE F5                       push  af
 19+  C8CF
 20+  C8CF                          ; Сохраняем значения
 21+  C8CF 22 9B D2                 ld    (v_input_start), hl
 22+  C8D2 EB                       ex    de, hl
 23+  C8D3 22 9D D2                 ld    (v_input_end), hl
 24+  C8D6
 25+  C8D6                          ; Помещаем в конец буфера 0
 26+  C8D6 62                       ld    h, d
 27+  C8D7 6B                       ld    l, e
 28+  C8D8 36 00                    ld  (hl), 0
 29+  C8DA
 30+  C8DA              input_loop: ; Ждем клавиашу
 31+  C8DA CD 03 C8                 call  j_getch
 32+  C8DD 4F                       ld    c, a
 33+  C8DE
 34+  C8DE                          ; Нажата служебная клавиша
 35+  C8DE FE 20                    cp    20h
 36+  C8E0 DA 32 C9                 jp c, input_spec
 37+  C8E3
 38+  C8E3                          ; Нажата клавиша Back space
 39+  C8E3 FE 7F                    cp    7Fh
 40+  C8E5 CA 21 C9                 jp z, input_bkspc
 41+  C8E8
 42+  C8E8                          ; ...
 43+  C8E8                          ;nop
 44+  C8E8                          ;nop
 45+  C8E8                          ;nop
 46+  C8E8
 47+  C8E8                          ; Это конец буфера
 48+  C8E8 E5                       push  hl
 49+  C8E9 2A 9D D2                 ld    hl, (v_input_end)
 50+  C8EC CD 89 C3                 call  cmp_hl_de_2
 51+  C8EF E1                       pop   hl
 52+  C8F0 C2 FC C8                 jp nz,  loc_C8DE
 53+  C8F3 CD 89 C3                 call  cmp_hl_de_2
 54+  C8F6 CA DA C8                 jp z, input_loop
 55+  C8F9 1A                       ld    a, (de)
 56+  C8FA 1B                       dec   de
 57+  C8FB 12                       ld    (de),a
 58+  C8FC C5           loc_C8DE:   push  bc
 59+  C8FD 44                       ld    b, h
 60+  C8FE 4D                       ld    c, l
 61+  C8FF 03                       inc   bc
 62+  C900 CD 97 C3                 call  memmove_bc_hl
 63+  C903 C1                       pop   bc
 64+  C904 71                       ld  (hl), c       ; *hl++     = c;
 65+  C905 CD 09 C8                 call  j_printChar ; Вывод     символа     на экран
 66+  C908 23                       inc   hl
 67+  C909 13                       inc   de
 68+  C90A E5           loc_C8EC:   push  hl
 69+  C90B 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 70+  C90E E3                       ex    (sp), hl
 71+  C90F E5                       push  hl
 72+  C910 CD 18 C8                 call  j_printString
 73+  C913 0E 20                    ld    c, ' '
 74+  C915 CD 09 C8                 call  j_printChar
 75+  C918 E1                       pop   hl
 76+  C919 E3                       ex    (sp), hl
 77+  C91A 22 FC 8F                 ld    (bios_vars.cursorY), hl
 78+  C91D E1                       pop   hl
 79+  C91E
 80+  C91E                          ; Продолжение
 81+  C91E C3 DA C8                 jp    input_loop
 82+  C921
 83+  C921              ; ---------------------------------------------------------------------------
 84+  C921
 85+  C921              input_bkspc:      ; Если курсор в начале строки ничего не удаляем
 86+  C921 CD 89 C3                 call  cmp_hl_de_2
 87+  C924 CA DA C8                 jp z, input_loop
 88+  C927
 89+  C927                          ; Сдвигаем строку
 90+  C927 44                       ld    b, h
 91+  C928 4D                       ld    c, l
 92+  C929 23                       inc   hl
 93+  C92A CD 97 C3                 call  memmove_bc_hl
 94+  C92D
 95+  C92D                          ; Уменьшаем положение курсора
 96+  C92D 2B                       dec   hl
 97+  C92E
 98+  C92E 1B                       dec   de
 99+  C92F C3 0A C9                 jp    loc_C8EC
100+  C932
101+  C932              ; ---------------------------------------------------------------------------
102+  C932
103+  C932              input_spec: ; Нажато влево
104+  C932 FE 08                    cp    8
105+  C934 CA 46 C9                 jp z, input_left
106+  C937
107+  C937                          ; Нажато вправо
108+  C937 FE 18                    cp    18h
109+  C939 CA 5A C9                 jp z, input_right
110+  C93C
111+  C93C                          ; Нажат не ввод
112+  C93C FE 0D                    cp    0Dh
113+  C93E C2 DA C8                 jp nz,  input_loop
114+  C941
115+  C941                          ; Нажат ввод
116+  C941
117+  C941                          ; Сохраняем в конец стрки 0D
118+  C941 12                       ld    (de),a
119+  C942
120+  C942                          ; Восстанавливаем регистры и выходим
121+  C942 F1                       pop   af
122+  C943 C1                       pop   bc
123+  C944 E1                       pop   hl
124+  C945 C9                       ret
125+  C946
126+  C946              ; ---------------------------------------------------------------------------
127+  C946
128+  C946              input_left: ; Если курсор в начале строки (hl==v_input_start) не перемещаем курсор
129+  C946 EB                       ex    de, hl
130+  C947 E5                       push  hl
131+  C948 2A 9B D2                 ld    hl, (v_input_start)
132+  C94B CD 89 C3                 call  cmp_hl_de_2
133+  C94E E1                       pop   hl
134+  C94F EB                       ex    de, hl
135+  C950 CA DA C8                 jp z, input_loop
136+  C953
137+  C953                          ; Уменьшаем положение курсора
138+  C953 2B                       dec   hl
139+  C954
140+  C954              input_lr:   ; Перемещаем курсор вправо/влево
141+  C954 CD 09 C8                 call  j_printChar
142+  C957
143+  C957                          ; Продолжаем ввод
144+  C957 C3 DA C8                 jp    input_loop
145+  C95A
146+  C95A              ; ---------------------------------------------------------------------------
147+  C95A
148+  C95A              input_right:      ; Если курсор в конце строк (hl==de) не перемещаем курсор
149+  C95A CD 89 C3                 call  cmp_hl_de_2
150+  C95D CA DA C8                 jp z, input_loop
151+  C960
152+  C960                          ; Увеличиваем положение курсора
153+  C960 23                       inc   hl
154+  C961
155+  C961                          ; Общее продолжение
156+  C961 C3 54 C9                 jp    input_lr
157+  C964
132   C964              	INCLUDE "calcCS.inc"
  1+  C964              ;+---------------------------------------------------------------------------
  2+  C964              ; MXOS
  3+  C964              ; Расчет контрольной суммы
  4+  C964              ;
  5+  C964              ; На входе
  6+  C964              ;  hl - начальный адрес
  7+  C964              ;  de - конечный адрес
  8+  C964              ;
  9+  C964              ; На выходе
 10+  C964              ;  bc - контрольная сумма
 11+  C964              ;
 12+  C964              ; 2013-12-12 Дизассемблировано vinxru
 13+  C964              ;----------------------------------------------------------------------------
 14+  C964
 15+  C964 01 00 00     calcCS:     ld      bc, 0
 16+  C967 7E           calcCS_1:   ld      a, (hl)
 17+  C968 81                       add     a, c
 18+  C969 4F                       ld      c, a
 19+  C96A F5                       push    af
 20+  C96B CD 89 C3                 call    cmp_hl_de_2
 21+  C96E CA 79 C9                 jp z,   calcCS_2
 22+  C971 F1                       pop     af
 23+  C972 78                       ld      a, b
 24+  C973 8E                       ADC     a, (hl)
 25+  C974 47                       ld      b, a
 26+  C975 23                       inc     hl
 27+  C976 C3 67 C9                 jp      calcCS_1
 28+  C979 F1           calcCS_2:   pop     af
 29+  C97A C9                       ret
 30+  C97B
133   C97B              	INCLUDE "reboot3.inc"
  1+  C97B              ;+---------------------------------------------------------------------------
  2+  C97B              ; MXOS
  3+  C97B              ; Обновление драйвера по адресу 0FFC0h и запуск NC.COM,
  4+  C97B              ; а также однократный запуск AUTOEX.BAT, если не нажата клавиша.
  5+  C97B              ;
  6+  C97B              ; 2013-12-12 Дизассемблировано vinxru
  7+  C97B              ;----------------------------------------------------------------------------
  8+  C97B
  9+  C97B              reboot3:    ; Инициализация стека
 10+  C97B 31 C0 FF                 ld      sp, STACK_ADDR
 11+  C97E
 12+  C97E                          ; Устанавливаем блочный драйвер
 13+  C97E 06 00                    ld      b, 0
 14+  C980 CD 8E CA                 call    setRAMDDriver
 15+  C983
 16+  C983                          ; Обновляем переменные
 17+  C983 21 00 C8                 ld      hl, j_reboot3
 18+  C986 22 E1 8F                 ld      (bios_vars.tapeError), hl
 19+  C989
 20+  C989              reboot3_0:
 21+  C989 C3 8C C9                 jp      reboot3_1
 22+  C98C
 23+  C98C              ; -------------------------------------
 24+  C98C              ; Код ниже будет выполнен лишь один раз после холодной перезагрузки.
 25+  C98C              ; То есть при теплой перезагрузке он не вызывается.
 26+  C98C
 27+  C98C              reboot3_1:
 28+  C98C                          ; Патчим предыдущую инструкцию - теперь она стала jp reboot3_2
 29+  C98C 21 C3 C9                 ld      hl, reboot3_2
 30+  C98F 22 8A C9                 ld      (reboot3_0+1), hl
 31+  C992
 32+  C992                          ; Устанавливаем побайтовый драйвер
 33+  C992 06 01                    ld      b, 1
 34+  C994 CD 8E CA                 call    setRAMDDriver
 35+  C997
 36+  C997                          ; Если в рам-диске по адресу 0FF00h (последний неполный сектор)
 37+  C997                          ; нет специальной метки, значит, не запускали форматирование
 38+  C997 21 BF FF                 ld      hl, 0FFBFh      ; адрес в странице
 39+  C99A AF                       xor     a               ; 0 страница
 40+  C99B CD C0 FF                 call    bios_RAMDRead
 41+  C99E 79                       ld      a, c            ; считанный байт в c
 42+  C99F FE 5A                    cp      5Ah
 43+  C9A1 CA B5 C9                 jp z,   skipFormat      ; метка есть - пропускаем форматирование
 44+  C9A4
 45+  C9A4                          ; Записываем метку
 46+  C9A4 AF                       xor     a               ; 0 страница
 47+  C9A5 0E 5A                    ld      c, 5Ah          ; записываемый байт
 48+  C9A7 CD D0 FF                 call    bios_RAMDWrite
 49+  C9AA
 50+  C9AA                          ; Устанавливаем блочный драйвер
 51+  C9AA 06 00                    ld      b, 0
 52+  C9AC CD 8E CA                 call    setRAMDDriver
 53+  C9AF
 54+  C9AF                          ; Запуск файла "A:FORMAT.BAT"
 55+  C9AF 21 0B D3                 ld      hl, pathFormatBat
 56+  C9B2 CD 20 CA                 call    fileExec
 57+  C9B5
 58+  C9B5              skipFormat:
 59+  C9B5                          ; Если нажата клавиша, пропустить запуск A:AUTOEX.BAT
 60+  C9B5 3A E1 FF                 ld      a, (IO_KEYB_B)
 61+  C9B8 E6 02                    and     2
 62+  C9BA CA C3 C9                 jp z,   reboot3_2
 63+  C9BD
 64+  C9BD                          ; Запуск файла A:AUTOEX.BAT
 65+  C9BD 21 FC D2                 ld      hl, pathAutoexecBat
 66+  C9C0 CD 20 CA                 call    fileExec
 67+  C9C3
 68+  C9C3              ; -------------------------------------
 69+  C9C3
 70+  C9C3              reboot3_2:
 71+  C9C3                          ; Запуск файла A:NC.COM
 72+  C9C3 21 F3 D2                 ld      hl, pathNcCom
 73+  C9C6 CD 20 CA                 call    fileExec
 74+  C9C9
 75+  C9C9                          ; Теплая перезагрузка
 76+  C9C9 C3 00 C8                 jp      j_reboot3
 77+  C9CC
134   C9CC              	INCLUDE "fileExecBat.inc"
  1+  C9CC              ;+---------------------------------------------------------------------------
  2+  C9CC              ; MXOS
  3+  C9CC              ; Запустить BAT файл. Вызывается функцией fileExec
  4+  C9CC              ;
  5+  C9CC              ; 2013-12-12 Дизассемблировано vinxru
  6+  C9CC              ;----------------------------------------------------------------------------
  7+  C9CC
  8+  C9CC              execBat:
  9+  C9CC D1                       pop     de
 10+  C9CD
 11+  C9CD                          ; Устанавливаем адрес загрузки BAT-файла на BAT_BUFFER (= FC00h)
 12+  C9CD 21 00 E8                 ld      hl, BAT_BUFFER
 13+  C9D0 22 A7 D2                 ld      (v_batPtr), hl
 14+  C9D3 EB                       ex      de, hl
 15+  C9D4
 16+  C9D4                          ; Изменяем адрес загрузки BAT-файла
 17+  C9D4                          ; TODO: это не работает с ром-диском (A: без поддержки записи). Поэтому
 18+  C9D4                          ; нельзя запустить BAT-файл с диска A:, если его адрес загрузки в каталоге
 19+  C9D4                          ; уже не прошит как FC00h (= BAT_BUFFER)
 20+  C9D4 21 76 D3                 ld      hl, v_curFileDescr
 21+  C9D7 0E 01                    ld      c, 1
 22+  C9D9 CD 9F D0                 call    fileGetSetAddr
 23+  C9DC DA 81 CA                 jp c,   badCommand
 24+  C9DF
 25+  C9DF                          ; Сохраняем имя BAT-файла
 26+  C9DF 21 76 D3                 ld      hl, v_curFileDescr
 27+  C9E2 11 81 D3                 ld      de, v_curFileDescr + FILE_NAME_LENGTH + 3
 28+  C9E5 01 96 D3                 ld      bc, v_batFileDescr
 29+  C9E8 CD 97 C3                 call    memmove_bc_hl
 30+  C9EB
 31+  C9EB                          ; Сохраняем диск содержащий BAT-файл
 32+  C9EB 3A 96 D2                 ld      a, (v_drive)
 33+  C9EE 32 F6 C9                 ld      (v_batDrive+1), a   ; самомодификация кода
 34+  C9F1
 35+  C9F1                          ; Этот цикл выполняется для каждой строки BAT-файла
 36+  C9F1              execBat_loop:
 37+  C9F1
 38+  C9F1                          ; Сохраняем текущий диск в регистре b
 39+  C9F1 3A 96 D2                 ld      a, (v_drive)
 40+  C9F4 47                       ld      b, a
 41+  C9F5
 42+  C9F5              v_batDrive:
 43+  C9F5                          ; Выбрать диск содержащий BAT файл
 44+  C9F5 3E 01                    ld      a, 1 ; << сюда вместо 1 пишется диск, содержащий BAT файл
 45+  C9F7 CD B1 CB                 call    fileSelectDrive
 46+  C9FA
 47+  C9FA                          ; Загрузить BAT-файл в память
 48+  C9FA 21 96 D3                 ld      hl, v_batFileDescr
 49+  C9FD CD BC CF                 call    fileLoad
 50+  CA00 2A A7 D2                 ld      hl, (v_batPtr)
 51+  CA03
 52+  CA03                          ; Сохраняем начало строки
 53+  CA03 54                       ld      d, h
 54+  CA04 5D                       ld      e, l
 55+  CA05
 56+  CA05                          ; Ищем конец строки
 57+  CA05              execBat_0:
 58+  CA05 7E                       ld      a, (hl)
 59+  CA06 23                       inc     hl
 60+  CA07
 61+  CA07                          ; Найден конец строки, запускаем файл
 62+  CA07 FE 0D                    cp      0Dh
 63+  CA09 CA 12 CA                 jp z,   execBat_1
 64+  CA0C
 65+  CA0C                          ; Конец файла
 66+  CA0C FE FF                    cp      0FFh
 67+  CA0E C2 05 CA                 jp nz,  execBat_0
 68+  CA11 C9                       ret
 69+  CA12
 70+  CA12              ; ---------------------------------------------------------------------------
 71+  CA12
 72+  CA12              execBat_1:
 73+  CA12                          ; Сохраняем указатель
 74+  CA12 22 A7 D2                 ld      (v_batPtr), hl
 75+  CA15
 76+  CA15                          ; Восстановление активного диска
 77+  CA15 78                       ld      a, b
 78+  CA16 CD B1 CB                 call    fileSelectDrive
 79+  CA19
 80+  CA19                          ; Запустить файл
 81+  CA19 EB                       ex      de, hl
 82+  CA1A CD 20 CA                 call    fileExec
 83+  CA1D
 84+  CA1D C3 F1 C9                 jp      execBat_loop
 85+  CA20
135   CA20              	INCLUDE "fileExec.inc"
  1+  CA20              ;+---------------------------------------------------------------------------
  2+  CA20              ; MXOS
  3+  CA20              ; Запустить файл
  4+  CA20              ;
  5+  CA20              ; На входе
  6+  CA20              ;  hl - ком строка в формате [Диск:]файл[ аргументы]
  7+  CA20              ;
  8+  CA20              ; На выходе
  9+  CA20              ;  сf - ошибка
 10+  CA20              ;
 11+  CA20              ; 2013-12-12 Дизассемблировано vinxru
 12+  CA20              ;----------------------------------------------------------------------------
 13+  CA20
 14+  CA20              fileExec:   ; Сюда будем записывать результат
 15+  CA20 11 00 FF                 ld      de, CMD_LINE
 16+  CA23
 17+  CA23                          ; Если первый символ меньше пробела, выходим c CF
 18+  CA23 7E                       ld      a, (hl)
 19+  CA24 FE 20                    cp      ' '
 20+  CA26 DA 87 CA                 jp      c, stc_ret
 21+  CA29
 22+  CA29                          ; Максимальный размер ком строки (+2 терминатора, итого 82h)
 23+  CA29 0E 80                    ld      c, 80h
 24+  CA2B
 25+  CA2B              fileExec_0: ; Если символ меньше пробела, выходим
 26+  CA2B 7E                       ld      a, (hl)
 27+  CA2C FE 20                    cp      20h
 28+  CA2E DA 38 CA                 jp c,   fileExec_1
 29+  CA31
 30+  CA31                          ; Копируем симовол из hl в de
 31+  CA31 12                       ld      (de),a
 32+  CA32 23                       inc     hl
 33+  CA33 13                       inc     de
 34+  CA34
 35+  CA34                          ; Повторяем 80h раз
 36+  CA34 0D                       dec     c
 37+  CA35 C2 2B CA                 jp nz,  fileExec_0
 38+  CA38
 39+  CA38              fileExec_1: ; В конец имени помещаем 13, 0
 40+  CA38 3E 0D                    ld      a, 0Dh
 41+  CA3A 12                       ld      (de), a
 42+  CA3B 13                       inc     de
 43+  CA3C AF                       xor     a
 44+  CA3D 12                       ld      (de), a
 45+  CA3E
 46+  CA3E                          ; Выводим на экран 0Ah
 47+  CA3E CD 89 CA                 call    printCharA
 48+  CA41
 49+  CA41                          ; Выводим на экран имя файла
 50+  CA41 21 00 FF                 ld      hl, CMD_LINE
 51+  CA44 CD 18 C8                 call    j_printString
 52+  CA47
 53+  CA47                          ; Подготовка имени файла
 54+  CA47 21 00 FF                 ld      hl, CMD_LINE
 55+  CA4A 11 76 D3                 ld      de, v_curFileDescr
 56+  CA4D CD 4F D1                 call    fileNamePrepare
 57+  CA50
 58+  CA50                          ; Запоминаем в стеке текущий адрес командной строки (начало списка аргументов)
 59+  CA50 E5                       push    hl
 60+  CA51
 61+  CA51                          ; Если это BAT файл
 62+  CA51 11 18 D3                 ld      de, aBat ; "BAT"
 63+  CA54 CD 17 CC                 call    cmpFileExt
 64+  CA57 CA CC C9                 jp z,   execBat
 65+  CA5A
 66+  CA5A                          ; Если это COM или EXE файл
 67+  CA5A CD 17 CC                 call    cmpFileExt
 68+  CA5D CA 66 CA                 jp z,   execExeCom
 69+  CA60 CD 17 CC                 call    cmpFileExt
 70+  CA63 C2 80 CA                 jp nz,  execError
 71+  CA66
 72+  CA66              execExeCom:
 73+  CA66                          ; Вытаскиваем из стека текущий адрес командной строки (начало списка аргументов)
 74+  CA66 D1                       pop     de
 75+  CA67
 76+  CA67                          ; Загрузить файл
 77+  CA67 21 76 D3                 ld      hl, v_curFileDescr
 78+  CA6A CD BC CF                 call    fileLoad
 79+  CA6D DA 81 CA                 jp c,   badCommand
 80+  CA70
 81+  CA70                          ; Адрес командной строки
 82+  CA70 D5                       push    de
 83+  CA71
 84+  CA71                          ; Выводим на экран 0Ah
 85+  CA71                          ;call printCharA
 86+  CA71
 87+  CA71                          ; hl = указатель на адрес загрузки (= адрес запуска) файла
 88+  CA71 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress   ; смещение поля с адресом загрузки
 89+  CA74 19                       add     hl, de
 90+  CA75
 91+  CA75                          ; de = адрес загрузки (= адрес запуска) файла
 92+  CA75 5E                       ld      e, (hl)
 93+  CA76 23                       inc     hl
 94+  CA77 56                       ld      d, (hl)
 95+  CA78
 96+  CA78                          ; Адрес возврата
 97+  CA78 21 7E CA                 ld      hl, defAppReturn
 98+  CA7B E3                       ex      (sp), hl
 99+  CA7C
100+  CA7C                          ; Запуск программы (переход на de)
101+  CA7C EB                       ex      de, hl  ; hl <--> de
102+  CA7D E9                       jp      (hl)    ; pc <-- hl
103+  CA7E
104+  CA7E              ; ---------------------------------------------------------------------------
105+  CA7E
106+  CA7E              defAppReturn:
107+  CA7E B7                       or  a
108+  CA7F C9                       ret
109+  CA80
110+  CA80              ; ---------------------------------------------------------------------------
111+  CA80
112+  CA80              execError:
113+  CA80 D1                       pop     de
114+  CA81              badCommand:
115+  CA81 21 3C D3                 ld      hl, txtBadCommand; "\nBAD COMMAND or FILE NAME"
116+  CA84 CD 18 C8                 call    j_printString
117+  CA87              stc_ret:
118+  CA87 37                       scf
119+  CA88 C9                       ret
120+  CA89
121+  CA89              ; ---------------------------------------------------------------------------
122+  CA89
123+  CA89              printCharA:
124+  CA89 0E 0A                    ld  c, 0Ah
125+  CA8B C3 09 C8                 jp  j_printChar
126+  CA8E
136   CA8E              	INCLUDE "driverFFC0.inc"
  1+  CA8E              ;+---------------------------------------------------------------------------
  2+  CA8E              ; MXOS
  3+  CA8E              ; Драйверы диска в ДОЗУ (часть, которая копируется на адрес 0FFC0h)
  4+  CA8E              ;
  5+  CA8E              ; 2013-12-12 Дизассемблировано и доработано vinxru
  6+  CA8E              ; 2022-02-02 Доработано SpaceEngineer
  7+  CA8E              ;----------------------------------------------------------------------------
  8+  CA8E
  9+  CA8E              ;----------------------------------------------------------------------------
 10+  CA8E              ; Установить драйвер доступа к ДОЗУ в окно разделяемой памяти
 11+  CA8E              ; Специалиста-MX (FFC0h-FFDEh)
 12+  CA8E              ;
 13+  CA8E              ; вход:
 14+  CA8E              ;  b = 0 - установить блочный драйвер, b = 1 - установить побайтовый драйвер
 15+  CA8E              ;
 16+  CA8E              ; 2022-02-02 SpaceEngineer
 17+  CA8E              ;----------------------------------------------------------------------------
 18+  CA8E
 19+  CA8E              setRAMDDriver:
 20+  CA8E E5                       push  hl
 21+  CA8F D5                       push  de
 22+  CA90 C5                       push  bc
 23+  CA91 F5                       push  af
 24+  CA92 05                       dec   b
 25+  CA93 CA 9F CA                 jp z, setRAMDDriver_1
 26+  CA96
 27+  CA96                          ; Адреса блочного драйвера
 28+  CA96 21 B0 CA                 ld    hl, driverBlockStart
 29+  CA99 11 D0 CA                 ld    de, driverBlockEnd
 30+  CA9C C3 A5 CA                 jp    setRAMDDriver_2
 31+  CA9F
 32+  CA9F              setRAMDDriver_1:
 33+  CA9F                          ; Адреса побайтового драйвера
 34+  CA9F 21 D0 CA                 ld    hl, driverByteStart
 35+  CAA2 11 F0 CA                 ld    de, driverByteEnd
 36+  CAA5
 37+  CAA5                          ; Копируем драйвер на адрес bc = bios_RAMDRead = 0FFC0h
 38+  CAA5              setRAMDDriver_2:
 39+  CAA5 01 C0 FF                 ld    bc, bios_RAMDRead
 40+  CAA8 CD 2D C4                 call  memcpy_bc_hl
 41+  CAAB
 42+  CAAB                          ; Восстанавливаем регистры и выходим
 43+  CAAB F1                       pop   af
 44+  CAAC C1                       pop   bc
 45+  CAAD D1                       pop   de
 46+  CAAE E1                       pop   hl
 47+  CAAF C9                       ret
 48+  CAB0
 49+  CAB0              ;----------------------------------------------------------------------------
 50+  CAB0              ; Блочный драйвер, обрабатывает сразу блок 256 байт
 51+  CAB0              ;
 52+  CAB0              ; FFC0h - чтение 256-байтного блока
 53+  CAB0              ;   вход:
 54+  CAB0              ;     c = номер страницы
 55+  CAB0              ;     d = номер блока
 56+  CAB0              ;     e = 0
 57+  CAB0              ;     hl = адрес буфера в памяти
 58+  CAB0              ;
 59+  CAB0              ; FFD0h - запись 256-байтного блока
 60+  CAB0              ;   вход:
 61+  CAB0              ;     c = номер страницы
 62+  CAB0              ;     d = номер блока
 63+  CAB0              ;     e = 0
 64+  CAB0              ;     hl = адрес буфера в памяти
 65+  CAB0              ;
 66+  CAB0              ;----------------------------------------------------------------------------
 67+  CAB0
 68+  CAB0              ; Чтение 256-байтного блока с диска
 69+  CAB0
 70+  CAB0              driverBlockStart: ; эта п/п копируется на FFC0h
 71+  CAB0 79                       ld      a, c
 72+  CAB1 32 FD FF                 ld      (IO_PAGE_RAMD), a
 73+  CAB4 1A                       ld      a, (de)
 74+  CAB5 32 FC FF                 ld      (IO_PAGE_RAM), a
 75+  CAB8 77                       ld      (hl), a
 76+  CAB9 23                       inc     hl
 77+  CABA 1C                       inc     e
 78+  CABB C2 C0 FF                 jp nz,  0FFC0h
 79+  CABE C9                       ret
 80+  CABF
 81+  CABF                          ; осталось места: 1 байт
 82+  CABF 00                       nop
 83+  CAC0
 84+  CAC0              ; Запись 256-байтного блока на диск
 85+  CAC0
 86+  CAC0              driverBlockWrite: ; эта п/п копируется на FFD0h
 87+  CAC0 46                       ld      b, (hl)
 88+  CAC1 79                       ld      a, c
 89+  CAC2 32 FD FF                 ld      (IO_PAGE_RAMD), a
 90+  CAC5 78                       ld      a, b
 91+  CAC6 12                       ld      (de), a
 92+  CAC7 32 FC FF                 ld      (IO_PAGE_RAM), a
 93+  CACA 23                       inc     hl
 94+  CACB 1C                       inc     e
 95+  CACC C2 D0 FF                 jp nz,  0FFD0h
 96+  CACF C9                       ret
 97+  CAD0
 98+  CAD0                          ; осталось места: 0 байт
 99+  CAD0
100+  CAD0              driverBlockEnd:
101+  CAD0
102+  CAD0              ;----------------------------------------------------------------------------
103+  CAD0              ; Побайтовый драйвер, обрабатывает только 1 байт
104+  CAD0              ;
105+  CAD0              ; FFC0h - чтение байта
106+  CAD0              ;   вход:
107+  CAD0              ;     a  = номер страницы
108+  CAD0              ;     hl = адрес байта в странице ДОЗУ
109+  CAD0              ;   выход:
110+  CAD0              ;     c  = считанный байт
111+  CAD0              ;
112+  CAD0              ; FFD0h - запись байта
113+  CAD0              ;   вход:
114+  CAD0              ;     a  = номер страницы
115+  CAD0              ;     hl = байта в странице ДОЗУ
116+  CAD0              ;     c  = записываемый байт
117+  CAD0              ;
118+  CAD0              ;----------------------------------------------------------------------------
119+  CAD0
120+  CAD0              driverByteStart: ; эта п/п копируется на FFC0h
121+  CAD0 32 FD FF                 ld      (IO_PAGE_RAMD), a
122+  CAD3 4E                       ld      c, (hl)
123+  CAD4 32 FC FF                 ld      (IO_PAGE_RAM), a
124+  CAD7 C9                       ret
125+  CAD8
126+  CAD8                          ; осталось места: 8 байт
127+  CAD8 00                       nop
128+  CAD9 00                       nop
129+  CADA 00                       nop
130+  CADB 00                       nop
131+  CADC 00                       nop
132+  CADD 00                       nop
133+  CADE 00                       nop
134+  CADF 00                       nop
135+  CAE0
136+  CAE0              driverByteWrite: ; эта п/п копируется на FFD0h
137+  CAE0 32 FD FF                 ld      (IO_PAGE_RAMD), a
138+  CAE3 71                       ld      (hl), c
139+  CAE4 32 FC FF                 ld      (IO_PAGE_RAM), a
140+  CAE7 C9                       ret
141+  CAE8
142+  CAE8                          ; осталось места: 8 байт
143+  CAE8 00                       nop
144+  CAE9 00                       nop
145+  CAEA 00                       nop
146+  CAEB 00                       nop
147+  CAEC 00                       nop
148+  CAED 00                       nop
149+  CAEE 00                       nop
150+  CAEF 00                       nop
151+  CAF0
152+  CAF0              driverByteEnd:
153+  CAF0
154+  CAF0              ; ---------------------------------------------------------------------------
155+  CAF0
156+  CAF0              ; Проверка, что драйверы влезаеют в 32 байта разделяемой памяти Специалиста-MX
157+  CAF0
158+  CAF0                  IF driverBlockWrite-driverBlockStart+bios_RAMDRead != bios_RAMDWrite
159+  CAF0 ~                    ASSERT 0
160+  CAF0 ~                    DISPLAY /l, "Error! Block briver entry point FFD0 has been shifted: ", driverBlockWrite-driverBlockStart+bios_RAMDRead, " != 0xFFD0"
161+  CAF0                  ENDIF
162+  CAF0
163+  CAF0                  IF driverByteWrite-driverByteStart+bios_RAMDRead != bios_RAMDWrite
164+  CAF0 ~                    ASSERT 0
165+  CAF0 ~                    DISPLAY /l, "Error! Byte briver entry point FFD0 has been shifted: ", driverByteWrite-driverByteStart+bios_RAMDRead, " != 0xFFD0"
166+  CAF0                  ENDIF
167+  CAF0
168+  CAF0                  IF driverBlockEnd-driverBlockStart > 32
169+  CAF0 ~                    ASSERT 0
170+  CAF0 ~                    DISPLAY /d, "Error! Block briver did not fit: ", driverBlockEnd-driverBlockStart, " > 32 bytes"
171+  CAF0                  ENDIF
172+  CAF0
173+  CAF0                  IF driverByteEnd-driverByteStart > 32
174+  CAF0 ~                    ASSERT 0
175+  CAF0 ~                    DISPLAY /d, "Error! Byte briver did not fit: ", driverByteEnd-driverByteStart, " > 32 bytes"
176+  CAF0                  ENDIF
177+  CAF0
137   CAF0              	INCLUDE "driver.inc"
  1+  CAF0              ;+---------------------------------------------------------------------------
  2+  CAF0              ; MXOS
  3+  CAF0              ; Встроенный драйвер ROM-диска (в ПЗУ) и RAM-диска (в ДОЗУ)
  4+  CAF0              ;
  5+  CAF0              ; Запись 256-байтного блока
  6+  CAF0              ;   На входе
  7+  CAF0              ;     b = 1                 // было: e = 1
  8+  CAF0              ;     de = номер кластера   // было: d = номер блока
  9+  CAF0              ;     hl = адрес буфера в памяти
 10+  CAF0              ;   На выходе
 11+  CAF0              ;     все регистры сохраняются
 12+  CAF0              ;
 13+  CAF0              ; Чтение 256-байтного блока
 14+  CAF0              ;   На входе
 15+  CAF0              ;     b = 2                 // было: e = 2
 16+  CAF0              ;     de = номер кластера   // было: d = номер блока
 17+  CAF0              ;     hl = адрес буфера в памяти
 18+  CAF0              ;   На выходе
 19+  CAF0              ;     все регистры сохраняются
 20+  CAF0              ;
 21+  CAF0              ; Получение размера накопителя
 22+  CAF0              ;   На входе
 23+  CAF0              ;     b = 3                 // было: e = 3
 24+  CAF0              ;   На выходе
 25+  CAF0              ;     de = количество секторов на диске (0 - нет драйвера)
 26+  CAF0              ;     hl = адрес структуры DISK_INFO
 27+  CAF0              ;
 28+  CAF0              ; 2013-12-12 Дизассемблировано и доработано vinxru
 29+  CAF0              ; 2022-02-15 Доработано SpaceEngineer
 30+  CAF0              ;----------------------------------------------------------------------------
 31+  CAF0
 32+  CAF0              diskDriver: ; Сохраняем регистры
 33+  CAF0 F5                       push    af
 34+  CAF1
 35+  CAF1                          ; Функция 3 - Получение размера диска
 36+  CAF1 78                       ld      a, b
 37+  CAF2 FE 03                    cp      3
 38+  CAF4 CA 64 CB                 jp z,   diskDriver_s
 39+  CAF7
 40+  CAF7                           ; Сохраняем регистры
 41+  CAF7 E5                       push    hl
 42+  CAF8 C5                       push    bc
 43+  CAF9 D5                       push    de
 44+  CAFA
 45+  CAFA                          ; Заранее загружаем в С активный диск
 46+  CAFA 3A 96 D2                 ld      a, (v_drive)
 47+  CAFD 4F                       ld      c, a
 48+  CAFE
 49+  CAFE                          ; Функция 1 - Запись блока
 50+  CAFE 05                       dec     b
 51+  CAFF CA 56 CB                 jp z,   diskDriver_w
 52+  CB02
 53+  CB02                          ; Функция 2 - Чтение блока
 54+  CB02 05                       dec     b
 55+  CB03 CA 0B CB                 jp z,   diskDriver_r
 56+  CB06
 57+  CB06              popDBHA_ret:
 58+  CB06                          ; Восстанавливаем регистры и выходим
 59+  CB06 D1                       pop     de
 60+  CB07 C1                       pop     bc
 61+  CB08 E1                       pop     hl
 62+  CB09 F1                       pop     af
 63+  CB0A C9                       ret
 64+  CB0B
 65+  CB0B
 66+  CB0B              ; ---------------------------------------------------------------------------
 67+  CB0B              ; Функция 2 - Чтение блока
 68+  CB0B
 69+  CB0B              diskDriver_r:
 70+  CB0B                          ; Это ROM-диск?
 71+  CB0B B7                       or      a
 72+  CB0C C2 4C CB                 jp nz,  ramDRead ; нет, переходим к драйверу RAM-диска
 73+  CB0F
 74+  CB0F                  IF ROM_64K
 75+  CB0F
 76+  CB0F                          ; Это старшая часть ПЗУ?
 77+  CB0F 3E 80                    ld      a, 80h
 78+  CB11 AB                       xor     e
 79+  CB12 FA 38 CB                 jp m,   romMXRead; нет переходим к драйверу ROM-диска MX (Специалист-MX2)
 80+  CB15
 81+  CB15                          ; Драйвер ROM-диска STD (Специалист-MX2)
 82+  CB15 57                       ld      d, a
 83+  CB16 1E 00                    ld      e, 0
 84+  CB18 13                       inc     de ; пропускаем первые 4 байта в ПЗУ STD (это код перехода на загрузчик)
 85+  CB19 13                       inc     de
 86+  CB1A 13                       inc     de
 87+  CB1B 13                       inc     de
 88+  CB1C
 89+  CB1C                          ; Включаем ПЗУ STD (да, надо регистр цвета сбросить для этого)
 90+  CB1C AF                       xor     a
 91+  CB1D 32 F8 FF                 ld      (IO_COLOR), a
 92+  CB20              romStdReadLoop:
 93+  CB20                          ; Включаем режим STD
 94+  CB20 32 FF FF                 ld      (IO_PAGE_STD), a
 95+  CB23                          ; Чтение
 96+  CB23 1A                       ld      a, (de)
 97+  CB24                          ; Включаем ОЗУ MX
 98+  CB24 32 FC F7                 ld      (IO_PAGE_RAM-800h),a
 99+  CB27                          ; Запись
100+  CB27 77                       ld      (hl), a
101+  CB28 23                       inc     hl
102+  CB29                          ; Цикл
103+  CB29 13                       inc     de
104+  CB2A 3E 04                    ld      a, 4
105+  CB2C BB                       cp      e
106+  CB2D C2 20 CB                 jp nz,  romStdReadLoop
107+  CB30
108+  CB30                          ; Восстаналиваем цвет
109+  CB30 3E F0                    ld      a, COLOR_BIOS
110+  CB32 32 F8 FF                 ld      (IO_COLOR), a
111+  CB35
112+  CB35                          ; Восстанавливаем регистры и выходим
113+  CB35 C3 06 CB                 jp      popDBHA_ret
114+  CB38
115+  CB38                  ENDIF
116+  CB38
117+  CB38              romMXRead:
118+  CB38              romMXReadDrv:
119+  CB38 79                       ld      a, c    ; c = номер страницы = 0
120+  CB39 53                       ld      d, e    ; d = номер блока
121+  CB3A 1E 00                    ld      e, 0    ; e = 0
122+  CB3C                                          ; hl = адрес буфера в памяти
123+  CB3C              romMXReadLoop:
124+  CB3C 32 FE FF                 ld      (IO_PAGE_ROM), a
125+  CB3F 1A                       ld      a, (de)
126+  CB40 32 FC FF                 ld      (IO_PAGE_RAM), a
127+  CB43 77                       ld      (hl), a
128+  CB44 23                       inc     hl
129+  CB45 1C                       inc     e
130+  CB46 C2 3C CB                 jp nz,  romMXReadLoop
131+  CB49 C3 06 CB                 jp      popDBHA_ret
132+  CB4C
133+  CB4C              ramDRead:
134+  CB4C                          ; Вызываем драйвер чтения RAM-диска
135+  CB4C 4A                       ld      c, d        ; c = номер страницы
136+  CB4D 53                       ld      d, e        ; d = номер блока
137+  CB4E 1E 00                    ld      e, 0        ; e = 0
138+  CB50                                              ; hl = адрес буфера в памяти
139+  CB50 CD C0 FF                 call    bios_RAMDRead
140+  CB53
141+  CB53                          ; Восстановливаем регистры и выходим
142+  CB53 C3 06 CB                 jp      popDBHA_ret
143+  CB56
144+  CB56              ; ---------------------------------------------------------------------------
145+  CB56              ; Функция 1 - Запись блока
146+  CB56
147+  CB56              diskDriver_w:
148+  CB56 B7                       or      a           ; это ROM-диск?
149+  CB57 CA 06 CB                 jp z,   popDBHA_ret ; да, запись не поддерживается
150+  CB5A
151+  CB5A                          ; Вызываем драйвер записи RAM-диска
152+  CB5A 4A                       ld      c, d        ; c = номер страницы
153+  CB5B 53                       ld      d, e        ; d = номер блока
154+  CB5C 1E 00                    ld      e, 0        ; e = 0
155+  CB5E                                              ; hl = адрес буфера в памяти
156+  CB5E CD D0 FF                 call    bios_RAMDWrite
157+  CB61
158+  CB61                          ; Восстановливаем регистры и выходим
159+  CB61 C3 06 CB                 jp      popDBHA_ret
160+  CB64
161+  CB64              ; ---------------------------------------------------------------------------
162+  CB64              ; Функция 3 - Получение размера диска
163+  CB64
164+  CB64              diskDriver_s:
165+  CB64 3A 96 D2                 ld      a, (v_drive)
166+  CB67 B7                       or      a                   ; это ROM-диск?
167+  CB68 CA 7A CB                 jp z,   diskDriver_s_rom    ; да, переходим
168+  CB6B
169+  CB6B                          ; Это RAM-диск. Рассчитываем размер, зная количество банок ДОЗУ
170+  CB6B 3A F8 8F                 ld      a, (bios_vars.ramPageCount) ; a  = количество 64к банок ДОЗУ
171+  CB6E 5F                       ld      e, a
172+  CB6F 16 00                    ld      d, 0                        ; de = количество 64к банок ДОЗУ
173+  CB71 21 00 01                 ld      hl, 65536 / SECTOR_SIZE     ; hl = количество секторов в одной 64к банке
174+  CB74 CD 3C D2                 call    mul_hl_de                   ; hl = количество секторов в ДОЗУ
175+  CB77 C3 7D CB                 jp      diskDriver_s_exit
176+  CB7A
177+  CB7A              diskDriver_s_rom:
178+  CB7A                          ; У ROM-диска размер должен быть прошит в загрузочном секторе
179+  CB7A 2A CF D2                 ld      hl, (v_diskInfo.totalSectors)
180+  CB7D
181+  CB7D              diskDriver_s_exit:
182+  CB7D                          ; Возвращаем в de размер диска в секторах
183+  CB7D EB                       ex      hl, de
184+  CB7E
185+  CB7E                          ; Возвращаем в hl адрес структуры v_diskInfo
186+  CB7E 21 C5 D2                 ld      hl, v_diskInfo
187+  CB81
188+  CB81                          ; Восстановливаем регистры и выходим
189+  CB81 F1                       pop     af
190+  CB82 C9                       ret
191+  CB83
192+  CB83              ;----------------------------------------------------------------------------
193+  CB83              ; MXOS
194+  CB83              ; "Пустой" драйвер диска
195+  CB83              ; Назначается при старте на накопители C: ... H:
196+  CB83              ;
197+  CB83              ; 2022-02-07 SpaceEngineer
198+  CB83              ;----------------------------------------------------------------------------
199+  CB83
200+  CB83              diskDriverDummy:
201+  CB83 F5                       push    af
202+  CB84
203+  CB84                          ; Функция 3 - Получение размера диска
204+  CB84 78                       ld      a, b
205+  CB85 FE 03                    cp      3
206+  CB87 C2 8D CB                 jp nz,  diskDriverDummyExit
207+  CB8A
208+  CB8A 11 00 00                 ld      de, 0   ; вернуть размер 0 - драйвер не установлен
209+  CB8D
210+  CB8D                          ; Остальные функции просто ничего не делают
211+  CB8D              diskDriverDummyExit:
212+  CB8D
213+  CB8D                          ; Возвращаем в hl адрес структуры v_diskInfo
214+  CB8D 21 C5 D2                 ld      hl, v_diskInfo
215+  CB90
216+  CB90 F1                       pop     af
217+  CB91 C9                       ret
218+  CB92
138   CB92              	INCLUDE "installDriver.inc"
  1+  CB92              ;+---------------------------------------------------------------------------
  2+  CB92              ; MXOS
  3+  CB92              ; Установить драйвер устройства
  4+  CB92              ;
  5+  CB92              ; На входе
  6+  CB92              ;  a - диск
  7+  CB92              ;  hl - адрес драйвера
  8+  CB92              ;
  9+  CB92              ; На выходе
 10+  CB92              ;  hl - адрес структуры DISK_INFO
 11+  CB92              ;
 12+  CB92              ; 2013-12-12 Дизассемблировано vinxru
 13+  CB92              ;----------------------------------------------------------------------------
 14+  CB92
 15+  CB92              installDriver:    ; Сохранение регистров
 16+  CB92 D5                       push de
 17+  CB93 E5                       push hl
 18+  CB94
 19+  CB94                          ; Максимум дисков
 20+  CB94 E6 07                    and 7
 21+  CB96
 22+  CB96                          ; Вычисление адреса в таблице дисков
 23+  CB96 87                       add   a, a
 24+  CB97 6F                       ld    l, a
 25+  CB98 26 00                    ld    h, 0
 26+  CB9A 11 B5 D2                 ld    de, v_drives
 27+  CB9D 19                       add   hl, de
 28+  CB9E
 29+  CB9E                          ; Установка драйвера
 30+  CB9E D1                       pop   de
 31+  CB9F 73                       ld  (hl), e
 32+  CBA0 23                       inc   hl
 33+  CBA1 72                       ld  (hl), d
 34+  CBA2
 35+  CBA2                          ; Восстановление регистров
 36+  CBA2 EB                       ex  de, hl
 37+  CBA3 D1                       pop de
 38+  CBA4 0F                       rrca
 39+  CBA5
 40+  CBA5                          ; Передача адреса структуры v_diskInfo
 41+  CBA5 21 C5 D2                 ld  hl, v_diskInfo
 42+  CBA8
 43+  CBA8                          ; Выход
 44+  CBA8 C9                       ret
 45+  CBA9
139   CBA9              	INCLUDE "fileGetSetDrive.inc"
  1+  CBA9              ;+---------------------------------------------------------------------------
  2+  CBA9              ; MXOS
  3+  CBA9              ; Получение/установка текущего накопителя.
  4+  CBA9              ; В режиме 1 функция переключает драйвер накопителя.
  5+  CBA9              ;
  6+  CBA9              ; На входе
  7+  CBA9              ;   e  - 0=чтение, 1=установка
  8+  CBA9              ;   a  - накопитель от 0 до 7
  9+  CBA9              ;
 10+  CBA9              ; На выходе
 11+  CBA9              ;   a  - накопитель
 12+  CBA9              ;   bc, de, hl - сохраняются
 13+  CBA9              ;
 14+  CBA9              ; 2013-12-12 Дизассемблировано vinxru
 15+  CBA9              ; 2022-02-02 Доработано SpaceEngineer
 16+  CBA9              ;----------------------------------------------------------------------------
 17+  CBA9
 18+  CBA9              fileGetSetDrive:
 19+  CBA9 1D                       dec     e
 20+  CBAA CA B1 CB                 jp z,   fileSelectDrive
 21+  CBAD 3A 96 D2                 ld      a, (v_drive)
 22+  CBB0 C9                       ret
 23+  CBB1
 24+  CBB1              ; ---------------------------------------------------------------------------
 25+  CBB1
 26+  CBB1              fileSelectDrive:
 27+  CBB1                          ; Максимум устройств - 1
 28+  CBB1 E6 07                    and     7
 29+  CBB3
 30+  CBB3                          ; Если устройство не менялось, выходим
 31+  CBB3 E5                       push    hl
 32+  CBB4 21 96 D2                 ld      hl, v_drive
 33+  CBB7 BF BE                    cp      a, (hl)
 34+  CBB9 E1                       pop     hl
 35+  CBBA C8                       ret z
 36+  CBBB
 37+  CBBB                          ; Сохраняем выбранное устройство
 38+  CBBB 32 96 D2                 ld      (v_drive), a
 39+  CBBE
 40+  CBBE                          ; Пригодится ниже (a = a * 2)
 41+  CBBE 87                       add     a, a
 42+  CBBF
 43+  CBBF                          ; Сохраняем регистры
 44+  CBBF E5                       push    hl
 45+  CBC0 D5                       push    de
 46+  CBC1
 47+  CBC1                          ; Получаем точку входа драйвера
 48+  CBC1 6F                       ld      l, a
 49+  CBC2 26 00                    ld      h, 0
 50+  CBC4 11 B5 D2                 ld      de, v_drives
 51+  CBC7 19                       add     hl, de
 52+  CBC8 5E                       ld      e, (hl)
 53+  CBC9 23                       inc     hl
 54+  CBCA 56                       ld      d, (hl)
 55+  CBCB EB                       ex      de, hl
 56+  CBCC
 57+  CBCC                          ; Сохраняем её
 58+  CBCC 22 64 C8                 ld      (j_diskDriver+1), hl
 59+  CBCF
 60+  CBCF                          ; Восстаналвиаем a
 61+  CBCF 0F                       rrca
 62+  CBD0
 63+  CBD0                          ; Очищаем кэш fat
 64+  CBD0 C5                       push    bc
 65+  CBD1 CD 47 CC                 call    resetSectorCache
 66+  CBD4 C1                       pop     bc
 67+  CBD5
 68+  CBD5                          ; Считываем загрузочный сектор и инициализируем структуру v_diskInfo
 69+  CBD5 CD 00 CE                 call    fatReadBootSector
 70+  CBD8
 71+  CBD8                          ; Восстанавливаем регистры и выходим
 72+  CBD8 D1                       pop     de
 73+  CBD9 E1                       pop     hl
 74+  CBDA C9                       ret
 75+  CBDB
140   CBDB                  INCLUDE "strcmp.inc"
  1+  CBDB              ;----------------------------------------------------------------------------
  2+  CBDB              ; MXOS
  3+  CBDB              ; Сравнение строк, чувстсвительное к регистру
  4+  CBDB              ;
  5+  CBDB              ; вход:
  6+  CBDB              ;  de = адрес строки 1
  7+  CBDB              ;  hl = адрес строки 2
  8+  CBDB              ;  c  = длина строки
  9+  CBDB              ;
 10+  CBDB              ; выход:
 11+  CBDB              ;  zf - строки равны
 12+  CBDB              ;
 13+  CBDB              ; регистры не сохраняются!
 14+  CBDB              ;
 15+  CBDB              ; 2022-02-11 SpaceEngineer
 16+  CBDB              ;----------------------------------------------------------------------------
 17+  CBDB
 18+  CBDB              strcmp:     ; Сравнение символов
 19+  CBDB 1A                       ld      a, (de)
 20+  CBDC BE                       cp      (hl)
 21+  CBDD C0                       ret nz          ; если символы не равны, выходим с флагом nz
 22+  CBDE 23                       inc     hl
 23+  CBDF 13                       inc     de
 24+  CBE0
 25+  CBE0                          ; Повтор цикла
 26+  CBE0 0D                       dec     c
 27+  CBE1 C2 DB CB                 jp nz,  strcmp
 28+  CBE4
 29+  CBE4                          ; Сравнили до конца и не вышли раньше - значит, строки равны
 30+  CBE4 C9                       ret             ; выходим с флагом z
 31+  CBE5
 32+  CBE5              ;----------------------------------------------------------------------------
 33+  CBE5              ; MXOS
 34+  CBE5              ; Сравнение строк, нечувстсвительное к регистру
 35+  CBE5              ;
 36+  CBE5              ; вход:
 37+  CBE5              ;  hl = адрес строки 1
 38+  CBE5              ;  de = адрес строки 2
 39+  CBE5              ;  c  = длина строки
 40+  CBE5              ;
 41+  CBE5              ; выход:
 42+  CBE5              ;  zf = 1 - строки равны
 43+  CBE5              ;
 44+  CBE5              ; регистр bc сохраняется
 45+  CBE5              ;
 46+  CBE5              ; 2022-02-11 SpaceEngineer
 47+  CBE5              ;----------------------------------------------------------------------------
 48+  CBE5
 49+  CBE5 C5           stricmp:    push    bc
 50+  CBE6              stricmp_loop:
 51+  CBE6                          ; Читаем символ из первой строки и переводим в верхний регистр
 52+  CBE6 1A                       ld      a, (de)
 53+  CBE7 CD FB CB                 call    upperCase
 54+  CBEA 47                       ld      b, a    ; сохраняем его в b
 55+  CBEB
 56+  CBEB                          ; Читаем символ из второй строки и переводим в верхний регистр
 57+  CBEB 7E                       ld      a, (hl)
 58+  CBEC CD FB CB                 call    upperCase
 59+  CBEF
 60+  CBEF                          ; Сравнение символов
 61+  CBEF B8                       cp      b
 62+  CBF0 C2 F9 CB                 jp nz,  stcicmp_exit    ; если символы не равны, выходим с флагом zf = 0
 63+  CBF3
 64+  CBF3                          ; Повтор цикла
 65+  CBF3 23                       inc     hl
 66+  CBF4 13                       inc     de
 67+  CBF5 0D                       dec     c
 68+  CBF6 C2 E6 CB                 jp nz,  stricmp_loop
 69+  CBF9
 70+  CBF9                          ; Сравнили до конца и не вышли раньше - значит, строки равны
 71+  CBF9              stcicmp_exit:
 72+  CBF9 C1                       pop     bc
 73+  CBFA C9                       ret             ; выходим с флагом zf = 1
 74+  CBFB
 75+  CBFB              ;----------------------------------------------------------------------------
 76+  CBFB              ; MXOS
 77+  CBFB              ; Преобразование кода символа КОИ-8 в верхний регистр.
 78+  CBFB              ;
 79+  CBFB              ; вход:
 80+  CBFB              ;  a = символ
 81+  CBFB              ;
 82+  CBFB              ; выход:
 83+  CBFB              ;  a = символ в верхнем регистре
 84+  CBFB              ;
 85+  CBFB              ; все регистры сохраняются
 86+  CBFB              ;
 87+  CBFB              ; 2022-02-11 SpaceEngineer
 88+  CBFB              ;----------------------------------------------------------------------------
 89+  CBFB
 90+  CBFB              upperCase:  ; Цифры, знаки и прописные английские буквы - не меняем
 91+  CBFB FE 61                    cp      61h
 92+  CBFD D8                       ret c
 93+  CBFE
 94+  CBFE                          ; Строчные английские буквы - вычитаем 20h
 95+  CBFE FE 7B                    cp      7Bh
 96+  CC00 D2 06 CC                 jp nc,  upperCase1
 97+  CC03 D6 20                    sub     20h
 98+  CC05 C9                       ret
 99+  CC06
100+  CC06              upperCase1: ; Буква ё - прибавляем 10h
101+  CC06 FE A3                    cp      0A3h
102+  CC08 D2 0E CC                 jp nc,  upperCase2
103+  CC0B C6 10                    add     10h
104+  CC0D C9                       ret
105+  CC0E
106+  CC0E              upperCase2: ; Символы псевдографики - не меняем
107+  CC0E FE C0                    cp      0C0h
108+  CC10 D8                       ret c
109+  CC11
110+  CC11                          ; Заглавные русские буквы - не маняем
111+  CC11 FE E0                    cp      0E0h
112+  CC13 D0                       ret nc
113+  CC14
114+  CC14                          ; Строчные русские буквы - прибавляем 20h
115+  CC14 C6 20                    add     20h
116+  CC16 C9                       ret
117+  CC17
118+  CC17              ;+---------------------------------------------------------------------------
119+  CC17              ; MXOS
120+  CC17              ; Сравнение расширений файлов
121+  CC17              ;
122+  CC17              ; На входе
123+  CC17              ;  de - адрес расширения 1
124+  CC17              ;  v_curFileDescr - имя с расширением 2
125+  CC17              ;
126+  CC17              ; На выходе
127+  CC17              ;  zf = 0 - расширения равны
128+  CC17              ;  de = de+3
129+  CC17              ;
130+  CC17              ; 2013-12-12 Дизассемблировано vinxru
131+  CC17              ; 2022-02-11 Доработано SpaceEngineer
132+  CC17              ;----------------------------------------------------------------------------
133+  CC17
134+  CC17              cmpFileExt:
135+  CC17                          ; Адрес расширения
136+  CC17 21 7E D3                 ld      hl, v_curFileDescr + FILE_NAME_LENGTH
137+  CC1A 0E 03                    ld      c, 3   ; cравниваем 3 символа
138+  CC1C CD E5 CB                 call    stricmp ; zf = 1 если равны
139+  CC1F
140+  CC1F                          ; Делаем так, чтобы на выходе функции de было
141+  CC1F                          ; на 3 больше, чем на входе в функцию
142+  CC1F 06 00                    ld      b, 0
143+  CC21 F5                       push    af
144+  CC22 EB                       ex      de, hl
145+  CC23 09                       add     hl, bc
146+  CC24 EB                       ex      de, hl
147+  CC25 F1                       pop     af
148+  CC26
149+  CC26                          ; Выход
150+  CC26 C9                       ret
151+  CC27
141   CC27              	INCLUDE "fatCache.inc"
  1+  CC27              ;----------------------------------------------------------------------------
  2+  CC27              ; MXOS
  3+  CC27              ; Кэш секторов fat
  4+  CC27              ;
  5+  CC27              ; 2022-02-08 Разработано SpaceEngineer
  6+  CC27              ;----------------------------------------------------------------------------
  7+  CC27
  8+  CC27                  STRUCT  FAT_CACHE_DATA          ; размер структуры 8 байт
  9+  CC27 ~            number:         DW  0FFFFh          ; номер сектора
 10+  CC27 ~            address:        DW  FAT_CACHE_ADDR  ; адрес закешированного сектора в ОЗУ
 11+  CC27 ~            accessTime:     DW  0               ; последнее время обращения к сектору
 12+  CC27 ~            isModified:     DB  0               ; модифицирован ли сектор
 13+  CC27 ~            _align:         DB  0               ; для выравнивания
 14+  CC27                  ENDS
 15+  CC27
 16+  CC27              ; Массив из FAT_CACHE_CAPACITY структур длиной FAT_CACHE_DATA, инициализирован нулями
 17+  CC27 00 00 00...  cacheData:      BLOCK   FAT_CACHE_CAPACITY * FAT_CACHE_DATA, 0
 18+  CC47
 19+  CC47              ;----------------------------------------------------------------------------
 20+  CC47              ; MXOS
 21+  CC47              ; Инициализация кэша fat
 22+  CC47              ;
 23+  CC47              ; регисты НЕ сохраняются!
 24+  CC47              ;
 25+  CC47              ; 2022-02-08 Разработано SpaceEngineer
 26+  CC47              ;----------------------------------------------------------------------------
 27+  CC47
 28+  CC47              resetSectorCache:
 29+  CC47                      ; bc = системное время
 30+  CC47 CD 5D CD             call    getSystemTime
 31+  CC4A
 32+  CC4A                      ; В цикле записываем начальные значения во поля address
 33+  CC4A 11 00 FB             ld      de, FAT_CACHE_ADDR      ; адрес буфера секторов
 34+  CC4D 21 27 CC             ld      hl, cacheData           ; адрес первого элемента в массиве
 35+  CC50 3E 04                ld      a,  FAT_CACHE_CAPACITY  ; счетчик цикла
 36+  CC52
 37+  CC52              resetCacheLoop:
 38+  CC52                      ; Поле number = 0FFFFh
 39+  CC52 36 FF                ld      (hl), 0FFh
 40+  CC54 23                   inc     hl
 41+  CC55 36 FF                ld      (hl), 0FFh
 42+  CC57 23                   inc     hl
 43+  CC58                      ; Поле address = de
 44+  CC58 73                   ld      (hl), e
 45+  CC59 23                   inc     hl
 46+  CC5A 72                   ld      (hl), d
 47+  CC5B 23                   inc     hl
 48+  CC5C                      ; Поле accessTime = bc
 49+  CC5C 71                   ld      (hl), c
 50+  CC5D 23                   inc     hl
 51+  CC5E 70                   ld      (hl), b
 52+  CC5F 23                   inc     hl
 53+  CC60                      ; Поле isModified = 0
 54+  CC60 36 00                ld      (hl), 0
 55+  CC62 23                   inc     hl
 56+  CC63                      ; Поле isLoaded = 0
 57+  CC63 36 00                ld      (hl), 0
 58+  CC65 23                   inc     hl
 59+  CC66
 60+  CC66                      ; de += SECTOR_SIZE
 61+  CC66 14                   inc     d   ; это работает только с секторами по 256 байт
 62+  CC67
 63+  CC67                      ; Повтор чикла
 64+  CC67 3D                   dec     a
 65+  CC68 C2 52 CC             jp nz,  resetCacheLoop
 66+  CC6B
 67+  CC6B C9                   ret
 68+  CC6C
 69+  CC6C              ;----------------------------------------------------------------------------
 70+  CC6C              ; MXOS
 71+  CC6C              ; Получение адреса закешированного сектора в памяти.
 72+  CC6C              ; Если сектор не найден в кэше, он загружается с текущего накопителя.
 73+  CC6C              ;
 74+  CC6C              ; вход:
 75+  CC6C              ;   de = номер сектора
 76+  CC6C              ;   a  = 1 - установить флаг isModified сектора
 77+  CC6C              ;
 78+  CC6C              ; выход:
 79+  CC6C              ;   hl = адрес сектора в буфере
 80+  CC6C              ;
 81+  CC6C              ;   регистры de, bc сохраняются
 82+  CC6C              ;
 83+  CC6C              ; 2022-02-08 Разработано SpaceEngineer
 84+  CC6C              ;----------------------------------------------------------------------------
 85+  CC6C
 86+  CC6C              getSectorAddressInCache:
 87+  CC6C C5                   push    bc
 88+  CC6D D5                   push    de
 89+  CC6E 47                   ld      b, a    ; b = isModified
 90+  CC6F EB                   ex      hl, de
 91+  CC70
 92+  CC70                      ; Находим сектор в кэше; если нету - кешируем
 93+  CC70                      ; вход:  hl = номер сектора на диске
 94+  CC70                      ; выход: hl = адрес сектора в ОЗУ
 95+  CC70 CD 8D CC             call    cacheSector
 96+  CC73
 97+  CC73 D1                   pop     de
 98+  CC74 C1                   pop     bc
 99+  CC75 C9                   ret
100+  CC76
101+  CC76              ;----------------------------------------------------------------------------
102+  CC76              ; MXOS
103+  CC76              ; Получение адреса ячейки fat.
104+  CC76              ; Если сектор fat не найден в кэше, он загружается с текущего накопителя.
105+  CC76              ;
106+  CC76              ; вход:
107+  CC76              ;   de = номер ячейки fat
108+  CC76              ;   a  = 1 - установить флаг isModified сектора
109+  CC76              ;
110+  CC76              ; выход:
111+  CC76              ;   hl = адрес ячейки в буфере
112+  CC76              ;
113+  CC76              ; 2022-02-08 Разработано SpaceEngineer
114+  CC76              ;----------------------------------------------------------------------------
115+  CC76
116+  CC76              getFatCellAddress:
117+  CC76 C5                   push    bc
118+  CC77 47                   ld      b, a ; b = isModified
119+  CC78
120+  CC78                      ; Вычисляем номер сектора, где находится искомая ячейка fat
121+  CC78                      ; fatSectorNum  = (N * 2) / v_diskInfo.sectorSize + v_diskInfo.resSectors;
122+  CC78                      ; fatCellOffset = (N * 2) % v_diskInfo.sectorSize;
123+  CC78 2A C5 D2             ld      hl, (v_diskInfo.sectorSize)
124+  CC7B EB                   ex      hl, de
125+  CC7C 29                   add     hl, hl      ; hl = N * 2
126+  CC7D CD 61 D2             call    div_hl_de   ; выход: hl = номер сектора от начала fat; de = смещение ячейки в секторе
127+  CC80 D5                   push    de          ; de = смещение ячейки в секторе
128+  CC81 EB                   ex      hl, de
129+  CC82 2A C9 D2             ld      hl, (v_diskInfo.resSectors)
130+  CC85 19                   add     hl, de      ; hl += v_diskInfo.resSectors
131+  CC86
132+  CC86                      ; Находим сектор в кэше; если нету - кешируем
133+  CC86                      ; вход:  hl = номер сектора на диске
134+  CC86                      ; выход: hl = адрес сектора в ОЗУ
135+  CC86 CD 8D CC             call    cacheSector
136+  CC89
137+  CC89                      ; Находим смещение ячейки fat в этом секторе
138+  CC89 D1                   pop     de      ; de = смещение ячейки в секторе
139+  CC8A 19                   add     hl, de  ; hl = адрес ячейки в секторе
140+  CC8B
141+  CC8B C1                   pop     bc
142+  CC8C C9                   ret
143+  CC8D
144+  CC8D              ;----------------------------------------------------------------------------
145+  CC8D              ; MXOS
146+  CC8D              ; Поиск сектора в кэше. Если сектор не найден, то он загружается с накопителя.
147+  CC8D              ;
148+  CC8D              ; вход:
149+  CC8D              ;   hl = номер сектора
150+  CC8D              ;   b  = флаг модификации
151+  CC8D              ;
152+  CC8D              ; выход:
153+  CC8D              ;   hl = адрес начала сектора в памяти
154+  CC8D              ;
155+  CC8D              ; регистры de, bc сохраняются
156+  CC8D              ;
157+  CC8D              ; 2022-02-08 Разработано SpaceEngineer
158+  CC8D              ;----------------------------------------------------------------------------
159+  CC8D
160+  CC8D              cacheSector:
161+  CC8D                      ; Сохраняем регистры
162+  CC8D D5                   push    de
163+  CC8E C5                   push    bc
164+  CC8F
165+  CC8F                      ; Просматриваем массив структур cacheData в поисках сектора с номером hl
166+  CC8F EB                   ex      hl, de                                      ; de = номер для поиска
167+  CC90 21 27 CC             ld      hl, cacheData + FAT_CACHE_DATA.number       ; hl = адрес поля number в первом элементе массива
168+  CC93 0E 04                ld      c,  FAT_CACHE_CAPACITY                      ; счетчик цикла
169+  CC95              cff_FindSector:
170+  CC95 CD 69 CD             call    cmp_m_de            ; сравниваем [hl] и de
171+  CC98 CA D8 CC             jp z,   cff_SectorFound     ; если равно, значит есть такой сектор в кэше
172+  CC9B C5                   push    bc                  ; иначе переходим на следущий элемент массива
173+  CC9C 01 08 00             ld      bc, FAT_CACHE_DATA  ; bc = размер структуры FAT_CACHE_DATA
174+  CC9F 09                   add     hl, bc
175+  CCA0 C1                   pop     bc
176+  CCA1 0D                   dec     c                   ; повтор цикла
177+  CCA2 C2 95 CC             jp      nz, cff_FindSector
178+  CCA5
179+  CCA5                      ; Не не нашли сектор в массиве, загружаем его с накопителя на место наиболее давно использовавашегося
180+  CCA5 D5                   push    de  ; de = номер сектора, который надо загрузить
181+  CCA6
182+  CCA6                      ; Ищем наиболее давно использовавашийся сектор (т.е. у которого самый маленький accessTime)
183+  CCA6 11 FF FF             ld      de, 0FFFFh                                  ; de = максимальный найденый accessTime сектора
184+  CCA9 21 2B CC             ld      hl, cacheData + FAT_CACHE_DATA.accessTime   ; hl = адрес поля accessTime в первом элементе массива
185+  CCAC 01 04 00             ld      bc, FAT_CACHE_CAPACITY                      ; b  = 0, c = счетчик цикла
186+  CCAF              cff_FindOldestSector:
187+  CCAF CD 69 CD             call    cmp_m_de            ; сравниваем [hl] и de
188+  CCB2 D2 BA CC             jp nc,  cff_next            ; переход, если [hl] >= de
189+  CCB5 5E                   ld      e, (hl)             ; тут [hl] < de, запоминаем accessTime сектора в de
190+  CCB6 23                   inc     hl
191+  CCB7 56                   ld      d, (hl)
192+  CCB8 2B                   dec     hl
193+  CCB9 41                   ld      b, c                ; запоминаем итерацию цикла сектора в b
194+  CCBA              cff_next:
195+  CCBA C5                   push    bc                  ; переходим на следущий элемент массива
196+  CCBB 01 08 00             ld      bc, FAT_CACHE_DATA  ; bc = размер структуры FAT_CACHE_DATA
197+  CCBE 09                   add     hl, bc
198+  CCBF C1                   pop     bc
199+  CCC0 0D                   dec     c                   ; повтор цикла
200+  CCC1 C2 AF CC             jp      nz, cff_FindOldestSector
201+  CCC4
202+  CCC4                      ; Нашли наиболее давно использовавашийся сектор
203+  CCC4 3E 04                ld      a, FAT_CACHE_CAPACITY
204+  CCC6 90                   sub     b       ; a = индекс найденного сектора
205+  CCC7 17                   rla
206+  CCC8 17                   rla
207+  CCC9 17                   rla             ; a = a * 8 (размер структуры FAT_CACHE_DATA)
208+  CCCA 4F                   ld      c, a
209+  CCCB 06 00                ld      b, 0    ; bc = смещение сектора в массиве cacheData
210+  CCCD 21 27 CC             ld      hl, cacheData
211+  CCD0 09                   add     hl, bc  ; hl = адрес элемента массива
212+  CCD1
213+  CCD1                      ; Прежде чем загрузить новый сектор, старый надо сохранить, если его isModified не ноль
214+  CCD1 CD FF CC             call    saveSectorFromCache    ; записываем сектор на накопитель
215+  CCD4
216+  CCD4                      ; Загружаем новый сектор на место старого
217+  CCD4 D1                   pop     de              ; de = номер сектора, который надо загрузить
218+  CCD5 CD EC CC             call    loadSectorToCache    ; загружаем сектор с накопителя
219+  CCD8
220+  CCD8                      ; Сектор найден или загружен, возвращаем его адрес
221+  CCD8                      ; Здесь hl = адрес элемента массива cacheData этого сектора
222+  CCD8              cff_SectorFound:
223+  CCD8
224+  CCD8 23                   inc     hl
225+  CCD9 23                   inc     hl      ; теперь hl = адрес поля address
226+  CCDA
227+  CCDA                      ; Читаем адрес сектора в de
228+  CCDA 5E                   ld      e, (hl)
229+  CCDB 23                   inc     hl
230+  CCDC 56                   ld      d, (hl) ; de = адрес сектора
231+  CCDD 23                   inc     hl      ; теперь hl = адрес поля accessTime
232+  CCDE
233+  CCDE                      ; Уcтанавливаем accessTime сектора
234+  CCDE CD 5D CD             call    getSystemTime;  bc = системное время
235+  CCE1
236+  CCE1 71                   ld      (hl), c
237+  CCE2 23                   inc     hl
238+  CCE3 70                   ld      (hl), b ; de = адрес сектора
239+  CCE4 23                   inc     hl      ; теперь hl = адрес поля isModified
240+  CCE5
241+  CCE5                      ; Устанавливаем isModified, если в регистре b на входе в функцию был не ноль
242+  CCE5 C1                   pop     bc      ; b = флаг модификации
243+  CCE6 7E                   ld      a, (hl)
244+  CCE7 B0                   or      b
245+  CCE8 77                   ld      (hl), a
246+  CCE9
247+  CCE9                      ; hl = адрес сектора
248+  CCE9 EB                   ex      hl, de
249+  CCEA
250+  CCEA                      ; Восстанавливаем регистры и выходим
251+  CCEA D1                   pop     de
252+  CCEB C9                   ret
253+  CCEC
254+  CCEC              ;----------------------------------------------------------------------------
255+  CCEC              ; MXOS
256+  CCEC              ; Загрузка сектора с накопителя в кэш
257+  CCEC              ;
258+  CCEC              ; вход:
259+  CCEC              ;   hl = адрес структуры FAT_CACHE_DATA с описанием сектора
260+  CCEC              ;   de = номер сектора
261+  CCEC              ;
262+  CCEC              ; регистры hl, de, bc сохраняются
263+  CCEC              ;
264+  CCEC              ; 2022-02-08 Разработано SpaceEngineer
265+  CCEC              ;----------------------------------------------------------------------------
266+  CCEC
267+  CCEC              loadSectorToCache:
268+  CCEC E5                   push    hl
269+  CCED
270+  CCED                      ; Записываем номер сектора в структуру
271+  CCED 73                   ld      (hl), e
272+  CCEE 23                   inc     hl
273+  CCEF 72                   ld      (hl), d
274+  CCF0 23                   inc     hl      ; теперь hl = адрес поля address
275+  CCF1 D5                   push    de
276+  CCF2
277+  CCF2                      ; Читаем в de адрес загрузки сектора
278+  CCF2 5E                   ld      e, (hl)
279+  CCF3 23                   inc     hl
280+  CCF4 56                   ld      d, (hl)
281+  CCF5 23                   inc     hl
282+  CCF6
283+  CCF6                      ; Загружаем сектор
284+  CCF6                      ; Номер сектора = номер сектора, т.к. fat начинается с начала диска
285+  CCF6 EB                   ex      hl, de  ; hl = адрес буфера
286+  CCF7 D1                   pop     de      ; de = номер сектора
287+  CCF8 06 02                ld      b, 2    ; режим - чтение
288+  CCFA CD 63 C8             call    j_diskDriver
289+  CCFD
290+  CCFD                      ; Восстанавливаем регситры и выходим
291+  CCFD E1                   pop     hl
292+  CCFE C9                   ret
293+  CCFF
294+  CCFF              ;----------------------------------------------------------------------------
295+  CCFF              ; MXOS
296+  CCFF              ; Запись сектора из кэша на накопитель, если его isModified не ноль
297+  CCFF              ;
298+  CCFF              ; вход:
299+  CCFF              ;   hl = адрес структуры FAT_CACHE_DATA с описанием сектора
300+  CCFF              ;
301+  CCFF              ;   регистры hl, de, bc сохраняются
302+  CCFF              ;
303+  CCFF              ; 2022-02-08 Разработано SpaceEngineer
304+  CCFF              ;----------------------------------------------------------------------------
305+  CCFF
306+  CCFF              saveSectorFromCache:
307+  CCFF E5                   push    hl
308+  CD00 D5                   push    de
309+  CD01
310+  CD01                      ; Проверяем, был ли изменен сектор
311+  CD01 C5                   push    bc
312+  CD02 01 06 00             ld      bc, FAT_CACHE_DATA.isModified   ; bc = смещение поля isModified
313+  CD05 09                   add     hl, bc      ; hl = адрес поля isModified
314+  CD06 C1                   pop     bc
315+  CD07 7E                   ld      a, (hl)     ; a = isModified
316+  CD08 B7                   or      a           ; a == 0?
317+  CD09 CA 1F CD             jp z,   ssfc_Exit   ; если isModified == 0, сектор не был изменен, и его не надо сохранять
318+  CD0C
319+  CD0C                      ; Обнуляем isModified
320+  CD0C 36 00                ld      (hl), 0
321+  CD0E
322+  CD0E 2B                   dec     hl  ; теперь hl = адрес поля accessTime (ст. байт)
323+  CD0F
324+  CD0F 2B                   dec     hl
325+  CD10 2B                   dec     hl  ; теперь hl = адрес поля address (ст. байт)
326+  CD11
327+  CD11                      ; Читаем в de адрес загрузки сектора
328+  CD11 56                   ld      d, (hl)
329+  CD12 2B                   dec     hl
330+  CD13 5E                   ld      e, (hl)
331+  CD14 D5                   push    de  ; сохраняем его в стек
332+  CD15
333+  CD15 2B                   dec     hl  ; теперь hl = адрес поля number (ст. байт)
334+  CD16
335+  CD16                      ; Читаем в de номер сектора
336+  CD16 56                   ld      d, (hl)
337+  CD17 2B                   dec     hl
338+  CD18 5E                   ld      e, (hl)
339+  CD19
340+  CD19                      ; Записываем сектор
341+  CD19                      ; de = номер сектора
342+  CD19 E1                   pop     hl      ; hl = адрес загрузки сектора
343+  CD1A 06 01                ld      b, 1    ; режим - запись
344+  CD1C CD 63 C8             call    j_diskDriver
345+  CD1F
346+  CD1F              ssfc_Exit:
347+  CD1F                      ; Восстанавливаем регситры и выходим
348+  CD1F D1                   pop     de
349+  CD20 E1                   pop     hl
350+  CD21 C9                   ret
351+  CD22
352+  CD22              ;----------------------------------------------------------------------------
353+  CD22              ; MXOS
354+  CD22              ; Запись всех закешированных секторов на накопитель, если их isModified не ноль
355+  CD22              ;
356+  CD22              ; регистры hl, de, bc сохраняются
357+  CD22              ;
358+  CD22              ; 2022-02-08 Разработано SpaceEngineer
359+  CD22              ;----------------------------------------------------------------------------
360+  CD22
361+  CD22              saveSectorCache:
362+  CD22                      ; Сохраняем регситры
363+  CD22 E5                   push    hl
364+  CD23 D5                   push    de
365+  CD24 C5                   push    bc
366+  CD25
367+  CD25 21 27 CC             ld      hl, cacheData           ; hl = первый элемент в массиве cacheData
368+  CD28 11 08 00             ld      de, FAT_CACHE_DATA      ; de = размер элемента массива cacheData
369+  CD2B 0E 04                ld      c,  FAT_CACHE_CAPACITY  ; счетчик цикла
370+  CD2D              saveSectorCacheLoop:
371+  CD2D CD FF CC             call    saveSectorFromCache     ; записываем сектор на накопитель
372+  CD30 19                   add     hl, de
373+  CD31 0D                   dec     c
374+  CD32 C2 2D CD             jp nz,  saveSectorCacheLoop
375+  CD35
376+  CD35                      ; Восстанавливаем регситры и выходим
377+  CD35 C1                   pop     bc
378+  CD36 D1                   pop     de
379+  CD37 E1                   pop     hl
380+  CD38 C9                   ret
381+  CD39
382+  CD39              ;----------------------------------------------------------------------------
383+  CD39              ; MXOS
384+  CD39              ; Вычисление номера сектора по номеру кластера
385+  CD39              ;
386+  CD39              ; вход:
387+  CD39              ;   de = номер кластера
388+  CD39              ;
389+  CD39              ; формула:
390+  CD39              ;   de = (de - 2) * v_diskInfo.sectorsPerCluster + v_diskInfo.dataStartSector
391+  CD39              ;
392+  CD39              ; выход:
393+  CD39              ;   de = номер сектора
394+  CD39              ;
395+  CD39              ;   регистры bc, hl сохраняются
396+  CD39              ;
397+  CD39              ; 2022-02-14 Разработано SpaceEngineer
398+  CD39              ;----------------------------------------------------------------------------
399+  CD39
400+  CD39              fatClusterToSector:
401+  CD39 E5                   push    hl
402+  CD3A
403+  CD3A 1B                   dec     de
404+  CD3B 1B                   dec     de          ; de -= 2 (нумерация кластеров начинается с 2)
405+  CD3C
406+  CD3C 2A C7 D2             ld      hl, (v_diskInfo.sectorsPerCluster)
407+  CD3F CD 3C D2             call    mul_hl_de   ; hl = de * BPB_SecPerClus
408+  CD42 EB                   ex      hl, de
409+  CD43
410+  CD43 2A D9 D2             ld      hl, (v_diskInfo.dataStartSector)
411+  CD46 19                   add     hl, de
412+  CD47 EB                   ex      hl, de
413+  CD48
414+  CD48 E1                   pop     hl
415+  CD49 C9                   ret
416+  CD4A
417+  CD4A              ;----------------------------------------------------------------------------
418+  CD4A              ; MXOS
419+  CD4A              ; Начало цикла по файлам в каталоге
420+  CD4A              ;
421+  CD4A              ; выход:
422+  CD4A              ;   de = номер первого сектора каталога
423+  CD4A              ;   с  = количество секторов каталога (мл. байт)
424+  CD4A              ;
425+  CD4A              ;   остальные регистры сохраняются
426+  CD4A              ;
427+  CD4A              ; 2022-02-14 Разработано SpaceEngineer
428+  CD4A              ;----------------------------------------------------------------------------
429+  CD4A
430+  CD4A              fatBeginDirLoop:
431+  CD4A EB                   ex      hl, de
432+  CD4B 2A D7 D2             ld      hl, (v_diskInfo.dirStartSector)
433+  CD4E EB                   ex      hl, de                      ; de = номер первого сектора каталога
434+  CD4F 3A CD D2             ld      a, (v_diskInfo.dirSectors)  ; a = количество секторов каталога (мл. байт)
435+  CD52 4F                   ld      c,  a                       ; с  = счетчик цикла
436+  CD53 C9                   ret
437+  CD54
438+  CD54              ;----------------------------------------------------------------------------
439+  CD54              ; MXOS
440+  CD54              ; Установка сектору каталога флага isModified
441+  CD54              ;
442+  CD54              ; вход:
443+  CD54              ;  v_cachedSector - номер сектора
444+  CD54              ;
445+  CD54              ; выход:
446+  CD54              ;   bc = системное время
447+  CD54              ;
448+  CD54              ;   регистр bc сохраняется
449+  CD54              ;
450+  CD54              ; 2022-02-08 Разработано SpaceEngineer
451+  CD54              ;----------------------------------------------------------------------------
452+  CD54
453+  CD54              markDirSectorAsModified:
454+  CD54 2A A1 D2             ld      hl, (v_cachedSector)
455+  CD57 EB                   ex      hl, de  ; de = номер сектора
456+  CD58 3E 01                ld      a, 1    ; флаг - сектор будет изменен
457+  CD5A
458+  CD5A                      ; Загрузка сектора в кэш; если сектор уже в кэше,
459+  CD5A                      ; функция просто найдет его и изменит флаг
460+  CD5A C3 6C CC             jp      getSectorAddressInCache
461+  CD5D
462+  CD5D              ;----------------------------------------------------------------------------
463+  CD5D              ; MXOS
464+  CD5D              ; Получение текущего системного времени
465+  CD5D              ;
466+  CD5D              ; В "Специалисте" нет часов реального времени (RTC), поэтому системное время
467+  CD5D              ; - это просто счетчик, увеличивающийся каждый раз при обращении. В будущем
468+  CD5D              ; можно будет сделать вермя через таймер ВИ53, или через драйвер RTC, при его
469+  CD5D              ; наличии в системе.
470+  CD5D              ;
471+  CD5D              ; выход:
472+  CD5D              ;   bc = системное время
473+  CD5D              ;
474+  CD5D              ; все остальные регистры сохраняеюся
475+  CD5D              ;
476+  CD5D              ; 2022-02-08 Разработано SpaceEngineer
477+  CD5D              ;----------------------------------------------------------------------------
478+  CD5D
479+  CD5D              getSystemTime:
480+  CD5D E5                   push    hl
481+  CD5E 2A B3 D2             ld      hl, (v_fakeSystemTime)
482+  CD61 23                   inc     hl
483+  CD62 22 B3 D2             ld      (v_fakeSystemTime), hl
484+  CD65 44                   ld      b, h
485+  CD66 4D                   ld      c, l
486+  CD67 E1                   pop     hl
487+  CD68 C9                   ret
488+  CD69
489+  CD69              ;----------------------------------------------------------------------------
490+  CD69              ; MXOS
491+  CD69              ; Сравнение слова по адресу hl и de
492+  CD69              ; Псевдокод: cp [hl], de
493+  CD69              ;
494+  CD69              ; выход:
495+  CD69              ;   флаги c, z
496+  CD69              ;
497+  CD69              ; 2022-02-08 Разработано SpaceEngineer
498+  CD69              ;----------------------------------------------------------------------------
499+  CD69
500+  CD69              cmp_m_de:
501+  CD69 23                   inc   hl
502+  CD6A 7E                   ld    a, (hl)
503+  CD6B 2B                   dec   hl
504+  CD6C BA                   cp    d
505+  CD6D D8                   ret   c
506+  CD6E C0                   ret   nz
507+  CD6F 7E                   ld    a, (hl)
508+  CD70 BB                   cp    e
509+  CD71 C9                   ret
510+  CD72
142   CD72              	INCLUDE "fatFindCluster.inc"
  1+  CD72              ;+---------------------------------------------------------------------------
  2+  CD72              ; MXOS
  3+  CD72              ; Поиск свободного кластера
  4+  CD72              ;
  5+  CD72              ; На выходе
  6+  CD72              ;  cf - ошибка
  7+  CD72              ;  de - номер кластера
  8+  CD72              ;  регистры bc, hl сохраняются
  9+  CD72              ;
 10+  CD72              ; 2013-12-12 Дизассемблировано vinxru
 11+  CD72              ; 2022-02-04 Переработано SpaceEngineer
 12+  CD72              ;----------------------------------------------------------------------------
 13+  CD72
 14+  CD72              fatFindClusterFirst:
 15+  CD72                          ; Сохраняем регистры
 16+  CD72 E5                       push  hl
 17+  CD73
 18+  CD73                          ; de = номер первого кластера для поиска
 19+  CD73                          ; Первые 2 ячейки fat зарезервированы
 20+  CD73 11 02 00                 ld    de, 2
 21+  CD76
 22+  CD76 C3 7F CD                 jp    fatFindClusterCommon
 23+  CD79
 24+  CD79              ;----------------------------------------------------------------------------
 25+  CD79              ; Поиск следующего свободного кластера
 26+  CD79              ;
 27+  CD79              ; На выходе
 28+  CD79              ;  cf - ошибка
 29+  CD79              ;  de - номер кластера
 30+  CD79              ;  регистры bc, hl сохраняются
 31+  CD79              ;----------------------------------------------------------------------------
 32+  CD79
 33+  CD79              fatFindClusterNext:
 34+  CD79                          ; Сохраняем регистры
 35+  CD79 E5                       push    hl
 36+  CD7A
 37+  CD7A                          ; Предыдущий найденный кластер
 38+  CD7A 2A 97 D2                 ld      hl, (v_findCluster)
 39+  CD7D
 40+  CD7D                          ; Начинаем поиск со следующего кластера
 41+  CD7D 23                       inc     hl
 42+  CD7E EB                       ex      hl, de
 43+  CD7F
 44+  CD7F                          ; Ищем свободный кластер: перебераем все ячейки fat, пока не найдём 0
 45+  CD7F              fatFindClusterCommon:
 46+  CD7F C5                       push    bc
 47+  CD80 2A D5 D2                 ld      hl, (v_diskInfo.fatNumCells)
 48+  CD83 44                       ld      b, h
 49+  CD84 4D                       ld      c, l    ; bc = кол-во ячеек fat
 50+  CD85
 51+  CD85              fatFindClusterLoop:
 52+  CD85                          ; Запоминаем номер последнего кластера в hl
 53+  CD85 62                       ld      h, d
 54+  CD86 6B                       ld      l, e
 55+  CD87
 56+  CD87                          ; de = fat[de]
 57+  CD87 CD A6 CD                 call    fatReadCluster
 58+  CD8A
 59+  CD8A                          ; Сравниваем de с нулем
 60+  CD8A 7A                       ld      a, d
 61+  CD8B B3                       or      e
 62+  CD8C CA 9E CD                 jp z,   fatFindClusterOk  ; найден
 63+  CD8F
 64+  CD8F                          ; Следующий кластер
 65+  CD8F 54                       ld      d, h
 66+  CD90 5D                       ld      e, l
 67+  CD91 13                       inc     de
 68+  CD92
 69+  CD92                          ; Счётчик просмотренных ячеек fat
 70+  CD92 0B                       dec     bc
 71+  CD93 78                       ld      a, b
 72+  CD94 B1                       or      c
 73+  CD95 C2 85 CD                 jp nz,  fatFindClusterLoop  ; повтор цикла
 74+  CD98
 75+  CD98              ;---------------------------------------------------------------------------
 76+  CD98
 77+  CD98                          ; Свободный кластер не найден
 78+  CD98                          ; Восстанавливаем регистры и выходим с a=1, CF=1, ZF=0
 79+  CD98 C1                       pop     bc
 80+  CD99 E1                       pop     hl
 81+  CD9A 3E 01                    ld      a, 1
 82+  CD9C 37                       scf
 83+  CD9D C9                       ret
 84+  CD9E
 85+  CD9E              ;---------------------------------------------------------------------------
 86+  CD9E
 87+  CD9E                          ; Свободный кластер найден
 88+  CD9E              fatFindClusterOk:
 89+  CD9E                          ; Устаналиваем ZF=0. Номер кластера не может быть нулевым.
 90+  CD9E                          ; В случае ошибки мы тоже выходим с ZF=1
 91+  CD9E B7                       or      a
 92+  CD9F
 93+  CD9F                          ; Для ускорения поиска сохраняем номер найденного кластера в v_findCluster
 94+  CD9F 22 97 D2                 ld      (v_findCluster), hl
 95+  CDA2 EB                       ex      hl, de
 96+  CDA3
 97+  CDA3                          ; Восстанавливаем регистры и выходим с CF=0, ZF=0
 98+  CDA3 C1                       pop     bc
 99+  CDA4 E1                       pop     hl
100+  CDA5 C9                       ret
101+  CDA6
143   CDA6                  INCLUDE "fatReadWriteCluster.inc"
  1+  CDA6              ;----------------------------------------------------------------------------
  2+  CDA6              ; MXOS
  3+  CDA6              ;
  4+  CDA6              ; Чтение номера кластера из таблицы fat
  5+  CDA6              ;
  6+  CDA6              ; вход:
  7+  CDA6              ;   de = номер ячейки, чтобы прочитать
  8+  CDA6              ;
  9+  CDA6              ; выход:
 10+  CDA6              ;   de = номер кластера, прочитанный из ячейки
 11+  CDA6              ;   hl, bc, a - сохраняются
 12+  CDA6              ;
 13+  CDA6              ; СИ аналог:
 14+  CDA6              ;   de = fat[de];
 15+  CDA6              ;
 16+  CDA6              ; 2022-02-04 SpaceEngineer
 17+  CDA6              ;----------------------------------------------------------------------------
 18+  CDA6
 19+  CDA6              fatReadCluster:
 20+  CDA6 E5                       push    hl
 21+  CDA7
 22+  CDA7                          ; вычисляем адрес ячейки, куда указывает de
 23+  CDA7 AF                       xor     a ; флаг - сектор fat не будет модифицироваться
 24+  CDA8 CD 76 CC                 call    getFatCellAddress
 25+  CDAB
 26+  CDAB                          ; читаем в de номер кластера из fat по адресу hl
 27+  CDAB 5E                       ld      e, (hl)
 28+  CDAC 23                       inc     hl
 29+  CDAD 56                       ld      d, (hl)
 30+  CDAE
 31+  CDAE                          ; восстанавливаем регистры и выходим
 32+  CDAE E1                       pop     hl
 33+  CDAF C9                       ret
 34+  CDB0
 35+  CDB0              ;----------------------------------------------------------------------------
 36+  CDB0              ; MXOS
 37+  CDB0              ;
 38+  CDB0              ; Запись номера кластера в таблицу fat и переход на следующий адрес ячейки
 39+  CDB0              ;
 40+  CDB0              ; вход:
 41+  CDB0              ;   hl = номер ячейки fat, куда писать
 42+  CDB0              ;   de = номер кластера, чтобы записать
 43+  CDB0              ;
 44+  CDB0              ; выход:
 45+  CDB0              ;   hl = de
 46+  CDB0              ;   bc, a - сохраняются
 47+  CDB0              ;
 48+  CDB0              ; СИ аналог:
 49+  CDB0              ;   fat[de] = hl;
 50+  CDB0              ;   hl = de;
 51+  CDB0              ;
 52+  CDB0              ; 2022-02-04 SpaceEngineer
 53+  CDB0              ;----------------------------------------------------------------------------
 54+  CDB0
 55+  CDB0              fatWriteCluster:
 56+  CDB0                          ; вычисляем адрес ячейки, куда указывает hl
 57+  CDB0 D5                       push    de
 58+  CDB1 EB                       ex      hl, de
 59+  CDB2 3E 01                    ld      a, 1 ; флаг - сектр fat будет модифицироваться
 60+  CDB4 CD 76 CC                 call    getFatCellAddress
 61+  CDB7 D1                       pop     de
 62+  CDB8
 63+  CDB8                          ; записываем номер кластера из de в fat по адресу hl
 64+  CDB8 73                       ld      (hl), e
 65+  CDB9 23                       inc     hl
 66+  CDBA 72                       ld      (hl), d
 67+  CDBB
 68+  CDBB                          ; hl = de
 69+  CDBB 62                       ld      h, d
 70+  CDBC 6B                       ld      l, e
 71+  CDBD C9                       ret
 72+  CDBE
 73+  CDBE              ;----------------------------------------------------------------------------
 74+  CDBE              ; MXOS
 75+  CDBE              ;
 76+  CDBE              ; Освобождение кластера в таблице fat
 77+  CDBE              ;
 78+  CDBE              ; вход:
 79+  CDBE              ;   de = номер кластера
 80+  CDBE              ;
 81+  CDBE              ; выход:
 82+  CDBE              ;   de = номер следующего кластера
 83+  CDBE              ;   hl, bc, a - сохраняются
 84+  CDBE              ;
 85+  CDBE              ; СИ аналог:
 86+  CDBE              ;   fat[de] = 0x0000;
 87+  CDBE              ;
 88+  CDBE              ; 2022-02-04 SpaceEngineer
 89+  CDBE              ;----------------------------------------------------------------------------
 90+  CDBE
 91+  CDBE              fatFreeCluster:
 92+  CDBE E5                       push    hl
 93+  CDBF
 94+  CDBF                          ; вычисляем адрес ячейки, куда указывает hl
 95+  CDBF D5                       push    de
 96+  CDC0 EB                       ex      hl, de
 97+  CDC1 3E 01                    ld      a, 1 ; флаг - сектор fat будет модифицироваться
 98+  CDC3 CD 76 CC                 call    getFatCellAddress
 99+  CDC6 D1                       pop     de
100+  CDC7
101+  CDC7                          ; читаем номер кластера из fat, и сразу записываем туда нули
102+  CDC7 5E                       ld      e, (hl)
103+  CDC8 36 00                    ld      (hl), 0
104+  CDCA 23                       inc     hl
105+  CDCB 56                       ld      d, (hl)
106+  CDCC 36 00                    ld      (hl), 0
107+  CDCE
108+  CDCE                          ; восстанавливаем регистры и выходим
109+  CDCE E1                       pop     hl
110+  CDCF C9                       ret
111+  CDD0
112+  CDD0
144   CDD0                  INCLUDE "fatGetFreeSpace.inc"
  1+  CDD0              ;----------------------------------------------------------------------------
  2+  CDD0              ; MXOS
  3+  CDD0              ; Определение свободного объема накопителя
  4+  CDD0              ;
  5+  CDD0              ; выход:
  6+  CDD0              ;   de = количество свободных кластеров
  7+  CDD0              ;
  8+  CDD0              ; 2022-02-09 Разработано SpaceEngineer
  9+  CDD0              ;----------------------------------------------------------------------------
 10+  CDD0
 11+  CDD0              getDriveFreeSpace:
 12+  CDD0                          ; Сохраняем регистры
 13+  CDD0 E5                       push    hl
 14+  CDD1 C5                       push    bc
 15+  CDD2
 16+  CDD2                          ; Счетчик свободных кластеров
 17+  CDD2 11 00 00                 ld      de, 0
 18+  CDD5
 19+  CDD5                          ; Кэшируем по очереди все секторы таблицы fat,
 20+  CDD5                          ; и подсчитываем общее коичество свободных кластеров в них
 21+  CDD5 2A CB D2                 ld      hl, (v_diskInfo.fatSectors) ; hl = количество секторов fat на устройстве
 22+  CDD8 7D                       ld      a, l                        ; a  = количество секторов fat на устройстве (считаем, что их меньше 256)
 23+  CDD9 F5                       push    af
 24+  CDDA 2A C9 D2                 ld      hl, (v_diskInfo.resSectors) ; hl = номер сектора: начинаем с resSectors
 25+  CDDD              fatSectorsLoop:
 26+  CDDD E5                       push    hl              ; hl = номер сектора
 27+  CDDE 06 00                    ld      b, 0            ; флаг - сектор не будет модифицироваться
 28+  CDE0 CD 8D CC                 call    cacheSector     ; теперь hl = адрес буфера с загруженным сектором fat
 29+  CDE3
 30+  CDE3                          ; Цикл по кластерам сектора fat
 31+  CDE3 01 80 00                 ld      bc, SECTOR_SIZE/2   ; счетчик цикла
 32+  CDE6              sectorClustersLoop:
 33+  CDE6                          ; Читаем в a номер кластера из ячейки по адресу hl и сразу сравниваем с нулем
 34+  CDE6 7E                       ld      a, (hl)
 35+  CDE7 23                       inc     hl
 36+  CDE8 B6                       or      (hl)
 37+  CDE9 23                       inc     hl
 38+  CDEA
 39+  CDEA                          ; Если кластер пустой, увеличиваем счетчик свободных кластеров
 40+  CDEA C2 EE CD                 jp nz,  gdfs_nonEmpty
 41+  CDED 13                       inc     de
 42+  CDEE              gdfs_nonEmpty:
 43+  CDEE
 44+  CDEE                          ; Повтор цикла по кластерам сектора fat
 45+  CDEE 0B                       dec     bc  ; счетчик просмотренных кластеров сектора
 46+  CDEF 78                       ld      a, b
 47+  CDF0 B1                       or      c
 48+  CDF1 C2 E6 CD                 jp nz,  sectorClustersLoop
 49+  CDF4
 50+  CDF4                          ; Повтор цикла по секторам fat
 51+  CDF4 E1                       pop     hl              ; hl = номер сектора
 52+  CDF5 23                       inc     hl              ; инкремент номера сектора
 53+  CDF6
 54+  CDF6 F1                       pop     af
 55+  CDF7 3D                       dec     a               ; счетчик цикла
 56+  CDF8 F5                       push    af
 57+  CDF9
 58+  CDF9 C2 DD CD                 jp nz,  fatSectorsLoop  ; повтор цилкла по секторам
 59+  CDFC
 60+  CDFC                          ; Восстанавливаем регистры и выходим
 61+  CDFC F1                       pop     af
 62+  CDFD C1                       pop     bc
 63+  CDFE E1                       pop     hl
 64+  CDFF
 65+  CDFF C9                       ret
 66+  CE00
145   CE00                  INCLUDE "fatReadBootSector.inc"
  1+  CE00              ;----------------------------------------------------------------------------
  2+  CE00              ; MXOS
  3+  CE00              ; Считывание загрузочного сектора и инициализация структуры v_diskInfo.
  4+  CE00              ; Подпрограмма затирает дисковый кэш!
  5+  CE00              ;
  6+  CE00              ; На выходе
  7+  CE00              ;  cf - ошибка
  8+  CE00              ;  регистры bc, de, hl сохраняются
  9+  CE00              ;
 10+  CE00              ; 2022-02-13 Разработано SpaceEngineer
 11+  CE00              ;----------------------------------------------------------------------------
 12+  CE00
 13+  CE00              ; Структура загрузочного сектора FAT12/16
 14+  CE00
 15+  CE00                  STRUCT  FAT_BOOT_SECTOR
 16+  CE00 ~            BS_JmpBoot      BLOCK   3   ; смещение  00h,   3 байт - Jump instruction to the bootstrap code (x86 instruction): EBh, ??h, 90h (Short jump + NOP) or E9h, ??h, ??h (Near jump).
 17+  CE00 ~            BS_OEMName      BLOCK   8   ; смещение  03h,   8 байт - "MSWIN 4.1" is recommended but also "MSDOS 5.0" is often used.
 18+  CE00 ~            BPB_BytsPerSec  BLOCK   2   ; смещение  0Bh,   2 байт - Sector size in unit of byte. Valid values are 512, 1024, 2048, 4096. But must drivers use 512.
 19+  CE00 ~            BPB_SecPerClus  BLOCK   1   ; смещение  0Dh,   1 байт - Number of sectors per cluster. Valid values are 1, 2, 4, 8, ... 128.
 20+  CE00 ~            BPB_RsvdSecCnt  BLOCK   2   ; смещение  0Eh,   2 байт - Number of sectors in reserved area. This field hould be 1 on FAT12/16 volume.
 21+  CE00 ~            BPB_NumFATs     BLOCK   1   ; смещение  10h,   1 байт - Number of FATs. The value of this field should always be 2. On memory cards, it may be 1, but some FAT driver may not recognize such a volume properly.
 22+  CE00 ~            BPB_RootEntCnt  BLOCK   2   ; смещение  11h,   2 байт - Number of 32-byte directory entries in the root directory. For max compatibility, must be 512 on FAT16 volume.
 23+  CE00 ~            BPB_TotSec16    BLOCK   2   ; смещение  13h,   2 байт - Total number of sectors of the volume in old 16-bit field. If >= 0x10000, this field = 0, and the true value is set to BPB_TotSec32.
 24+  CE00 ~            BPB_Media       BLOCK   1   ; смещение  15h,   1 байт - Valid values are F0h, F8h ... FFh. The same value must be put in the lower 8-bits of FAT[0].
 25+  CE00 ~            BPB_FATSz16     BLOCK   2   ; смещение  16h,   2 байт - Number of sectors occupied by a FAT. The size of the FAT area becomes BPB_FATSz16 * BPB_NumFATs sectors.
 26+  CE00 ~            BPB_SecPerTrk   BLOCK   2   ; смещение  18h,   2 байт - Number of sectors per track. This field is relevant only for media that have geometry and used for only disk BIOS of IBM PC.
 27+  CE00 ~            BPB_NumHeads    BLOCK   2   ; смещение  1Ah,   2 байт - Number of heads. This field is relevant only for media that have geometry and used for only disk BIOS of IBM PC.
 28+  CE00 ~            BPB_HiddSec     BLOCK   4   ; смещение  1Ch,   4 байт - Number of hidden physical sectors preceding the FAT volume. Should always be 0 if the volume starts at the beginning of the storage.
 29+  CE00 ~            BPB_TotSec32    BLOCK   4   ; смещение  20h,   4 байт - Total number of sectors of the FAT volume in new 32-bit field.
 30+  CE00 ~            BS_DrvNum       BLOCK   1   ; смещение  24h,   1 байт - Drive number used by disk BIOS of IBM PC. This field is used in MS-DOS bootstrap, 0x00 for floppy disk and 0x80 for fixed disk.
 31+  CE00 ~            BS_Reserved     BLOCK   1   ; смещение  25h,   1 байт - Reserved (used by Windows NT). It should be set 0 when create the volume.
 32+  CE00 ~            BS_BootSig      BLOCK   1   ; смещение  26h,   1 байт - Extended boot signature (0x29). This is a signature byte indicates that the following three fields are present.
 33+  CE00 ~            BS_VolID        BLOCK   4   ; смещение  27h,   4 байт - Volume serial number used with BS_VolLab to track a volume on the removable storage. It enables to detect a wrong media change by FAT driver.
 34+  CE00 ~            BS_VolLab       BLOCK  11   ; смещение  2Bh,  11 байт - Volume label, matches volume label recorded in the root directory. When volume label is not present, "NO NAME " should be set.
 35+  CE00 ~            BS_FilSysType   BLOCK   8   ; смещение  36h,   8 байт - "FAT12   ", "FAT16   " or "FAT     ". Microsoft's FAT driver does not use this field to determine the FAT type.
 36+  CE00 ~            BS_BootCode     BLOCK 448   ; смещение  3Eh, 448 байт - Bootstrap program. It is platform dependent and filled with zero when not used.
 37+  CE00 ~            BS_BootSign     BLOCK   2   ; смещение 1FEh,   2 байт - 0xAA55. A boot signature indicating that this is a valid boot sector.
 38+  CE00                  ENDS
 39+  CE00
 40+  CE00              ;----------------------------------------------------------------------------
 41+  CE00
 42+  CE00              fatReadBootSector:
 43+  CE00                          ; Сохраняем регистры
 44+  CE00 E5                       push    hl
 45+  CE01 D5                       push    de
 46+  CE02 C5                       push    bc
 47+  CE03
 48+  CE03                          ; Помещаем значение DISK_NO_DRIVER в v_diskInfo.isValid
 49+  CE03 3E 00                    ld      a, DISK_NO_DRIVER
 50+  CE05 32 E7 D2                 ld      (v_diskInfo.isValid), a
 51+  CE08
 52+  CE08                          ; Проверяем, установлен ли драйвер: сравниваем
 53+  CE08                          ; с адресом пустого драйвера diskDriverDummy
 54+  CE08 2A 64 C8                 ld      hl, (j_diskDriver + 1)  ; hl = адрес драйвера
 55+  CE0B 3E CB                    ld      a, diskDriverDummy >> 8
 56+  CE0D BC                       cp      h
 57+  CE0E C2 17 CE                 jp nz,  frbs_DriverOk
 58+  CE11 3E 83                    ld      a, diskDriverDummy & 0FFh
 59+  CE13 BC                       cp      h
 60+  CE14 CA A1 CE                 jp z,   frbs_Exit
 61+  CE17
 62+  CE17              frbs_DriverOk:
 63+  CE17                          ; Драйвер установлен; загружаем boot сектор в дисковый кэш, затирая его
 64+  CE17 21 00 FB                 ld      hl, FAT_CACHE_ADDR  ; адрес буфера
 65+  CE1A 11 00 00                 ld      de, 0               ; номер сектора - 0
 66+  CE1D 06 02                    ld      b, 2                ; режим драйвера - чтение
 67+  CE1F CD 63 C8                 call    j_diskDriver        ; читаем сектор в память
 68+  CE22
 69+  CE22                          ; Помещаем значение DISK_INVALID в v_diskInfo.isValid
 70+  CE22 3E 01                    ld      a, DISK_INVALID
 71+  CE24 32 E7 D2                 ld      (v_diskInfo.isValid), a
 72+  CE27
 73+  CE27                          ; Проверяем, корректный ли это FAT12/16 диск:
 74+  CE27                          ; поле BS_FilSysType должно содержить текст "FAT"
 75+  CE27 21 36 FB                 ld      hl, FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BS_FilSysType
 76+  CE2A 11 21 D3                 ld      de, aFat
 77+  CE2D 0E 03                    ld      c, 3
 78+  CE2F CD DB CB                 call    strcmp
 79+  CE32 C2 A1 CE                 jp nz,  frbs_Exit   ; это не FAT диск, или не отформатирован - выходим
 80+  CE35
 81+  CE35                          ; Помещаем значение DISK_VALID в v_diskInfo.isValid
 82+  CE35 3E 02                    ld      a, DISK_VALID
 83+  CE37 32 E7 D2                 ld      (v_diskInfo.isValid), a
 84+  CE3A
 85+  CE3A                          ; Копируем и рассчитываем необходимые значения
 86+  CE3A 2A 0B FB                 ld      hl, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_BytsPerSec)
 87+  CE3D 22 C5 D2                 ld      (v_diskInfo.sectorSize), hl         ; размер сектора
 88+  CE40
 89+  CE40 3A 0D FB                 ld      a, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_SecPerClus)
 90+  CE43 32 C7 D2                 ld      (v_diskInfo.sectorsPerCluster), a
 91+  CE46 AF                       xor     a
 92+  CE47 32 C8 D2                 ld      (v_diskInfo.sectorsPerCluster+1), a ; секторов на кластер (16-битным словом)
 93+  CE4A
 94+  CE4A 2A 13 FB                 ld      hl, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_TotSec16)
 95+  CE4D 22 CF D2                 ld      (v_diskInfo.totalSectors), hl       ; сколько всего секторов на диске
 96+  CE50
 97+  CE50 2A 0E FB                 ld      hl, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_RsvdSecCnt)
 98+  CE53 22 C9 D2                 ld      (v_diskInfo.resSectors), hl         ; сколько секторов занимает зарезервированная область
 99+  CE56
100+  CE56 EB                       ex      hl, de
101+  CE57
102+  CE57 2A 16 FB                 ld      hl, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_FATSz16)
103+  CE5A 22 CB D2                 ld      (v_diskInfo.fatSectors), hl         ; сколько секторов занимает таблица fat
104+  CE5D
105+  CE5D 19                       add     hl, de
106+  CE5E 22 D7 D2                 ld      (v_diskInfo.dirStartSector), hl     ; первый сектор корневого каталога
107+  CE61 E5                       push    hl
108+  CE62
109+  CE62 2A 11 FB                 ld      hl, (FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BPB_RootEntCnt)
110+  CE65 22 D1 D2                 ld      (v_diskInfo.rootDirMaxFiles), hl    ; максимум файлов в корневом каталоге
111+  CE68
112+  CE68 2A C5 D2                 ld      hl, (v_diskInfo.sectorSize)
113+  CE6B 11 20 00                 ld      de, FILE_DESCR_SIZE ; de = 32
114+  CE6E CD 61 D2                 call    div_hl_de;
115+  CE71 22 D3 D2                 ld      (v_diskInfo.descrPerSector), hl     ; сколько дескрипторов файлов вмещается в один сектор
116+  CE74
117+  CE74 EB                       ex      hl, de
118+  CE75 2A D1 D2                 ld      hl, (v_diskInfo.rootDirMaxFiles)
119+  CE78 CD 61 D2                 call    div_hl_de;
120+  CE7B 22 CD D2                 ld      (v_diskInfo.dirSectors), hl         ; сколько секторов занимает корневой каталог
121+  CE7E
122+  CE7E D1                       pop     de
123+  CE7F 19                       add     hl, de
124+  CE80 22 D9 D2                 ld      (v_diskInfo.dataStartSector), hl    ; первый сектор области данных
125+  CE83
126+  CE83 2A C5 D2                 ld      hl, (v_diskInfo.sectorSize)
127+  CE86 CD 34 D2                 call    div_hl_2
128+  CE89 EB                       ex      hl, de
129+  CE8A 2A CB D2                 ld      hl, (v_diskInfo.fatSectors)
130+  CE8D CD 3C D2                 call    mul_hl_de;
131+  CE90 22 D5 D2                 ld      (v_diskInfo.fatNumCells), hl        ; количество ячеек в таблице fat (= fatSectors * sectorSize / 2)
132+  CE93
133+  CE93                          ; Копируем метку тома
134+  CE93 21 2B FB                 ld      hl, FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BS_VolLab          ; откуда - начало
135+  CE96 11 36 FB                 ld      de, FAT_CACHE_ADDR + FAT_BOOT_SECTOR.BS_FilSysType      ; откуда - конец
136+  CE99 01 DB D2                 ld      bc, v_diskInfo.volumeLabel                              ; куда
137+  CE9C CD 2D C4                 call    memcpy_bc_hl
138+  CE9F 36 00                    ld      (hl), 0                                                 ; в конце байт-терминатор строки
139+  CEA1
140+  CEA1              frbs_Exit:  ; Восстанавливаем регистры и выходим
141+  CEA1 C1                       pop     bc
142+  CEA2 D1                       pop     de
143+  CEA3 E1                       pop     hl
144+  CEA4 C9                       ret
145+  CEA5
146   CEA5              	INCLUDE "fileCreate.inc"
  1+  CEA5              ;----------------------------------------------------------------------------
  2+  CEA5              ; MXOS
  3+  CEA5              ; Создать файл
  4+  CEA5              ;
  5+  CEA5              ; На входе
  6+  CEA5              ;  hl - адрес дескриптора файла в формате FAT (имя, фтрибуты, размер и т.д.)
  7+  CEA5              ;
  8+  CEA5              ; На выходе
  9+  CEA5              ;  сf - ошибка
 10+  CEA5              ;
 11+  CEA5              ; TODO: В случае нехватки места на диске, на нем остается неполный файл.
 12+  CEA5              ; Надо удалить то, что записали.
 13+  CEA5              ;
 14+  CEA5              ; 2013-12-12 Дизассемблировано vinxru
 15+  CEA5              ; 2022-02-11 Переработано SpaceEngineer
 16+  CEA5              ;----------------------------------------------------------------------------
 17+  CEA5
 18+  CEA5              fileCreate: ; Сохраняем регистры
 19+  CEA5 E5                       push    hl  ; [1]
 20+  CEA6 C5                       push    bc  ; [2]
 21+  CEA7 D5                       push    de  ; [3]
 22+  CEA8
 23+  CEA8                          ; Сохраняем адрес подготовленного дескриптора создаваемого файла
 24+  CEA8 22 A3 D2                 ld      (v_newDescrPtr), hl
 25+  CEAB
 26+  CEAB                          ; Если файл существует, то удаляем его
 27+  CEAB CD 5F CF                 call    fileFind
 28+  CEAE D4 2F D0                 call nc,deleteFileInt
 29+  CEB1
 30+  CEB1                          ; de = номер первого сектора каталога
 31+  CEB1                          ; с  = количество секторов каталога (мл. байт)
 32+  CEB1 CD 4A CD                 call    fatBeginDirLoop
 33+  CEB4
 34+  CEB4                          ; Цикл по секторам каталога
 35+  CEB4              fileCreate_dirLoop:
 36+  CEB4                          ; Сохраняем номер сектора каталога
 37+  CEB4 D5                       push    de  ; [4]               ; de = номер сектора каталога
 38+  CEB5
 39+  CEB5                          ; Кэшируем сектор каталога
 40+  CEB5 AF                       xor     a                       ; флаг - сектор не будет меняться
 41+  CEB6 CD 6C CC                 call    getSectorAddressInCache ; выход: hl = адрес сектора в буфере
 42+  CEB9
 43+  CEB9                          ; Кол-во дескрипторов файлов в одном секторе каталога (мл. байт)
 44+  CEB9 3A D3 D2                 ld      a, (v_diskInfo.descrPerSector)
 45+  CEBC 47                       ld      b, a
 46+  CEBD
 47+  CEBD                          ; Размер дескриптора
 48+  CEBD 11 20 00                 ld      de, FILE_DESCR_SIZE
 49+  CEC0
 50+  CEC0                          ; Цикл по дескрипторам в закешированном секторе каталога
 51+  CEC0              fileCreate_sectorLoop:
 52+  CEC0 7E                       ld      a, (hl)                 ; читаем байт из каталога
 53+  CEC1 3C                       inc     a                       ; если байт = 0FFh, значит запись свободна
 54+  CEC2 CA D6 CE                 jp z,   fileCreate_placeFound   ; переход, если свободная запись найдена
 55+  CEC5
 56+  CEC5                          ; Вычисляем адрес следующего дескриптора
 57+  CEC5 19                       add     hl, de
 58+  CEC6
 59+  CEC6                          ; Еще остались файлы в секторе каталога?
 60+  CEC6 05                       dec     b
 61+  CEC7 C2 C0 CE                 jp nz,  fileCreate_sectorLoop
 62+  CECA
 63+  CECA                          ; Еще остались секторы каталога?
 64+  CECA                          ; Восстанавливаем номер сектора каталога
 65+  CECA D1                       pop     de  ; [4]   de = номер сектора каталога
 66+  CECB 13                       inc     de  ;       следующий сектор каталога
 67+  CECC
 68+  CECC 0D                       dec     c
 69+  CECD C2 B4 CE                 jp nz,  fileCreate_dirLoop
 70+  CED0
 71+  CED0                          ;-----------------------------------------------------------
 72+  CED0                          ; Свободных записей нет
 73+  CED0
 74+  CED0                          ; Установка a=0, ZF=1
 75+  CED0 AF                       xor     a
 76+  CED1
 77+  CED1              stc_popDBH_ret:
 78+  CED1                          ; Установка флага CF=1
 79+  CED1 37                       scf
 80+  CED2
 81+  CED2              popDBH_ret: ; Восстановление регистров и выход
 82+  CED2 D1                       pop     de  ; [3]
 83+  CED3 C1                       pop     bc  ; [2]
 84+  CED4 E1                       pop     hl  ; [1]
 85+  CED5 C9                       ret
 86+  CED6
 87+  CED6                          ;-----------------------------------------------------------
 88+  CED6                          ; Свободная запись найдена
 89+  CED6
 90+  CED6              fileCreate_placeFound:
 91+  CED6
 92+  CED6                          ; Сохраняем найденный в кэше адрес свободного дескриптора
 93+  CED6 22 9F D2                 ld      (v_cachedDescrPtr), hl
 94+  CED9
 95+  CED9                          ; Сохраняем номер сектора каталога
 96+  CED9 D1                       pop     de  ; [4]   de = номер сектора каталога
 97+  CEDA EB                       ex      hl, de
 98+  CEDB 22 A1 D2                 ld      (v_cachedSector), hl
 99+  CEDE
100+  CEDE                          ; Находим первый свободный кластер
101+  CEDE CD 72 CD                 call    fatFindClusterFirst ; de = первый свободный кластер
102+  CEE1 DA D1 CE                 jp c,   stc_popDBH_ret      ; если нет свободных кластеров - выходим с ошибкой
103+  CEE4
104+  CEE4                          ; Сохраняем его в переменную v_fileFirstCluster
105+  CEE4 EB                       ex      hl, de
106+  CEE5 22 99 D2                 ld      (v_fileFirstCluster), hl
107+  CEE8 EB                       ex      hl, de
108+  CEE9
109+  CEE9                          ; Сохраняем номер первого кластера в дескриптор файла
110+  CEE9                          ; de = номер первого кластера
111+  CEE9                          ; hl = адрес дескриптора файла
112+  CEE9 2A A3 D2                 ld      hl, (v_newDescrPtr)
113+  CEEC 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
114+  CEEF 09                       add     hl, bc  ; hl = адрес поля firstCluster (мл. байт) в дескрипторе файла
115+  CEF0 73                       ld      (hl), e
116+  CEF1 23                       inc     hl      ; hl = адрес поля firstCluster (ст. байт) в дескрипторе файла
117+  CEF2 72                       ld      (hl), d
118+  CEF3
119+  CEF3
120+  CEF3                          ;---------------------------------------------------------------------
121+  CEF3                          ; Записываем дескриптор в каталог, пока сектор каталога все еще в кэше
122+  CEF3
123+  CEF3                          ; Ставим сектору каталога флаг isModified
124+  CEF3 CD 54 CD                 call    markDirSectorAsModified
125+  CEF6
126+  CEF6                          ; Копируем подготовленный дескриптор файла в закешированный сектор каталога
127+  CEF6 2A A3 D2                 ld      hl, (v_newDescrPtr)     ; адрес подготовленного дескриптора
128+  CEF9 EB                       ex      hl, de
129+  CEFA 2A 9F D2                 ld      hl, (v_cachedDescrPtr)  ; адрес свободного дескриптора в кэше
130+  CEFD
131+  CEFD                          ; Копирование c байт из de в hl
132+  CEFD C5                       push    bc
133+  CEFE CD B7 D1                 call    copyDescriptor
134+  CF01 C1                       pop     bc
135+  CF02
136+  CF02                          ;---------------------------------------------------------------------
137+  CF02
138+  CF02              		    ; Читаем адрес загрузки файла
139+  CF02                          ; de = адрес загрузки файла
140+  CF02 2A A3 D2                 ld      hl, (v_newDescrPtr)
141+  CF05 01 12 00                 ld      bc, FILE_DESCRIPTOR.loadAddress
142+  CF08 09                       add     hl, bc  ; hl = адрес поля loadAddress (мл. байт) в дескрипторе файла
143+  CF09 5E                       ld      e, (hl)
144+  CF0A 23                       inc     hl      ; hl = адрес поля loadAddress (ст. байт) в дескрипторе файла
145+  CF0B 56                       ld      d, (hl) ; de = адрес загрузки
146+  CF0C
147+  CF0C                          ; Сохраняем адрес загрузки в переменную v_input_start
148+  CF0C EB                       ex      de, hl
149+  CF0D 22 9B D2                 ld      (v_input_start), hl ; v_input_start = адрес загрузки файла
150+  CF10
151+  CF10                          ; Читаем размер файла
152+  CF10                          ; de = размер файла
153+  CF10 2A A3 D2                 ld      hl, (v_newDescrPtr)
154+  CF13 01 1C 00                 ld      bc, FILE_DESCRIPTOR.size
155+  CF16 09                       add     hl, bc  ; hl = адрес поля size (мл. байт) в дескрипторе файла
156+  CF17 5E                       ld      e, (hl)
157+  CF18 23                       inc     hl      ; hl = адрес поля size (ст. байт) в дескрипторе файла
158+  CF19 56                       ld      d, (hl)
159+  CF1A
160+  CF1A                          ; Сохраняем размер файла в переменную v_input_end
161+  CF1A EB                       ex      de, hl
162+  CF1B 22 9D D2                 ld      (v_input_end), hl   ; v_input_end = размер файла
163+  CF1E
164+  CF1E                          ; Счётчик кластеров файла
165+  CF1E 4C                       ld      c, h        ; c  = старший байт размера = количество кластеров файла - 1, т.к. кластер размером 256 байт.
166+  CF1F 0C                       inc     c           ; c  = количество кластеров файла. TODO: это не будет работать с другим размером кластера!
167+  CF20 41                       ld      b, c        ; сохраняем в b - пригодится позже
168+  CF21
169+  CF21                          ; Первый кластер файла в fat
170+  CF21 2A 99 D2                 ld      hl, (v_fileFirstCluster)    ; hl = номер первого кластера файла
171+  CF24 54                       ld      d, h
172+  CF25 5D                       ld      e, l                        ; de = hl - если файл состоит из одного кластера, ячейка fat будет указывать на саму себя
173+  CF26
174+  CF26 C3 2F CF                 jp      writeFirstCluster
175+  CF29
176+  CF29              ; ---------------------------------------------------------------------------
177+  CF29              ; Записываем кластеры файла в таблицу fat на устройстве
178+  CF29
179+  CF29              allocClusters:
180+  CF29 CD 79 CD                 call    fatFindClusterNext  ; de = следующий свободный кластер
181+  CF2C DA D1 CE                 jp c,   stc_popDBH_ret      ; если больше нет свободных кластеров - выходим с ошибкой
182+  CF2F
183+  CF2F              writeFirstCluster:
184+  CF2F                          ; записываем номер кластера в fat
185+  CF2F                          ; hl = номер ячейки fat
186+  CF2F                          ; de = номер кластера
187+  CF2F CD B0 CD                 call    fatWriteCluster
188+  CF32
189+  CF32 0D                       dec     c                   ; счётчик записанных кластеров
190+  CF33 C2 29 CF                 jp nz,  allocClusters       ; повтор цикла
191+  CF36
192+  CF36                          ; Конец, последний кластер файла указывает сам на себя
193+  CF36                          ; hl == de
194+  CF36 CD B0 CD                 call    fatWriteCluster
195+  CF39
196+  CF39              ; ---------------------------------------------------------------------------
197+  CF39              ; Сохраняем файл на диск
198+  CF39
199+  CF39                          ; Номер первого кластера
200+  CF39 2A 99 D2                 ld      hl, (v_fileFirstCluster)
201+  CF3C EB                       ex      hl, de                      ; de = номер первого кластера файла
202+  CF3D D5                       push    de
203+  CF3E
204+  CF3E                          ; Переводим в номер сектора
205+  CF3E CD 39 CD                 call    fatClusterToSector          ; de = номер первого сектора файла
206+  CF41
207+  CF41 2A 9B D2                 ld      hl, (v_input_start)         ; hl = адрес загрузки файла
208+  CF44 48                       ld      c, b                        ; c = количество кластеров файла
209+  CF45 06 01                    ld      b, 1                        ; режим драйвера 1 - запись
210+  CF47
211+  CF47              writeFileLoop:
212+  CF47 CD 63 C8                 call    j_diskDriver
213+  CF4A 24                       inc     h                   ; cледующий блок файла в памяти (TODO: это работает только для кластера 256 байт)
214+  CF4B
215+  CF4B                          ; Находим следующий кластер в fat
216+  CF4B D1                       pop     de                  ; de = номер текущего кластера
217+  CF4C CD A6 CD                 call    fatReadCluster      ; de = номер следующего кластера
218+  CF4F D5                       push    de
219+  CF50
220+  CF50                          ; Переводим в номер сектора
221+  CF50 CD 39 CD                 call    fatClusterToSector  ; de = следующий сектор файла в области данных
222+  CF53
223+  CF53 0D                       dec     c                   ; счётчик записанных кластеров
224+  CF54 C2 47 CF                 jp nz,  writeFileLoop       ; повтор цикла
225+  CF57
226+  CF57 D1                       pop     de
227+  CF58
228+  CF58              ; ---------------------------------------------------------------------------
229+  CF58              ; Расчет однобайтовой контрольной суммы
230+  CF58              ; Это нигде не используется даже в оригинальной ОС
231+  CF58
232+  CF58              ;            ld      hl, (v_input_end)   ; hl = размер файла - 1 из v_input_end
233+  CF58              ;            inc     hl                  ; hl = размер файла
234+  CF58              ;            ex      de, hl              ; de = размер файла
235+  CF58              ;            ld      hl, (v_input_start) ; hl = адрес загрузки файла из v_input_start
236+  CF58              ;            ld      b, 0                ; тут будет накапливаться сумма
237+  CF58              ;fileCreateCRCLoop:
238+  CF58              ;            ld      a, d
239+  CF58              ;            or      e
240+  CF58              ;            jp z,   fileCreateCRCDone   ; если счетчик досчитал до нуля, выходим
241+  CF58              ;            ld  a,  (hl)                ; читаем байт файла
242+  CF58              ;            add     a, b                ; накапливаем сумму
243+  CF58              ;            ld      b, a
244+  CF58              ;            inc     hl                  ; следующий байт
245+  CF58              ;            dec     de                  ; уменьшаем счетчик
246+  CF58              ;            jp      fileCreateCRCLoop
247+  CF58              ;fileCreateCRCDone:
248+  CF58              ;            ; Сохраняем контрольную сумму в дескриптор файла, в поле ntReserved
249+  CF58              ;            ld      a, b                ; a = посчитанная контрольная сумма
250+  CF58              ;            ld      hl, (v_newDescrPtr)
251+  CF58              ;            ld      bc, FILE_DESCRIPTOR.ntReserved
252+  CF58              ;            add     hl, bc              ; hl = адрес поля ntReserved в дескрипторе файла
253+  CF58              ;            ld      (hl), a             ; сохраняем контрльную сумму
254+  CF58
255+  CF58              ; ------------------------------------------------------------------------------------------------------------------------
256+  CF58              ; Сохраняем кэш и выходим
257+  CF58
258+  CF58 CD 22 CD                 call    saveSectorCache ; сохраняем изменения в кэше на диск
259+  CF5B B7                       or      a               ; выходим с флагом cf = 0
260+  CF5C C3 D2 CE                 jp      popDBH_ret
261+  CF5F
147   CF5F              	INCLUDE "fileFind.inc"
  1+  CF5F              ;+---------------------------------------------------------------------------
  2+  CF5F              ; MXOS
  3+  CF5F              ; Найти файл
  4+  CF5F              ;
  5+  CF5F              ; На входе
  6+  CF5F              ;  hl - имя
  7+  CF5F              ;
  8+  CF5F              ; На выходе
  9+  CF5F              ;  bc, de, hl - сохраняются
 10+  CF5F              ;  cf - ошибка
 11+  CF5F              ;  v_foundDescrPtr - найденный файл
 12+  CF5F              ;
 13+  CF5F              ; 2013-12-12 Дизассемблировано vinxru
 14+  CF5F              ; 2022-02-11 Переработано SpaceEngineer
 15+  CF5F              ;----------------------------------------------------------------------------
 16+  CF5F
 17+  CF5F              fileFind:   ; Сохраняем регистры
 18+  CF5F C5                       push    bc  ; [1]
 19+  CF60 D5                       push    de  ; [2]
 20+  CF61
 21+  CF61                          ; de = номер первого сектора каталога
 22+  CF61                          ; с  = количество секторов каталога (мл. байт)
 23+  CF61 CD 4A CD                 call    fatBeginDirLoop
 24+  CF64
 25+  CF64                          ; Цикл по секторам каталога
 26+  CF64              fileFind_dirLoop:
 27+  CF64                          ; Сохраняем номер сектора каталога
 28+  CF64 D5                       push    de  ; [3]               ; de = номер сектора каталога
 29+  CF65
 30+  CF65                          ; Кэшируем сектор каталога
 31+  CF65 E5                       push    hl  ; [4*]
 32+  CF66 AF                       xor     a                       ; флаг - сектор не будет меняться
 33+  CF67 CD 6C CC                 call    getSectorAddressInCache ; выход: hl = адрес сектора в буфере
 34+  CF6A EB                       ex      hl, de                  ; de = адрес сектора в буфере
 35+  CF6B E1                       pop     hl  ; [4*]              ; hl = адрес имени искомого файла
 36+  CF6C
 37+  CF6C                          ; Кол-во дескрипторов файлов в одном секторе каталога (мл. байт)
 38+  CF6C 3A D3 D2                 ld      a, (v_diskInfo.descrPerSector)
 39+  CF6F 47                       ld      b, a
 40+  CF70 C5                       push    bc  ; [4]               ; b = счетчик секторов
 41+  CF71
 42+  CF71                          ; Цикл по дескрипторам в закешированном секторе каталога
 43+  CF71              fileFind_sectorLoop:
 44+  CF71
 45+  CF71                          ; Сохраняем адрес начала имени в каталоге и адрес имени искомого файла
 46+  CF71 E5                       push    hl  ; [5]   hl = адрес имени искомого файла
 47+  CF72 D5                       push    de  ; [6]   de = адрес дескриптора файла в кэше
 48+  CF73
 49+  CF73                          ; Если первый символ имени 0FFh, переходим к следующем файлу
 50+  CF73 1A                       ld      a, (de)
 51+  CF74 3C                       inc     a
 52+  CF75 CA 9A CF                 jp z,   fileFind_next
 53+  CF78
 54+  CF78                          ; Сравниваем имена файлов по адресам hl и de
 55+  CF78 0E 0B                    ld      c, FILE_NAME_LENGTH + 3 ; длина имени + расширения
 56+  CF7A CD E5 CB                 call    stricmp
 57+  CF7D C2 9A CF                 jp nz,  fileFind_next           ; если имена не совпадают, переходим к следующему файлу
 58+  CF80
 59+  CF80                          ;-----------------------------------------------------------
 60+  CF80                          ; Файл найден
 61+  CF80 E1                       pop     hl  ; [6]   hl = адрес дескриптора файла в кэше
 62+  CF81
 63+  CF81                          ; Сохраняем адрес дескриптора в кэше в переменную v_cachedDescrPtr
 64+  CF81 22 9F D2                 ld      (v_cachedDescrPtr), hl
 65+  CF84 EB                       ex      hl, de
 66+  CF85
 67+  CF85                          ; Сохраняем адрес v_tmpFileDescr в переменную v_foundDescrPtr
 68+  CF85 21 56 D3                 ld      hl, v_tmpFileDescr
 69+  CF88 22 A5 D2                 ld      (v_foundDescrPtr), hl
 70+  CF8B
 71+  CF8B                          ; Копируем дескриптор файла в переменную v_tmpFileDescr
 72+  CF8B                          ; de = откуда (v_cachedDescrPtr), hl = куда (v_tmpFileDescr)
 73+  CF8B CD B7 D1                 call    copyDescriptor
 74+  CF8E
 75+  CF8E                          ; Восстаналиваем регистры
 76+  CF8E E1                       pop     hl  ; [5]   hl = адрес имени искомого файла
 77+  CF8F C1                       pop     bc  ; [4]   c  = счетчик секторов
 78+  CF90
 79+  CF90                          ; Сохраняем номер сектора каталога в переменную v_cachedSector
 80+  CF90 D1                       pop     de  ; [3]   de = номер сектора каталога
 81+  CF91 EB                       ex      hl, de
 82+  CF92 22 A1 D2                 ld      (v_cachedSector), hl
 83+  CF95 EB                       ex      hl, de
 84+  CF96
 85+  CF96                          ; Восстаналиваем регистры и выходим с CF=0
 86+  CF96 D1                       pop     de  ; [2]
 87+  CF97 C1                       pop     bc  ; [1]
 88+  CF98 B7                       or      a   ;       для выхода с флагом
 89+  CF99 C9                       ret
 90+  CF9A                          ;-----------------------------------------------------------
 91+  CF9A
 92+  CF9A              fileFind_next:
 93+  CF9A                          ; Вычисляем адрес следующего дескриптора файла
 94+  CF9A D1                       pop     de  ; [6]   de = адрес дескриптора файла в кэше
 95+  CF9B 21 20 00                 ld      hl, FILE_DESCR_SIZE
 96+  CF9E 19                       add     hl, de
 97+  CF9F EB                       ex      de, hl
 98+  CFA0
 99+  CFA0                          ; Восстанавливаем адрес искомого имени
100+  CFA0 E1                       pop     hl  ; [5]   hl = адрес имени искомого файла
101+  CFA1
102+  CFA1                          ; Еще остались файлы в секторе каталога?
103+  CFA1 05                       dec     b
104+  CFA2 C2 71 CF                 jp nz,  fileFind_sectorLoop
105+  CFA5
106+  CFA5                          ; Еще остались секторы каталога?
107+  CFA5 C1                       pop     bc  ; [4]   c  = счетчик секторов
108+  CFA6
109+  CFA6                          ; Восстанавливаем номер сектора каталога
110+  CFA6 D1                       pop     de  ; [3]   de = номер сектора каталога
111+  CFA7 13                       inc     de  ;       следующий сектор каталога
112+  CFA8
113+  CFA8 0D                       dec     c
114+  CFA9 C2 64 CF                 jp nz,  fileFind_dirLoop
115+  CFAC
116+  CFAC                          ;-----------------------------------------------------------
117+  CFAC                          ; Файл не найден
118+  CFAC                          ; Восстаналиваем регистры и выходим с CF=1 и a=3
119+  CFAC D1                       pop     de  ; [2]
120+  CFAD C1                       pop     bc  ; [1]
121+  CFAE 3E 03                    ld      a, 3
122+  CFB0 37                       scf
123+  CFB1 C9                       ret
124+  CFB2
148   CFB2              	INCLUDE "fileLoad.inc"
  1+  CFB2              ;+---------------------------------------------------------------------------
  2+  CFB2              ; MXOS
  3+  CFB2              ; Загрузить файл по указанному адресу
  4+  CFB2              ;
  5+  CFB2              ; На входе
  6+  CFB2              ;  hl - имя
  7+  CFB2              ;  de - адрес загрузки
  8+  CFB2              ;
  9+  CFB2              ; На выходе
 10+  CFB2              ;  bc, de, hl - сохраняются
 11+  CFB2              ;  v_foundDescrPtr - адрес копии дескриптора найденного файла
 12+  CFB2              ;  cf - ошибка
 13+  CFB2              ;
 14+  CFB2              ; 2013-12-12 Дизассемблировано vinxru
 15+  CFB2              ; 2022-02-11 Переработано SpaceEngineer
 16+  CFB2              ;----------------------------------------------------------------------------
 17+  CFB2
 18+  CFB2              fileLoad2:  ; Ищем файл с именем в hl
 19+  CFB2 CD 5F CF                 call    fileFind
 20+  CFB5 D8                       ret c
 21+  CFB6
 22+  CFB6                          ; Сохранить регистры
 23+  CFB6 E5                       push    hl
 24+  CFB7 C5                       push    bc
 25+  CFB8 D5                       push    de
 26+  CFB9
 27+  CFB9 C3 CD CF                 jp      fileLoadStep2
 28+  CFBC
 29+  CFBC              ;----------------------------------------------------------------------------
 30+  CFBC              ; Загрузить файл по адресу указанному в заголовке
 31+  CFBC              ;
 32+  CFBC              ; На входе
 33+  CFBC              ;  hl - имя
 34+  CFBC              ;
 35+  CFBC              ; На выходе
 36+  CFBC              ;  bc, de, hl - сохраняются
 37+  CFBC              ;  v_foundDescrPtr - адрес копии дескриптора найденного файла
 38+  CFBC              ;  cf - ошибка
 39+  CFBC              ;----------------------------------------------------------------------------
 40+  CFBC
 41+  CFBC              fileLoad:   ; Ищем файл с именем в hl
 42+  CFBC CD 5F CF                 call    fileFind
 43+  CFBF D8                       ret c
 44+  CFC0
 45+  CFC0                          ; Сохраняем регистры
 46+  CFC0 E5                       push    hl
 47+  CFC1 C5                       push    bc
 48+  CFC2 D5                       push    de
 49+  CFC3
 50+  CFC3                          ; hl = указатель на адрес загрузки
 51+  CFC3 2A A5 D2                 ld      hl, (v_foundDescrPtr)
 52+  CFC6 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 53+  CFC9 19                       add     hl, de
 54+  CFCA
 55+  CFCA                          ; de = адрес загрузки
 56+  CFCA 5E                       ld      e, (hl)
 57+  CFCB 23                       inc     hl
 58+  CFCC 56                       ld      d, (hl)
 59+  CFCD
 60+  CFCD              fileLoadStep2:
 61+  CFCD                          ; Сохраним адрес загрузки
 62+  CFCD EB                       ex      hl, de
 63+  CFCE 22 9B D2                 ld      (v_input_start), hl
 64+  CFD1 EB                       ex      hl, de
 65+  CFD2
 66+  CFD2                          ; hl = указатель на номер первого кластера файла
 67+  CFD2 2A A5 D2                 ld      hl, (v_foundDescrPtr)
 68+  CFD5 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
 69+  CFD8 09                       add     hl, bc
 70+  CFD9
 71+  CFD9                          ; de = первый кластер файла
 72+  CFD9 5E                       ld      e, (hl)
 73+  CFDA 23                       inc     hl
 74+  CFDB 56                       ld      d, (hl)
 75+  CFDC D5                       push    de
 76+  CFDD
 77+  CFDD                          ; de = первый сектор файла в области данных
 78+  CFDD CD 39 CD                 call    fatClusterToSector
 79+  CFE0
 80+  CFE0                          ; hl = указатель на длину найденного файла
 81+  CFE0 2A A5 D2                 ld      hl, (v_foundDescrPtr)
 82+  CFE3 01 1D 00                 ld      bc, FILE_DESCRIPTOR.size + 1
 83+  CFE6 09                       add     hl, bc
 84+  CFE7
 85+  CFE7                          ; c = количество кластеров файла. Просто читаем старший байт
 86+  CFE7                          ; размера, т.к. кластер размером 256 байт.
 87+  CFE7                          ; TODO: это не будет работать с другим размером кластера!
 88+  CFE7 4E                       ld      c, (hl)
 89+  CFE8 0C                       inc     c
 90+  CFE9
 91+  CFE9                          ; hl = адрес загрузки
 92+  CFE9 2A 9B D2                 ld      hl, (v_input_start)
 93+  CFEC
 94+  CFEC                          ; Режим драйвера - чтение
 95+  CFEC 06 02                    ld      b, 2
 96+  CFEE              fileLoadLoop:
 97+  CFEE                          ; Читаем кластер в память
 98+  CFEE CD 63 C8                 call    j_diskDriver    ; de = номер сектора, hl = адрес куда читать
 99+  CFF1
100+  CFF1 24                       inc     h               ; следующий блок в памяти (TODO: это работает только для сектора 256 байт)
101+  CFF2
102+  CFF2                          ; Вычисляем следующий кластер в fat
103+  CFF2 D1                       pop     de              ; de = номер текущего кластера
104+  CFF3 CD A6 CD                 call    fatReadCluster  ; de = номер следующего кластера
105+  CFF6 D5                       push    de
106+  CFF7
107+  CFF7                          ; Переводим в номер сектора
108+  CFF7 CD 39 CD                 call    fatClusterToSector  ; de = следующий сектор файла в области данных
109+  CFFA
110+  CFFA 0D                       dec     c               ; счётчик считанных кластеров
111+  CFFB C2 EE CF                 jp nz,  fileLoadLoop    ; повтор цикла
112+  CFFE
113+  CFFE                          ; Восстанавливаем регистры
114+  CFFE D1                       pop     de
115+  CFFF D1                       pop     de
116+  D000 C1                       pop     bc
117+  D001 E1                       pop     hl
118+  D002
119+  D002 C3 09 D0                 jp      fileLoadExit
120+  D005
121+  D005              ; ---------------------------------------------------------------------------
122+  D005              ; Получить информацию о файле (дескриптор)
123+  D005              ;
124+  D005              ; На входе
125+  D005              ;  hl - имя
126+  D005              ;
127+  D005              ; На выходе
128+  D005              ;  bc, de, hl - сохраняются
129+  D005              ;  v_foundDescrPtr - адрес копии дескриптора найденного файла
130+  D005              ;  cf - ошибка
131+  D005              ;----------------------------------------------------------------------------
132+  D005
133+  D005              fileLoadInfo:
134+  D005                          ; Ищем файл с именем в hl
135+  D005 CD 5F CF                 call    fileFind
136+  D008 D8                       ret c
137+  D009
138+  D009              ; ---------------------------------------------------------------------------
139+  D009
140+  D009              fileLoadExit:
141+  D009                          ; Сохраняем регистры
142+  D009 E5                       push    hl
143+  D00A C5                       push    bc
144+  D00B D5                       push    de
145+  D00C
146+  D00C                          ; de = указатель на первое поле после расширения
147+  D00C 01 0B 00                 ld      bc, FILE_DESCRIPTOR.attrib
148+  D00F 09                       add     hl, bc
149+  D010 EB                       ex      de, hl
150+  D011
151+  D011                          ; Информация о файле, исключая имя
152+  D011 2A A5 D2                 ld      hl, (v_foundDescrPtr)
153+  D014 09                       add     hl, bc
154+  D015
155+  D015                          ; Копируем дескриптор из hl в de, исключая имя и расширение
156+  D015 06 15                    ld      b, FILE_DESCR_SIZE - FILE_NAME_LENGTH - 3
157+  D017              fileLoadCDLoop:
158+  D017 7E                       ld      a, (hl)
159+  D018 12                       ld      (de), a
160+  D019 23                       inc     hl
161+  D01A 13                       inc     de
162+  D01B 05                       dec     b
163+  D01C C2 17 D0                 jp nz,  fileLoadCDLoop
164+  D01F
165+  D01F                          ; Выход CF=0
166+  D01F B7                       or      a
167+  D020 C3 D2 CE                 jp      popDBH_ret
168+  D023
149   D023              	INCLUDE "fileDelete.inc"
  1+  D023              ;+---------------------------------------------------------------------------
  2+  D023              ; MXOS
  3+  D023              ; Удаление файла
  4+  D023              ;
  5+  D023              ; На входе
  6+  D023              ;  hl - имя файла
  7+  D023              ;
  8+  D023              ; На выходе
  9+  D023              ;  cf - ошибка
 10+  D023              ;  bc, de, hl - сохраняются
 11+  D023              ;
 12+  D023              ; 2013-12-12 Дизассемблировано vinxru
 13+  D023              ; 2022-02-11 Переработано SpaceEngineer
 14+  D023              ;----------------------------------------------------------------------------
 15+  D023
 16+  D023              fileDelete: ; Найти файл с именем из hl
 17+  D023 CD 5F CF                 call    fileFind
 18+  D026 D8                       ret     c
 19+  D027
 20+  D027                          ; Удалить файл
 21+  D027 CD 2F D0                 call    deleteFileInt
 22+  D02A
 23+  D02A                          ; Сохранить изменения на диск
 24+  D02A CD 22 CD                 call    saveSectorCache
 25+  D02D
 26+  D02D                          ; Результат
 27+  D02D B7                       or      a
 28+  D02E C9                       ret
 29+  D02F
 30+  D02F              ; ---------------------------------------------------------------------------
 31+  D02F
 32+  D02F              deleteFileInt:
 33+  D02F                          ; Сохраняем регистры
 34+  D02F E5                       push    hl
 35+  D030 C5                       push    bc
 36+  D031 D5                       push    de
 37+  D032
 38+  D032                          ; Помечаем файл в кэше, как удаленный, заменяя первую букву его имени на 0FFh
 39+  D032 2A 9F D2                 ld      hl, (v_cachedDescrPtr)
 40+  D035 36 FF                    ld      (hl), 0FFh
 41+  D037 E5                       push    hl
 42+  D038
 43+  D038                          ; Ставим сектору каталога флаг isModified
 44+  D038 CD 54 CD                 call    markDirSectorAsModified
 45+  D03B
 46+  D03B                          ; Получаем первый кластер файла в de
 47+  D03B E1                       pop     hl
 48+  D03C 11 1A 00                 ld      de, FILE_DESCRIPTOR.firstCluster
 49+  D03F 19                       add     hl, de
 50+  D040 5E                       ld      e, (hl)
 51+  D041 23                       inc     hl
 52+  D042 56                       ld      d, (hl)
 53+  D043
 54+  D043              deleteFileLoop:
 55+  D043 62                       ld      h, d
 56+  D044 6B                       ld      l, e
 57+  D045
 58+  D045                          ; Обнуляем кластер номер de и получаем номер
 59+  D045                          ; следующиего кластера файла в de
 60+  D045 CD BE CD                 call    fatFreeCluster
 61+  D048
 62+  D048                          ; Если это был не последний кластер, продолжаем.
 63+  D048 7A                       ld      a, d
 64+  D049 BC                       cp      h
 65+  D04A C2 43 D0                 jp nz,  deleteFileLoop
 66+  D04D 7B                       ld      a, e
 67+  D04E BD                       cp      l
 68+  D04F C2 43 D0                 jp nz,  deleteFileLoop
 69+  D052
 70+  D052                          ; Восстаналиваем регистры и выходим
 71+  D052 C3 D2 CE                 jp      popDBH_ret
 72+  D055
150   D055              	INCLUDE "fileRename.inc"
  1+  D055              ;+---------------------------------------------------------------------------
  2+  D055              ; MXOS
  3+  D055              ; Переименовать файл
  4+  D055              ;
  5+  D055              ; На входе
  6+  D055              ;  hl - исходное имя
  7+  D055              ;  de - новое имя
  8+  D055              ;
  9+  D055              ; На выходе
 10+  D055              ;  cf - ошибка
 11+  D055              ;  bc, de, hl - сохраняются
 12+  D055              ;
 13+  D055              ; 2013-12-12 Дизассемблировано vinxru
 14+  D055              ;----------------------------------------------------------------------------
 15+  D055
 16+  D055              fileRename: ; Найти файл с именем из hl
 17+  D055 CD 5F CF                 call    fileFind
 18+  D058 D8                       ret c
 19+  D059
 20+  D059                          ; Сохранить регистры
 21+  D059 E5                       push    hl
 22+  D05A C5                       push    bc
 23+  D05B D5                       push    de
 24+  D05C
 25+  D05C 2A 9F D2                 ld      hl, (v_cachedDescrPtr)
 26+  D05F
 27+  D05F                          ; Попытаться найти файл с новым именем
 28+  D05F EB                       ex      de, hl
 29+  D060 CD 5F CF                 call    fileFind
 30+  D063
 31+  D063                          ; Если такой файл есть, то удалить
 32+  D063 D4 2F D0                 call nc,deleteFileInt
 33+  D066
 34+  D066                          ; Заменяем имя
 35+  D066 0E 0B                    ld      c, FILE_NAME_LENGTH + 3
 36+  D068 7E           loc_CD2C:   ld      a, (hl)
 37+  D069 12                       ld      (de),a
 38+  D06A 23                       inc     hl
 39+  D06B 13                       inc     de
 40+  D06C 0D                       dec     c
 41+  D06D C2 68 D0                 jp nz,  loc_CD2C
 42+  D070
 43+  D070                          ; Ставим сектору каталога флаг isModified
 44+  D070 CD 54 CD                 call    markDirSectorAsModified
 45+  D073
 46+  D073                          ; Сохраняем изменения на диск
 47+  D073 CD 22 CD                 call    saveSectorCache
 48+  D076
 49+  D076                          ; Выход
 50+  D076 B7                       or      a
 51+  D077 C3 D2 CE                 jp      popDBH_ret
 52+  D07A
151   D07A              	INCLUDE "fileGetSetAttr.inc"
  1+  D07A              ;+---------------------------------------------------------------------------
  2+  D07A              ; MXOS
  3+  D07A              ; Получение/изменение атрибутов файла
  4+  D07A              ;
  5+  D07A              ; На входе
  6+  D07A              ;   hl - имя файла
  7+  D07A              ;   с  - 0=чтение, 1=изменение
  8+  D07A              ;   b  - новые атрибуты (если c==1)
  9+  D07A              ;
 10+  D07A              ; На выходе
 11+  D07A              ;   cf - ошибка
 12+  D07A              ;   a  - атрибуты
 13+  D07A              ;   bc, de, hl - сохраняются
 14+  D07A              ;
 15+  D07A              ; 2013-12-12 Дизассемблировано vinxru
 16+  D07A              ; 2022-01-31 Доработано SpaceEngineer
 17+  D07A              ;----------------------------------------------------------------------------
 18+  D07A
 19+  D07A              fileGetSetAttr:
 20+  D07A C5                       push    bc
 21+  D07B 47                       ld      b, a
 22+  D07C
 23+  D07C                          ; Ищем файл с именем в hl. Если найден, то переходим
 24+  D07C CD 5F CF                 call    fileFind
 25+  D07F D2 84 D0                 jp nc,  fileGetSetAt_0
 26+  D082
 27+  D082                          ; Ошибка, выходим
 28+  D082 C1                       pop     bc
 29+  D083 C9                       ret
 30+  D084
 31+  D084              ; ---------------------------------------------------------------------------
 32+  D084
 33+  D084              fileGetSetAt_0:
 34+  D084 E5                       push    hl
 35+  D085
 36+  D085                          ; Получаем адрес байта атрибутов
 37+  D085 D5                       push    de
 38+  D086 2A 9F D2                 ld      hl, (v_cachedDescrPtr)
 39+  D089 11 0B 00                 ld      de, FILE_DESCRIPTOR.attrib
 40+  D08C 19                       add     hl, de
 41+  D08D D1                       pop     de
 42+  D08E
 43+  D08E                          ; Проверяем режим
 44+  D08E 79                       ld      a, c
 45+  D08F 0D                       dec     c ; ZF=1 если режим 1
 46+  D090 C2 9A D0                 jp nz,  fileGetSetAt_1
 47+  D093
 48+  D093                          ; Устанавливаем атрибуты
 49+  D093 70                       ld      (hl), b
 50+  D094
 51+  D094                          ; Ставим сектору каталога флаг isModified
 52+  D094 CD 54 CD                 call    markDirSectorAsModified
 53+  D097
 54+  D097                          ; Сохраняем изменения на диск
 55+  D097 CD 22 CD                 call    saveSectorCache
 56+  D09A
 57+  D09A              fileGetSetAt_1:
 58+  D09A                          ; Читаем атрибуты
 59+  D09A 7E                       ld      a, (hl)
 60+  D09B
 61+  D09B                          ; Восстанавливаем регистры и выходим ;! А тут точно CF==0 будет?
 62+  D09B B7                       or      a
 63+  D09C E1                       pop     hl
 64+  D09D C1                       pop     bc
 65+  D09E C9                       ret
 66+  D09F
152   D09F              	INCLUDE "fileGetSetAddr.inc"
  1+  D09F              ;+---------------------------------------------------------------------------
  2+  D09F              ; MXOS
  3+  D09F              ; Получение/изменение адреса загрузки файла
  4+  D09F              ;
  5+  D09F              ; На входе
  6+  D09F              ;   hl - имя файла
  7+  D09F              ;   с  - 0=чтение, 1=изменение
  8+  D09F              ;   de - адрес
  9+  D09F              ;
 10+  D09F              ; На выходе
 11+  D09F              ;   de - адрес
 12+  D09F              ;   bc, hl - сохраняются
 13+  D09F              ;
 14+  D09F              ; 2013-12-12 Дизассемблировано vinxru
 15+  D09F              ; 2022-01-31 Доработано SpaceEngineer
 16+  D09F              ;----------------------------------------------------------------------------
 17+  D09F
 18+  D09F              fileGetSetAddr:   ; Ищем файл с именем в hl
 19+  D09F CD 5F CF                 call    fileFind
 20+  D0A2 D8                       ret c
 21+  D0A3
 22+  D0A3 E5                       push    hl
 23+  D0A4
 24+  D0A4                          ; Получаем адрес длины файла
 25+  D0A4 D5                       push    de
 26+  D0A5 2A 9F D2                 ld      hl, (v_cachedDescrPtr)
 27+  D0A8 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 28+  D0AB 19                       add     hl, de
 29+  D0AC D1                       pop     de
 30+  D0AD
 31+  D0AD                          ; Проверяем режим
 32+  D0AD 79                       ld      a, c
 33+  D0AE 0D                       dec     c ; ZF=1 если режим 1
 34+  D0AF C2 BE D0                 jp nz,  fileGetSetAd_0
 35+  D0B2
 36+  D0B2                          ; Заменяем адрес загрузки
 37+  D0B2 73                       ld      (hl), e
 38+  D0B3 23                       inc     hl
 39+  D0B4 72                       ld      (hl), d
 40+  D0B5
 41+  D0B5                          ; Ставим сектору каталога флаг isModified
 42+  D0B5 CD 54 CD                 call    markDirSectorAsModified
 43+  D0B8
 44+  D0B8                          ; Сохраняем изменения на диск
 45+  D0B8 CD 22 CD                 call    saveSectorCache
 46+  D0BB
 47+  D0BB                          ; Выходим
 48+  D0BB E1                       pop     hl
 49+  D0BC B7                       or      a
 50+  D0BD C9                       ret
 51+  D0BE
 52+  D0BE              fileGetSetAd_0:
 53+  D0BE                          ; Читаем адрес загрузки
 54+  D0BE 5E                       ld      e, (hl)
 55+  D0BF 23                       inc     hl
 56+  D0C0 56                       ld      d, (hl)
 57+  D0C1
 58+  D0C1                          ; Выходим
 59+  D0C1 E1                       pop     hl
 60+  D0C2 B7                       or      a
 61+  D0C3 C9                       ret
 62+  D0C4
153   D0C4              	INCLUDE "fileGetInfoAddr.inc"
  1+  D0C4              ;+---------------------------------------------------------------------------
  2+  D0C4              ; MXOS
  3+  D0C4              ; Получить указатель на информацию о a==1
  4+  D0C4              ;
  5+  D0C4              ; На входе
  6+  D0C4              ;   c - любое число
  7+  D0C4              ;
  8+  D0C4              ; На выходе
  9+  D0C4              ;   b, de - сохраняются
 10+  D0C4              ;   hl - указатель на дескриптор после расширения
 11+  D0C4              ;   zf - если a==1
 12+  D0C4              ;   a = c
 13+  D0C4              ;   c = c-1
 14+  D0C4              ;
 15+  D0C4              ; 2013-12-12 Дизассемблировано vinxru
 16+  D0C4              ;----------------------------------------------------------------------------
 17+  D0C4
 18+  D0C4              ;fileGetInfoAddr:
 19+  D0C4              ;            push de
 20+  D0C4              ;
 21+  D0C4              ;            ; Помещаем в hl адрес информации о файле
 22+  D0C4              ;            ld    hl, (v_foundDescrPtr)
 23+  D0C4              ;            ld    de, FILE_DESCRIPTOR.attrib
 24+  D0C4              ;            add   scf
 25+  D0C4              ;
 26+  D0C4              ;            ; Помещаем в a режим
 27+  D0C4              ;            ld    a, c
 28+  D0C4              ;
 29+  D0C4              ;            ; ZF=1 если режим 1
 30+  D0C4              ;            dec c
 31+  D0C4              ;
 32+  D0C4              ;            pop de
 33+  D0C4              ;            ret
 34+  D0C4              ;
 35+  D0C4
154   D0C4              	INCLUDE "fileList.inc"
  1+  D0C4              ;+---------------------------------------------------------------------------
  2+  D0C4              ; MXOS
  3+  D0C4              ; Получить список файлов каталога.
  4+  D0C4              ; Функция копирует в буфер уомпактные описатели файлов (FILE_INFO).
  5+  D0C4              ;
  6+  D0C4              ; На входе
  7+  D0C4              ;  hl - адрес буфера
  8+  D0C4              ;  de - размер буфера (макс. количество описателей файлов)
  9+  D0C4              ;  bc - с какого дескриптора начинать заполнение буфера
 10+  D0C4              ;
 11+  D0C4              ; На выходе
 12+  D0C4              ;  de - сколько всего дескрипторов в каталоге
 13+  D0C4              ;
 14+  D0C4              ;  bc, hl - сохраняются
 15+  D0C4              ;
 16+  D0C4              ; 2013-12-12 Дизассемблировано vinxru
 17+  D0C4              ; 2022-02-11 Переработано SpaceEngineer
 18+  D0C4              ;----------------------------------------------------------------------------
 19+  D0C4
 20+  D0C4              fileList:   ; Если нет драйвера или диск не отформатирован -
 21+  D0C4                          ; формируем пустой список и выходим
 22+  D0C4 3A E7 D2                 ld      a, (v_diskInfo.isValid)
 23+  D0C7 FE 02                    cp      DISK_VALID
 24+  D0C9 CA D2 D0                 jp z,   fileListOk
 25+  D0CC
 26+  D0CC                          ; В начало буфера помещаем символ 0FFh
 27+  D0CC 36 FF                    ld      (hl), 0FFh
 28+  D0CE
 29+  D0CE                          ; Возвращаем количество файлов в директории в de (ноль)
 30+  D0CE 11 00 00                 ld      de, 0
 31+  D0D1 C9                       ret
 32+  D0D2
 33+  D0D2              fileListOk: ; Сохранение регистров
 34+  D0D2 C5                       push    bc  ; [1]
 35+  D0D3 E5                       push    hl  ; [2]
 36+  D0D4
 37+  D0D4                          ; В de - максимум файлов, но его надо еще ограничить размером каталога
 38+  D0D4 2A D1 D2                 ld      hl, (v_diskInfo.rootDirMaxFiles)
 39+  D0D7 CD 89 C3                 call    cmp_hl_de_2
 40+  D0DA DA DE D0                 jp c,   fl_min
 41+  D0DD EB                       ex      hl, de
 42+  D0DE              fl_min:     ; Сохраняем максимум файлов
 43+  D0DE 22 AD D2                 ld      (v_dirMaxFiles), hl
 44+  D0E1
 45+  D0E1                          ; Сохраняем номер первого файла
 46+  D0E1 60                       ld      h, b
 47+  D0E2 69                       ld      l, c
 48+  D0E3 22 AB D2                 ld      (v_dirFirstFile), hl
 49+  D0E6
 50+  D0E6                          ; Обнуляем счетчики файлов
 51+  D0E6 21 00 00                 ld      hl, 0
 52+  D0E9 22 AF D2                 ld      (v_dirListedFiles), hl
 53+  D0EC 22 B1 D2                 ld      (v_dirTotalFiles),  hl
 54+  D0EF
 55+  D0EF E1                       pop     hl  ; [2]
 56+  D0F0 E5                       push    hl  ; [2]
 57+  D0F1
 58+  D0F1                          ; de = номер первого сектора каталога
 59+  D0F1                          ; с  = количество секторов каталога (мл. байт)
 60+  D0F1 CD 4A CD                 call    fatBeginDirLoop
 61+  D0F4
 62+  D0F4                          ; Цикл по секторам каталога
 63+  D0F4              fileList_dirLoop:
 64+  D0F4                          ; Сохраняем номер сектора каталога
 65+  D0F4 D5                       push    de  ; [3]               ; de = номер сектора каталога
 66+  D0F5
 67+  D0F5                          ; Кэшируем сектор каталога
 68+  D0F5 E5                       push    hl  ; [4]
 69+  D0F6 AF                       xor     a                       ; флаг - сектор не будет меняться
 70+  D0F7 CD 6C CC                 call    getSectorAddressInCache ; выход: hl = адрес сектора в буфере
 71+  D0FA EB                       ex      hl, de                  ; de = адрес сектора в буфере
 72+  D0FB E1                       pop     hl  ; [4]
 73+  D0FC
 74+  D0FC                          ; Кол-во дескрипторов файлов в одном секторе каталога (мл. байт)
 75+  D0FC 3A D3 D2                 ld      a, (v_diskInfo.descrPerSector)
 76+  D0FF 47                       ld      b, a
 77+  D100
 78+  D100                          ; Цикл по дескрипторам в закешированном секторе каталога
 79+  D100              fileList_sectorLoop:
 80+  D100                          ; Если первый символ = FFh, дескриптор пустой
 81+  D100 1A                       ld      a, (de)
 82+  D101 3C                       inc     a
 83+  D102 CA 35 D1                 jp z,   fileList_nextDescr
 84+  D105
 85+  D105 E5                       push    hl  ; [4]
 86+  D106 D5                       push    de  ; [5]
 87+  D107
 88+  D107                          ; Увеличиваем счетчик общего количества файлов в каталоге
 89+  D107 2A B1 D2                 ld      hl, (v_dirTotalFiles)
 90+  D10A 23                       inc     hl
 91+  D10B 22 B1 D2                 ld      (v_dirTotalFiles), hl
 92+  D10E
 93+  D10E                          ; Если не дошли до первого файла (v_dirTotalFiles < v_dirFirstFile),
 94+  D10E                          ; то продолжаем сканирование каталога без копирования дескриптора в буфер
 95+  D10E EB                       ex      hl, de
 96+  D10F 2A AB D2                 ld      hl, (v_dirFirstFile)
 97+  D112 CD 27 C4                 call    cmp_hl_de
 98+  D115 D2 33 D1                 jp nc,  fileList_skipCopy
 99+  D118
100+  D118                          ; Если буфер уже заполнен (v_dirListedFiles >= v_dirMaxFiles),
101+  D118                          ; то продолжаем сканирование каталога без копирования дескриптора в буфер
102+  D118 2A AD D2                 ld      hl, (v_dirMaxFiles)
103+  D11B EB                       ex      hl, de
104+  D11C 2A AF D2                 ld      hl, (v_dirListedFiles)
105+  D11F CD 27 C4                 call    cmp_hl_de
106+  D122 D2 33 D1                 jp nc,  fileList_skipCopy
107+  D125
108+  D125                          ; Увеличиваем счетчик скопированных дескрипторов
109+  D125 23                       inc     hl
110+  D126 22 AF D2                 ld      (v_dirListedFiles), hl
111+  D129
112+  D129 D1                       pop     de  ; [5]
113+  D12A E1                       pop     hl  ; [4]
114+  D12B
115+  D12B                          ; Копируем дескриптор из de в hl
116+  D12B C5                       push    bc  ; [4]
117+  D12C                          ;call    copyDescriptor
118+  D12C CD C2 D1                 call    copyDescriptorCompact
119+  D12F C1                       pop     bc  ; [4]
120+  D130
121+  D130                          ; copyDescriptor смещает de, поэтому код расчета
122+  D130                          ; адреса следующего дескриптора надо перепрыгнуть
123+  D130                          ;jp      fileList_next
124+  D130 C3 35 D1                 jp      fileList_nextDescr
125+  D133
126+  D133              fileList_skipCopy:
127+  D133 D1                       pop     de  ; [5]
128+  D134 E1                       pop     hl  ; [4]
129+  D135
130+  D135              fileList_nextDescr:
131+  D135                          ; Вычисляем адрес следующего дескриптора
132+  D135 E5                       push    hl  ; [4]
133+  D136 21 20 00                 ld      hl, FILE_DESCR_SIZE
134+  D139 19                       add     hl, de
135+  D13A EB                       ex      de, hl
136+  D13B E1                       pop     hl  ; [4]
137+  D13C
138+  D13C              fileList_next:
139+  D13C                          ; Еще остались файлы в секторе каталога?
140+  D13C 05                       dec     b
141+  D13D C2 00 D1                 jp nz,  fileList_sectorLoop
142+  D140
143+  D140                          ; Еще остались секторы каталога?
144+  D140                          ; Восстанавливаем номер сектора каталога
145+  D140 D1                       pop     de  ; [3]   de = номер сектора каталога
146+  D141 13                       inc     de  ;       следующий сектор каталога
147+  D142 0D                       dec     c
148+  D143 C2 F4 D0                 jp nz,  fileList_dirLoop
149+  D146
150+  D146              fileList_exit
151+  D146                          ; Завершение и выход
152+  D146                          ; В конец буфера помещаем символ 0FFh
153+  D146 36 FF                    ld      (hl), 0FFh
154+  D148
155+  D148                          ; Возвращаем количество файлов в директории в de
156+  D148 2A B1 D2                 ld      hl, (v_dirTotalFiles)
157+  D14B EB                       ex      hl, de
158+  D14C
159+  D14C E1                       pop     hl  ; [2]
160+  D14D C1                       pop     bc  ; [1]
161+  D14E C9                       ret
162+  D14F
155   D14F              	INCLUDE "fileNamePrepare.inc"
  1+  D14F              ;+---------------------------------------------------------------------------
  2+  D14F              ; MXOS
  3+  D14F              ; Подготовить имя файла для функций ОС
  4+  D14F              ;
  5+  D14F              ; На входе
  6+  D14F              ;  hl - исходное имя
  7+  D14F              ;  de - буфер для результата (P_INPUT_WIDTH + 3 байт)
  8+  D14F              ;
  9+  D14F              ; 2013-12-12 Дизассемблировано vinxru
 10+  D14F              ;----------------------------------------------------------------------------
 11+  D14F
 12+  D14F              fileNamePrepare:
 13+  D14F                          ; Сохраняем регистры
 14+  D14F C5                       push    bc
 15+  D150 D5                       push    de
 16+  D151
 17+  D151                          ; Если второй символ исходной строки ':', то меняем диск
 18+  D151 23                       inc     hl
 19+  D152 7E                       ld      a, (hl)
 20+  D153 FE 3A                    cp      ':'
 21+  D155 2B                       dec     hl
 22+  D156 C2 63 D1                 jp nz,  fileNamePr_1
 23+  D159
 24+  D159                          ; Меняем диск
 25+  D159 7E                       ld      a, (hl)
 26+  D15A D6 41                    sub     'A'
 27+  D15C E5                       push    hl
 28+  D15D CD B1 CB                 call    fileSelectDrive
 29+  D160 E1                       pop     hl
 30+  D161
 31+  D161                          ; Диск не входит в имя файла
 32+  D161 23                       inc     hl
 33+  D162 23                       inc     hl
 34+  D163
 35+  D163              fileNamePr_1:
 36+  D163                          ; b = длина имени, c = 3 - длина расширения
 37+  D163 01 03 08                 ld      bc, (FILE_NAME_LENGTH << 8) + 3
 38+  D166
 39+  D166                          ; Копируем текст до точки, пробела или конца строки, не более FILE_NAME_LENGTH символов.
 40+  D166              fileNamePr_2:
 41+  D166 7E                       ld      a, (hl)
 42+  D167 A7                       and     a
 43+  D168 F2 6D D1                 jp p,   fileNamePr_3
 44+  D16B D6 40                    sub     40h         ; проеобразование KOI?
 45+  D16D              fileNamePr_3:
 46+  D16D FE 21                    cp      ' '+1
 47+  D16F DA 8D D1                 jp c,   fileNamePr_5
 48+  D172 23                       inc     hl
 49+  D173 FE 2E                    cp      '.'
 50+  D175 CA 8D D1                 jp z,   fileNamePr_5
 51+  D178 12                       ld      (de), a
 52+  D179 13                       inc     de
 53+  D17A 05                       dec     b
 54+  D17B C2 66 D1                 jp nz,  fileNamePr_2
 55+  D17E
 56+  D17E                          ; Пропускаем текст до точки, пробела или конца строки
 57+  D17E              fileNamePr_4:
 58+  D17E 7E                       ld      a, (hl)
 59+  D17F FE 21                    cp      ' '+1
 60+  D181 DA 90 D1                 jp c,   fileNamePr_6
 61+  D184 23                       inc     hl
 62+  D185 FE 2E                    cp      '.'
 63+  D187 C2 7E D1                 jp nz,  fileNamePr_4
 64+  D18A C3 90 D1                 jp      fileNamePr_6
 65+  D18D
 66+  D18D              ; ---------------------------------------------------------------------------
 67+  D18D
 68+  D18D              fileNamePr_5:
 69+  D18D                          ; Имя короче FILE_NAME_LENGTH символов
 70+  D18D                          ; Заполняем недостающие символы имени пробелами
 71+  D18D CD C7 C3                 call    memset_de_20_b
 72+  D190
 73+  D190                          ; Копируем текст до пробела или конца строки, не более 3 символов.
 74+  D190              fileNamePr_6:
 75+  D190 7E                       ld      a, (hl)
 76+  D191 A7                       and     a
 77+  D192 F2 97 D1                 jp p,   fileNamePr_7
 78+  D195 D6 40                    sub     40h         ; проеобразование KOI?
 79+  D197              fileNamePr_7:
 80+  D197 FE 21                    cp      ' '+1
 81+  D199 DA B0 D1                 jp c,   fileNamePr_11
 82+  D19C 12                       ld      (de),a
 83+  D19D 23                       inc     hl
 84+  D19E 13                       inc     de
 85+  D19F 0D                       dec     c
 86+  D1A0 C2 90 D1                 jp nz,  fileNamePr_6
 87+  D1A3
 88+  D1A3              fileNamePr_8:
 89+  D1A3                          ; Пропускаем текст до пробела или конца строки
 90+  D1A3 7E                       ld      a, (hl)
 91+  D1A4 FE 20                    cp      ' '
 92+  D1A6 DA AD D1                 jp c,   fileNamePr_10
 93+  D1A9 23                       inc     hl
 94+  D1AA C2 A3 D1                 jp nz,  fileNamePr_8
 95+  D1AD
 96+  D1AD              ;fileNamePr_9:
 97+  D1AD              ;            ; Пропускаем текст до пробела или конца строки
 98+  D1AD              ;            ; Почему то дублируется код
 99+  D1AD              ;            ld      a, (hl)
100+  D1AD              ;            cp      ' '
101+  D1AD              ;            jp c,   fileNamePr_10
102+  D1AD              ;            inc     hl
103+  D1AD              ;            jp z,   fileNamePr_9
104+  D1AD              ;            dec     hl
105+  D1AD
106+  D1AD              fileNamePr_10:    ; Восстанавливаем регистры и выходим
107+  D1AD D1                       pop     de
108+  D1AE C1                       pop     bc
109+  D1AF C9                       ret
110+  D1B0
111+  D1B0              ; ---------------------------------------------------------------------------
112+  D1B0
113+  D1B0              fileNamePr_11:
114+  D1B0                          ; Заполняем недостающие символы расширения пробелами
115+  D1B0 41                       ld      b, c
116+  D1B1 CD C7 C3                 call    memset_de_20_b
117+  D1B4
118+  D1B4                          ; Восстанавливаем регистры и выходим
119+  D1B4 D1                       pop     de
120+  D1B5 C1                       pop     bc
121+  D1B6 C9                       ret
122+  D1B7
156   D1B7                  INCLUDE "copyDescriptor.inc"
  1+  D1B7              ;----------------------------------------------------------------------------
  2+  D1B7              ; MXOS
  3+  D1B7              ; Копирование дескриптора файла (FILE_DESCRIPTOR)
  4+  D1B7              ;
  5+  D1B7              ; вход:
  6+  D1B7              ;  de = адрес откуда
  7+  D1B7              ;  hl = адрес куда
  8+  D1B7              ;
  9+  D1B7              ; выход:
 10+  D1B7              ;  de = адрес следующего дескриптора
 11+  D1B7              ;  hl = адрес следующего дескриптора
 12+  D1B7              ;
 13+  D1B7              ; 2022-02-11 SpaceEngineer
 14+  D1B7              ;----------------------------------------------------------------------------
 15+  D1B7
 16+  D1B7              copyDescriptor:
 17+  D1B7                          ; Копируем FILE_DESCR_SIZE байт из de в hl
 18+  D1B7 06 20                    ld      b, FILE_DESCR_SIZE
 19+  D1B9 1A           cfd_loop:   ld      a, (de)
 20+  D1BA 77                       ld      (hl), a
 21+  D1BB 23                       inc     hl
 22+  D1BC 13                       inc     de
 23+  D1BD 05                       dec     b
 24+  D1BE C2 B9 D1                 jp nz,  cfd_loop
 25+  D1C1 C9                       ret
 26+  D1C2
 27+  D1C2              ;----------------------------------------------------------------------------
 28+  D1C2              ; MXOS
 29+  D1C2              ; Проеобразование дескриптора файла в компактную форму
 30+  D1C2              ; FILE_DESCRIPTOR -> FILE_INFO
 31+  D1C2              ;
 32+  D1C2              ; вход:
 33+  D1C2              ;  de = адрес откуда
 34+  D1C2              ;  hl = адрес куда
 35+  D1C2              ;
 36+  D1C2              ; выход:
 37+  D1C2              ;  hl = адрес следующего описателя
 38+  D1C2              ;
 39+  D1C2              ;  de - сохраняется
 40+  D1C2              ;
 41+  D1C2              ; 2022-02-16 SpaceEngineer
 42+  D1C2              ;----------------------------------------------------------------------------
 43+  D1C2
 44+  D1C2              copyDescriptorCompact:
 45+  D1C2 D5                       push    de
 46+  D1C3
 47+  D1C3                          ; Копируем имя файла + расширение + байт атрибутов
 48+  D1C3 06 0C                    ld      b, FILE_NAME_LENGTH + 4
 49+  D1C5 1A           cfdc_loop:  ld      a, (de)
 50+  D1C6 77                       ld      (hl), a
 51+  D1C7 23                       inc     hl
 52+  D1C8 13                       inc     de
 53+  D1C9 05                       dec     b
 54+  D1CA C2 C5 D1                 jp nz,  cfdc_loop
 55+  D1CD
 56+  D1CD                          ; Копируем поле адреса загрузки
 57+  D1CD EB                       ex      hl, de
 58+  D1CE 01 06 00                 ld      bc, FILE_DESCRIPTOR.loadAddress - FILE_DESCRIPTOR.attrib - 1   ; относительное смещение поля loadAddr
 59+  D1D1 09                       add     hl, bc
 60+  D1D2 EB                       ex      hl, de
 61+  D1D3
 62+  D1D3 1A                       ld      a, (de)
 63+  D1D4 77                       ld      (hl), a
 64+  D1D5 23                       inc     hl
 65+  D1D6 13                       inc     de
 66+  D1D7 1A                       ld      a, (de)
 67+  D1D8 77                       ld      (hl), a
 68+  D1D9 23                       inc     hl
 69+  D1DA
 70+  D1DA                          ; Копируем поле размера
 71+  D1DA EB                       ex      hl, de
 72+  D1DB 01 09 00                 ld      bc, FILE_DESCRIPTOR.size - FILE_DESCRIPTOR.loadAddress - 1  ; относительное смещение поля size
 73+  D1DE 09                       add     hl, bc
 74+  D1DF EB                       ex      hl, de
 75+  D1E0
 76+  D1E0 1A                       ld      a, (de)
 77+  D1E1 77                       ld      (hl), a
 78+  D1E2 23                       inc     hl
 79+  D1E3 13                       inc     de
 80+  D1E4 1A                       ld      a, (de)
 81+  D1E5 77                       ld      (hl), a
 82+  D1E6 23                       inc     hl
 83+  D1E7
 84+  D1E7 D1                       pop     de
 85+  D1E8 C9                       ret
 86+  D1E9
157   D1E9              	INCLUDE "printDecWord.inc"
  1+  D1E9              ;----------------------------------------------------------------------------
  2+  D1E9              ; MXOS DOS.SYS
  3+  D1E9              ; Вывод десятичного числа из de
  4+  D1E9              ; Перенесено из NC.COM
  5+  D1E9              ;
  6+  D1E9              ; вход:
  7+  D1E9              ;   de = число
  8+  D1E9              ;   b = дополнить ведущими символами: 20h - пробелами, 30h - нулями, 00h - не дополнять
  9+  D1E9              ;
 10+  D1E9              ; выход:
 11+  D1E9              ;   hl, de, bc - сохраняются
 12+  D1E9              ;
 13+  D1E9              ; 2013-12-18 Дизассемблировано vinxru
 14+  D1E9              ;----------------------------------------------------------------------------
 15+  D1E9
 16+  D1E9              printDecWord:
 17+  D1E9 D5                       push  de
 18+  D1EA C5                       push  bc
 19+  D1EB E5                       push  hl
 20+  D1EC EB                       ex    de, hl
 21+  D1ED                          ; ld    b,  20h  ; b = маска кода символа, заменяет ведущие нули на (код_символа and маска)
 22+  D1ED 11 F0 D8                 ld    de, -10000
 23+  D1F0 CD 10 D2                 call  printDec1
 24+  D1F3 11 18 FC                 ld    de, -1000
 25+  D1F6 CD 10 D2                 call  printDec1
 26+  D1F9 11 9C FF                 ld    de, -100
 27+  D1FC CD 10 D2                 call  printDec1
 28+  D1FF 11 F6 FF                 ld    de, -10
 29+  D202 CD 10 D2                 call  printDec1
 30+  D205 7D                       ld    a, l
 31+  D206 C6 30                    add   a, '0'
 32+  D208 4F                       ld    c, a
 33+  D209 CD 37 C0                 call  printChar
 34+  D20C E1                       pop   hl
 35+  D20D C1                       pop   bc
 36+  D20E D1                       pop   de
 37+  D20F C9                       ret
 38+  D210
 39+  D210              ; ---------------------------------------------------------------------------
 40+  D210
 41+  D210
 42+  D210              printDec1:  ; c = '0' + (hl / de), hl /= de;
 43+  D210 0E 2F                    ld    c, '0'-1
 44+  D212
 45+  D212 0C           loc_DB11:   inc   c
 46+  D213 19                       add   hl, de
 47+  D214 DA 12 D2                 jp c, loc_DB11
 48+  D217
 49+  D217 7A                       ld    a, d        ; hl -= de;
 50+  D218 2F                       cpl
 51+  D219 57                       ld    d, a
 52+  D21A 7B                       ld    a, e
 53+  D21B 2F                       cpl
 54+  D21C 5F                       ld    e, a
 55+  D21D 13                       inc   de
 56+  D21E 19                       add   hl, de
 57+  D21F 79                       ld    a, c
 58+  D220
 59+  D220                          ; if (c!='0') b=0xFF; c&=b;
 60+  D220 FE 30                    cp    '0'
 61+  D222 CA 27 D2                 jp z, loc_DB26
 62+  D225 06 FF                    ld    b, 0FFh   ; первый не ноль, меняем маску кода символа на 0FFh
 63+  D227 A0           loc_DB26:   and   b
 64+  D228 C8                       ret   z ; выходим если код символа 0
 65+  D229 4F                       ld    c, a
 66+  D22A C3 37 C0                 jp    printChar
 67+  D22D
158   D22D                  INCLUDE "math.inc"
  1+  D22D              ;+---------------------------------------------------------------------------
  2+  D22D              ; MXOS
  3+  D22D              ; Математические фуннкции
  4+  D22D              ;----------------------------------------------------------------------------
  5+  D22D
  6+  D22D              ;----------------------------------------------------------------------------
  7+  D22D              ; Вычитание hl и de:
  8+  D22D              ; hl = hl - de
  9+  D22D              ;
 10+  D22D              ; de, bc - сохраняется
 11+  D22D              ;
 12+  D22D              ; SpaceEngineer
 13+  D22D              ;----------------------------------------------------------------------------
 14+  D22D
 15+  D22D              sub_hl_de:
 16+  D22D 7D                   ld    a, l
 17+  D22E 93                   sub   e
 18+  D22F 6F                   ld    l, a
 19+  D230 7C                   ld    a, h
 20+  D231 9A                   sbc   d
 21+  D232 67                   ld    h, a
 22+  D233 C9                   ret
 23+  D234
 24+  D234              ;----------------------------------------------------------------------------
 25+  D234              ; Деление hl на 2:
 26+  D234              ; hl = hl / 2
 27+  D234              ;
 28+  D234              ; de, bc - сохраняется
 29+  D234              ;
 30+  D234              ; SpaceEngineer
 31+  D234              ;----------------------------------------------------------------------------
 32+  D234
 33+  D234              div_hl_2:
 34+  D234 7C                   ld  a, h
 35+  D235 B7                   or  a    ; сброс флага c
 36+  D236 1F                   rra
 37+  D237 67                   ld  h, a
 38+  D238 7D                   ld  a, l
 39+  D239 1F                   rra
 40+  D23A 6F                   ld  l, a
 41+  D23B C9                   ret
 42+  D23C
 43+  D23C              ;----------------------------------------------------------------------------
 44+  D23C              ; Умножение hl на de:
 45+  D23C              ; hl = hl * de
 46+  D23C              ;
 47+  D23C              ;
 48+  D23C              ; На входе
 49+  D23C              ;  hl, de - множители
 50+  D23C              ;
 51+  D23C              ; На выходе
 52+  D23C              ;  hl - произведение
 53+  D23C              ;
 54+  D23C              ;  bc - сохраняется
 55+  D23C              ;
 56+  D23C              ; Взято из проекта c8080 VWarlock'a
 57+  D23C              ; https://github.com/VWarlock/C8080
 58+  D23C              ;----------------------------------------------------------------------------
 59+  D23C
 60+  D23C              mul_hl_de:
 61+  D23C C5                   push    bc
 62+  D23D 44                   ld      b, h
 63+  D23E 4D                   ld      c, l
 64+  D23F 21 00 00             ld      hl, 0
 65+  D242 3E 11                ld      a, 17
 66+  D244 3D           _mul1:  dec     a
 67+  D245 CA 5F D2             jp      z, pop_bc_ret
 68+  D248 29                   add     hl, hl
 69+  D249 EB                   ex      hl, de
 70+  D24A D2 52 D2             jp      nc, _mul2
 71+  D24D 29                   add     hl, hl
 72+  D24E 24                   inc     h
 73+  D24F C3 53 D2             jp      _mul3
 74+  D252 29           _mul2:  add     hl, hl
 75+  D253 EB           _mul3:  ex      hl, de
 76+  D254 D2 44 D2             jp      nc, _mul1
 77+  D257 09                   add     hl, bc
 78+  D258 D2 44 D2             jp      nc, _mul1
 79+  D25B 14                   inc     d
 80+  D25C C3 44 D2             jp      _mul1
 81+  D25F
 82+  D25F              pop_bc_ret:
 83+  D25F C1                   pop     bc
 84+  D260 C9                   ret
 85+  D261
 86+  D261              ;----------------------------------------------------------------------------
 87+  D261              ; Деление hl на de:
 88+  D261              ; hl = hl / de
 89+  D261              ; de = hl % de
 90+  D261              ;
 91+  D261              ; На входе
 92+  D261              ;  hl - делимое
 93+  D261              ;  de - делитель
 94+  D261              ;
 95+  D261              ; На выходе
 96+  D261              ;  hl - частное
 97+  D261              ;  de - останок
 98+  D261              ;
 99+  D261              ;  bc - сохраняется
100+  D261              ;
101+  D261              ; Взято из проекта c8080 VWarlock'a
102+  D261              ; https://github.com/VWarlock/C8080
103+  D261              ;----------------------------------------------------------------------------
104+  D261
105+  D261              div_hl_de:
106+  D261 C5                   push    bc
107+  D262 EB                   ex      hl, de
108+  D263 CD 68 D2             call    _div0
109+  D266 C1                   pop     bc
110+  D267 C9                   ret
111+  D268
112+  D268 7C           _div0:  ld      a, h
113+  D269 B5                   or      l
114+  D26A C8                   ret     z
115+  D26B 01 00 00             ld      bc, 0
116+  D26E C5                   push    bc
117+  D26F 7B           _div1:  ld      a, e
118+  D270 95                   sub     L
119+  D271 7A                   ld      a, d
120+  D272 9C                   sbc     h
121+  D273 DA 7B D2             jp      c, _div2
122+  D276 E5                   push    hl
123+  D277 29                   add     hl, hl
124+  D278 D2 6F D2             jp      nc, _div1
125+  D27B 21 00 00     _div2:  ld      hl, 0
126+  D27E C1           _div3:  pop     bc
127+  D27F 78                   ld      a, b
128+  D280 B1                   or      c
129+  D281 C8                   ret     z
130+  D282 29                   add     hl, hl
131+  D283 D5                   push    de
132+  D284 7B                   ld      a, e
133+  D285 91                   sub     c
134+  D286 5F                   ld      e, a
135+  D287 7A                   ld      a, d
136+  D288 98                   sbc     b
137+  D289 57                   ld      d, a
138+  D28A DA 92 D2             jp      c, _div4
139+  D28D 23                   inc     hl
140+  D28E C1                   pop     bc
141+  D28F C3 7E D2             jp      _div3
142+  D292 D1           _div4:  pop     de
143+  D293 C3 7E D2             jp      _div3
144+  D296
159   D296
160   D296              ;---------------------------------------------------------------------------
161   D296              ; Константы и Переменные
162   D296              ;---------------------------------------------------------------------------
163   D296
164   D296 01           v_drive:            DB 1            ; Текущий накопитель
165   D297 00 00        v_findCluster:      DW 0            ; Используется в fileFindClusterFirst/fileFindClusterNext
166   D299 00 00        v_fileFirstCluster: DW 0            ; Первый кластер созданного файла
167   D29B 00 00        v_input_start:      DW 0            ; Используется в input, createFile
168   D29D 00 00        v_input_end:        DW 0            ; Используется в input, createFile
169   D29F 00 00        v_cachedDescrPtr:   DW 0            ; Используется в findFile, createFile
170   D2A1 00 00        v_cachedSector:     DW 0            ; Используется в findFile, createFile
171   D2A3 00 00        v_newDescrPtr:      DW 0            ; Адрес дескриптора созданного файла
172   D2A5 00 00        v_foundDescrPtr:    DW 0            ; Адрес дескриптора найденного файла
173   D2A7 00 00        v_batPtr:           DW 0            ; Адрес буфра, где находится содержимое BAT файла
174   D2A9 DE 8F        v_memTop:           DW bios_vars-1  ; Максимальный доступный программам адрес в памяти (в оригинале почему-то 0FAFFh)
175   D2AB 00 00        v_dirFirstFile      DW 0            ; Используется в fileList
176   D2AD 00 00        v_dirMaxFiles       DW 0            ; Используется в fileList
177   D2AF 00 00        v_dirListedFiles    DW 0            ; Используется в fileList
178   D2B1 00 00        v_dirTotalFiles     DW 0            ; Используется в fileList
179   D2B3
180   D2B3              ; Фейковое "системное время". Пока что просто счетчик, увеличивающийся при обращении.
181   D2B3              ; В будущем может быть заменен на реальное время с RTC или таймера.
182   D2B3 00 00        v_fakeSystemTime:   DW 0
183   D2B5
184   D2B5              ; Адреса драйверов для 8 накопителей. Начальные значения:
185   D2B5              ; = diskDriver для накопителей A: и B: (встроенный драйвер ROM и RAM диска),
186   D2B5              ; = diskDriverDummy для отальных (пустой драйвер).
187   D2B5 F0 CA F0 CA  v_drives:           DW diskDriver,      diskDriver      ; A:, B:
188   D2B9 83 CB 83 CB                      DW diskDriverDummy, diskDriverDummy ; C:, D:
189   D2BD 83 CB 83 CB                      DW diskDriverDummy, diskDriverDummy ; E:, F:
190   D2C1 83 CB 83 CB                      DW diskDriverDummy, diskDriverDummy ; G:, H:
191   D2C5
192   D2C5              ; Информация о текущем накопителе
193   D2C5 00 00 00 00  v_diskInfo          DISK_INFO
193   D2C9 00 00 00 00
193   D2CD 00 00 00 00
193   D2D1 00 00 00 00
193   D2D5 00 00 00 00
193   D2D9 00 00 00 00
193   D2DD 00 00 00 00
193   D2E1 00...
193   D2E7 00
194   D2E8
195   D2E8 41 3A 46 4F  pathFontFnt:        DB "A:FONT.FNT",0
195   D2EC 4E 54 2E 46
195   D2F0 4E 54 00
196   D2F3 41 3A 4E 43  pathNcCom:          DB "A:NC.COM",0
196   D2F7 2E 43 4F 4D
196   D2FB 00
197   D2FC 41 3A 41 55  pathAutoexecBat:    DB "A:AUTOEXEC.BAT",0
197   D300 54 4F 45 58
197   D304 45 43 2E 42
197   D308 41 54 00
198   D30B 41 3A 46 4F  pathFormatBat:      DB "A:FORMAT.BAT",0
198   D30F 52 4D 41 54
198   D313 2E 42 41 54
198   D317 00
199   D318 42 41 54     aBat:               DB "BAT"
200   D31B 43 4F 4D     aCom:               DB "COM"
201   D31E 45 58 45     aExe:               DB "EXE"
202   D321 46 41 54     aFat:               DB "FAT"
203   D324
204   D324                  IF BOOT_FROM_TAPE
205   D324 ~            aATape_com:         DB "A:TAPE.COM",0
206   D324 ~            txtLoadingFromTape: DB 0Ah,"LOADING FROM TAPE...",0
207   D324                  ENDIF
208   D324
209   D324 0C 42 49 4F  txtBiosVer:         DB 0Ch,"BIOS 5.00",0Ah,0
209   D328 53 20 35 2E
209   D32C 30 30 0A 00
210   D330 0A 52 41 4D  txtRAM:             DB 0Ah,"RAM: ",0
210   D334 3A 20 00
211   D337 20 4B 42 0A  txtKB:              DB " KB",0Ah,0
211   D33B 00
212   D33C 0A 42 41 44  txtBadCommand:	    DB 0Ah,"BAD COMMAND OR FILE NAME",0
212   D340 20 43 4F 4D
212   D344 4D 41 4E 44
212   D348 20 4F 52 20
212   D34C 46 49 4C 45
212   D350 20 4E 41 4D
212   D354 45 00
213   D356
214   D356 00 00 00 00  v_tmpFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего файла
214   D35A 00 00 00 00
214   D35E 00 00 00 00
214   D362 00 00 00 00
214   D366 00 00 00 00
214   D36A 00 00 00 00
214   D36E 00 00 00 00
214   D372 00 00 00 00
215   D376 00 00 00 00  v_curFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего файла
215   D37A 00 00 00 00
215   D37E 00 00 00 00
215   D382 00 00 00 00
215   D386 00 00 00 00
215   D38A 00 00 00 00
215   D38E 00 00 00 00
215   D392 00 00 00 00
216   D396 00 00 00 00  v_batFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего BAT файла
216   D39A 00 00 00 00
216   D39E 00 00 00 00
216   D3A2 00 00 00 00
216   D3A6 00 00 00 00
216   D3AA 00 00 00 00
216   D3AE 00 00 00 00
216   D3B2 00 00 00 00
217   D3B6
218   D3B6              ; Буфер для копирования изображения символов при использовании шрифта из ПЗУ
219   D3B6 FF FF FF...  v_char:             BLOCK   13, 0FFh
220   D3C3
221   D3C3                  ; Проверка - DOS.SYS не должен вылезать за эти пределы
222   D3C3                  IF NEW_MEMORY_MAP==0
223   D3C3 ~                    ASSERT_DONT_FIT 0D000h  ; с этого адреса начинается NC.COM
224   D3C3                  ENDIF
225   D3C3
226   D3C3                  IF LOAD_FONT
227   D3C3              	    INCLUDE "initFont.inc"
  1+  D3C3              ;+---------------------------------------------------------------------------
  2+  D3C3              ; MXOS
  3+  D3C3              ; Загрузка шрифта в память
  4+  D3C3              ;
  5+  D3C3              ; Разработано vinxru
  6+  D3C3              ; Доработано SpaceEngineer
  7+  D3C3              ;----------------------------------------------------------------------------
  8+  D3C3
  9+  D3C3              initFont:   ; Изменяем команду перехода сюда на reboot2
 10+  D3C3 21 56 C5                 ld      hl, reboot2
 11+  D3C6 22 54 C5                 ld      (onceInitFont+1), hl
 12+  D3C9 E5                       push    hl
 13+  D3CA
 14+  D3CA                  IF EMBED_FONT == 0
 15+  D3CA
 16+  D3CA                          ; Шрифт грузится из файла
 17+  D3CA                          ; Устанавливаем блочный драйвер ДОЗУ
 18+  D3CA 06 00                    ld      b, 0
 19+  D3CC CD 8E CA                 call    setRAMDDriver
 20+  D3CF
 21+  D3CF                          ; Ищем и загружаем файл A:FONT.FNT на адрес FONT_ADDR
 22+  D3CF 21 E8 D2                 ld      hl, pathFontFnt
 23+  D3D2 11 76 D3                 ld      de, v_curFileDescr
 24+  D3D5 CD 4F D1                 call    fileNamePrepare   ; подготовка имени файла и переключение накопителя
 25+  D3D8 EB                       ex      de, hl
 26+  D3D9 11 00 E0                 ld      de, FONT_ADDR
 27+  D3DC C3 B2 CF                 jp      fileLoad2
 28+  D3DF
 29+  D3DF                  ELSE
 30+  D3DF ~                        ; Шрифт встроен в хвост программы
 31+  D3DF ~                        ; Копируем его на адрес FONT_ADDR
 32+  D3DF ~                        ld      hl, font
 33+  D3DF ~                        ld      de, fontEnd
 34+  D3DF ~                        ld      bc, FONT_ADDR
 35+  D3DF ~                        jp      memcpy_bc_hl
 36+  D3DF ~
 37+  D3DF ~            font:
 38+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 0
 39+  D3DF ~                  DB 004h,00Eh,015h,004h,015h,00Eh,004h,000h ; 1
 40+  D3DF ~                  DB 000h,000h,004h,00Ah,01Fh,000h,01Fh,000h ; 2
 41+  D3DF ~                  DB 000h,000h,01Fh,00Ah,004h,000h,01Fh,000h ; 3
 42+  D3DF ~                  DB 009h,01Bh,02Dh,01Bh,009h,000h,000h,000h ; 4
 43+  D3DF ~                  DB 024h,036h,02Dh,036h,024h,000h,000h,000h ; 5
 44+  D3DF ~                  DB 01Eh,021h,02Dh,029h,02Dh,021h,01Eh,000h ; 6
 45+  D3DF ~                  DB 010h,018h,017h,015h,017h,018h,010h,000h ; 7
 46+  D3DF ~                  DB 000h,000h,004h,008h,01Fh,008h,004h,000h ; 8
 47+  D3DF ~                  DB 000h,000h,014h,012h,01Fh,012h,014h,000h ; 9
 48+  D3DF ~                  DB 013h,012h,013h,01Ah,000h,01Fh,000h,000h ; 10
 49+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 11
 50+  D3DF ~                  DB 01Ch,018h,014h,002h,001h,001h,001h,000h ; 12
 51+  D3DF ~                  DB 01Fh,001h,001h,005h,009h,01Fh,008h,004h ; 13
 52+  D3DF ~                  DB 003h,004h,004h,01Ch,03Ch,018h,000h,000h ; 14
 53+  D3DF ~                  DB 003h,009h,005h,03Fh,005h,009h,003h,000h ; 15
 54+  D3DF ~                  DB 003h,009h,011h,03Fh,011h,009h,003h,000h ; 16
 55+  D3DF ~                  DB 004h,00Ah,011h,00Ah,004h,000h,000h,000h ; 17
 56+  D3DF ~                  DB 011h,011h,011h,011h,011h,000h,011h,000h ; 18
 57+  D3DF ~                  DB 000h,000h,000h,000h,000h,011h,011h,000h ; 19
 58+  D3DF ~                  DB 000h,008h,000h,008h,000h,008h,000h,000h ; 20
 59+  D3DF ~                  DB 004h,004h,000h,01Fh,000h,004h,004h,000h ; 21
 60+  D3DF ~                  DB 00Fh,008h,008h,008h,008h,028h,010h,000h ; 22
 61+  D3DF ~                  DB 03Fh,000h,000h,000h,000h,000h,000h,000h ; 23
 62+  D3DF ~                  DB 000h,000h,004h,002h,01Fh,002h,004h,000h ; 24
 63+  D3DF ~                  DB 004h,00Eh,015h,004h,004h,004h,004h,000h ; 25
 64+  D3DF ~                  DB 004h,004h,004h,004h,015h,00Eh,004h,000h ; 26
 65+  D3DF ~                  DB 01Bh,012h,01Ah,012h,01Bh,000h,01Fh,000h ; 27
 66+  D3DF ~                  DB 03Fh,001h,000h,000h,000h,000h,000h,000h ; 28
 67+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 29
 68+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 30
 69+  D3DF ~                  DB 01Fh,011h,019h,015h,013h,011h,01Fh,000h ; 31
 70+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 32
 71+  D3DF ~                  DB 004h,004h,004h,004h,004h,000h,004h,000h ; 33
 72+  D3DF ~                  DB 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
 73+  D3DF ~                  DB 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
 74+  D3DF ~                  DB 004h,00Fh,014h,00Eh,005h,01Eh,004h,000h ; 36
 75+  D3DF ~                  DB 010h,011h,002h,004h,008h,011h,001h,000h ; 37
 76+  D3DF ~                  DB 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
 77+  D3DF ~                  DB 000h,002h,002h,004h,000h,000h,000h,000h ; 39
 78+  D3DF ~                  DB 002h,004h,008h,008h,008h,004h,002h,000h ; 40
 79+  D3DF ~                  DB 008h,004h,002h,002h,002h,004h,008h,000h ; 41
 80+  D3DF ~                  DB 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
 81+  D3DF ~                  DB 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
 82+  D3DF ~                  DB 000h,000h,000h,000h,000h,004h,004h,008h ; 44
 83+  D3DF ~                  DB 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
 84+  D3DF ~                  DB 000h,000h,000h,000h,000h,004h,004h,000h ; 46
 85+  D3DF ~                  DB 000h,001h,002h,004h,008h,010h,000h,000h ; 47
 86+  D3DF ~                  DB 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
 87+  D3DF ~                  DB 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
 88+  D3DF ~                  DB 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
 89+  D3DF ~                  DB 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
 90+  D3DF ~                  DB 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
 91+  D3DF ~                  DB 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
 92+  D3DF ~                  DB 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
 93+  D3DF ~                  DB 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
 94+  D3DF ~                  DB 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
 95+  D3DF ~                  DB 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
 96+  D3DF ~                  DB 000h,004h,004h,000h,000h,004h,004h,000h ; 58
 97+  D3DF ~                  DB 000h,004h,004h,000h,000h,004h,004h,008h ; 59
 98+  D3DF ~                  DB 002h,004h,008h,010h,008h,004h,002h,000h ; 60
 99+  D3DF ~                  DB 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
100+  D3DF ~                  DB 008h,004h,002h,001h,002h,004h,008h,000h ; 62
101+  D3DF ~                  DB 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
102+  D3DF ~                  DB 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
103+  D3DF ~                  DB 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
104+  D3DF ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
105+  D3DF ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
106+  D3DF ~                  DB 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
107+  D3DF ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
108+  D3DF ~                  DB 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
109+  D3DF ~                  DB 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
110+  D3DF ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
111+  D3DF ~                  DB 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
112+  D3DF ~                  DB 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
113+  D3DF ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 75
114+  D3DF ~                  DB 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
115+  D3DF ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
116+  D3DF ~                  DB 011h,011h,019h,015h,013h,011h,011h,000h ; 78
117+  D3DF ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
118+  D3DF ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
119+  D3DF ~                  DB 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
120+  D3DF ~                  DB 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
121+  D3DF ~                  DB 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
122+  D3DF ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
123+  D3DF ~                  DB 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
124+  D3DF ~                  DB 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
125+  D3DF ~                  DB 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
126+  D3DF ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
127+  D3DF ~                  DB 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
128+  D3DF ~                  DB 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
129+  D3DF ~                  DB 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
130+  D3DF ~                  DB 000h,010h,008h,004h,002h,001h,000h,000h ; 92
131+  D3DF ~                  DB 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
132+  D3DF ~                  DB 004h,00Ah,011h,000h,000h,000h,000h,000h ; 94
133+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 95
134+  D3DF ~                  DB 000h,00Fh,000h,006h,009h,009h,006h,000h ; 96
135+  D3DF ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 97
136+  D3DF ~                  DB 008h,008h,008h,00Eh,009h,009h,016h,000h ; 98
137+  D3DF ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 99
138+  D3DF ~                  DB 002h,002h,002h,00Eh,012h,012h,00Dh,000h ; 100
139+  D3DF ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 101
140+  D3DF ~                  DB 006h,009h,008h,01Ch,008h,008h,008h,000h ; 102
141+  D3DF ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,01Ch ; 103
142+  D3DF ~                  DB 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
143+  D3DF ~                  DB 000h,010h,000h,010h,010h,011h,00Eh,000h ; 105
144+  D3DF ~                  DB 000h,001h,000h,001h,001h,001h,011h,00Eh ; 106
145+  D3DF ~                  DB 010h,010h,011h,012h,01Ch,012h,011h,000h ; 107
146+  D3DF ~                  DB 010h,010h,010h,010h,010h,011h,00Eh,000h ; 108
147+  D3DF ~                  DB 000h,000h,01Ah,015h,015h,015h,015h,000h ; 109
148+  D3DF ~                  DB 000h,000h,016h,019h,011h,011h,011h,000h ; 110
149+  D3DF ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
150+  D3DF ~                  DB 000h,000h,016h,009h,009h,00Eh,008h,008h ; 112
151+  D3DF ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,002h ; 113
152+  D3DF ~                  DB 000h,000h,016h,009h,008h,008h,008h,000h ; 114
153+  D3DF ~                  DB 000h,000h,00Eh,010h,00Eh,001h,00Eh,000h ; 115
154+  D3DF ~                  DB 008h,008h,01Ch,008h,008h,009h,006h,000h ; 116
155+  D3DF ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 117
156+  D3DF ~                  DB 000h,000h,011h,011h,011h,00Ah,004h,000h ; 118
157+  D3DF ~                  DB 000h,000h,015h,015h,015h,015h,00Ah,000h ; 119
158+  D3DF ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
159+  D3DF ~                  DB 000h,000h,011h,011h,011h,00Fh,001h,00Eh ; 121
160+  D3DF ~                  DB 000h,000h,01Fh,001h,00Eh,010h,01Fh,000h ; 122
161+  D3DF ~                  DB 003h,004h,004h,018h,004h,004h,003h,000h ; 123
162+  D3DF ~                  DB 01Fh,011h,011h,011h,011h,011h,01Fh,000h ; 124
163+  D3DF ~                  DB 018h,004h,004h,003h,004h,004h,018h,000h ; 125
164+  D3DF ~                  DB 000h,000h,008h,015h,002h,000h,000h,000h ; 126
165+  D3DF ~                  DB 001h,003h,007h,00Fh,007h,003h,001h,000h ; 127
166+  D3DF ~                  DB 000h,000h,00Ah,01Fh,01Fh,00Eh,004h,000h ; 128
167+  D3DF ~                  DB 000h,004h,004h,01Fh,004h,004h,01Bh,000h ; 129
168+  D3DF ~                  DB 004h,00Eh,01Fh,01Fh,00Ah,004h,01Bh,000h ; 130
169+  D3DF ~                  DB 000h,000h,004h,00Eh,01Fh,00Eh,004h,000h ; 131
170+  D3DF ~                  DB 002h,004h,00Ah,015h,011h,011h,00Eh,000h ; 132
171+  D3DF ~                  DB 00Eh,004h,01Fh,015h,004h,00Ah,011h,000h ; 133
172+  D3DF ~                  DB 003h,004h,006h,009h,006h,002h,00Ch,000h ; 134
173+  D3DF ~                  DB 007h,003h,005h,00Ch,012h,012h,00Ch,000h ; 135
174+  D3DF ~                  DB 00Eh,011h,011h,00Eh,004h,00Eh,004h,000h ; 136
175+  D3DF ~                  DB 000h,017h,014h,01Fh,005h,01Dh,000h,000h ; 137
176+  D3DF ~                  DB 004h,004h,01Fh,004h,014h,00Ch,006h,005h ; 138
177+  D3DF ~                  DB 004h,01Fh,004h,00Ah,011h,01Fh,004h,000h ; 139
178+  D3DF ~                  DB 004h,01Fh,005h,00Ah,011h,01Fh,004h,000h ; 140
179+  D3DF ~                  DB 004h,004h,01Fh,000h,01Fh,004h,004h,000h ; 141
180+  D3DF ~                  DB 004h,00Eh,00Ah,00Ah,00Ah,00Eh,004h,000h ; 142
181+  D3DF ~                  DB 004h,006h,001h,006h,001h,006h,004h,000h ; 143
182+  D3DF ~                  DB 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 144
183+  D3DF ~                  DB 030h,030h,030h,030h,030h,030h,030h,030h ; 145
184+  D3DF ~                  DB 003h,003h,003h,003h,003h,003h,003h,003h ; 146
185+  D3DF ~                  DB 030h,030h,030h,03Fh,03Fh,030h,030h,030h ; 147
186+  D3DF ~                  DB 003h,003h,003h,03Fh,03Fh,003h,003h,003h ; 148
187+  D3DF ~                  DB 000h,000h,000h,03Fh,03Fh,030h,030h,030h ; 149
188+  D3DF ~                  DB 000h,000h,000h,03Fh,03Fh,003h,003h,003h ; 150
189+  D3DF ~                  DB 003h,003h,003h,03Fh,03Fh,000h,000h,000h ; 151
190+  D3DF ~                  DB 030h,030h,030h,03Fh,03Fh,000h,000h,000h ; 152
191+  D3DF ~                  DB 000h,000h,000h,03Fh,03Fh,018h,018h,018h ; 153
192+  D3DF ~                  DB 018h,018h,018h,018h,018h,018h,018h,018h ; 154
193+  D3DF ~                  DB 018h,018h,018h,03Fh,03Fh,000h,000h,000h ; 155
194+  D3DF ~                  DB 018h,018h,018h,03Fh,03Fh,018h,018h,018h ; 156
195+  D3DF ~                  DB 000h,000h,001h,002h,014h,008h,000h,000h ; 157
196+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 158
197+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 159
198+  D3DF ~                  DB 002h,002h,00Ah,016h,012h,012h,00Dh,000h ; 160
199+  D3DF ~                  DB 006h,009h,00Eh,009h,00Eh,008h,010h,000h ; 161
200+  D3DF ~                  DB 01Fh,011h,011h,010h,010h,010h,010h,000h ; 162
201+  D3DF ~                  DB 00Fh,010h,012h,00Ah,00Ah,00Ah,011h,000h ; 163
202+  D3DF ~                  DB 01Fh,008h,004h,002h,004h,008h,01Fh,000h ; 164
203+  D3DF ~                  DB 005h,00Ah,010h,01Eh,011h,011h,00Eh,000h ; 165
204+  D3DF ~                  DB 009h,009h,009h,009h,00Fh,009h,010h,000h ; 166
205+  D3DF ~                  DB 008h,014h,004h,002h,006h,009h,011h,000h ; 167
206+  D3DF ~                  DB 015h,015h,015h,00Eh,004h,004h,004h,000h ; 168
207+  D3DF ~                  DB 00Eh,011h,01Bh,01Fh,01Bh,011h,00Eh,000h ; 169
208+  D3DF ~                  DB 00Eh,011h,011h,00Eh,004h,015h,01Bh,000h ; 170
209+  D3DF ~                  DB 006h,009h,009h,006h,000h,000h,000h,000h ; 171
210+  D3DF ~                  DB 00Eh,013h,015h,019h,00Eh,000h,000h,000h ; 172
211+  D3DF ~                  DB 002h,006h,002h,002h,007h,000h,000h,000h ; 173
212+  D3DF ~                  DB 006h,009h,002h,004h,00Fh,000h,000h,000h ; 174
213+  D3DF ~                  DB 00Fh,001h,002h,009h,006h,000h,000h,000h ; 175
214+  D3DF ~                  DB 00Ah,00Ah,00Fh,002h,002h,000h,000h,000h ; 176
215+  D3DF ~                  DB 00Eh,008h,00Eh,001h,00Eh,000h,000h,000h ; 177
216+  D3DF ~                  DB 006h,008h,00Eh,009h,006h,000h,000h,000h ; 178
217+  D3DF ~                  DB 00Fh,001h,002h,004h,004h,000h,000h,000h ; 179
218+  D3DF ~                  DB 006h,009h,006h,009h,006h,000h,000h,000h ; 180
219+  D3DF ~                  DB 006h,009h,007h,001h,006h,000h,000h,000h ; 181
220+  D3DF ~                  DB 000h,000h,00Eh,013h,015h,019h,00Eh,000h ; 182
221+  D3DF ~                  DB 000h,000h,002h,006h,002h,002h,007h,000h ; 183
222+  D3DF ~                  DB 000h,000h,006h,009h,002h,004h,00Fh,000h ; 184
223+  D3DF ~                  DB 000h,000h,00Fh,001h,002h,009h,006h,000h ; 185
224+  D3DF ~                  DB 000h,000h,00Ah,00Ah,00Fh,002h,002h,000h ; 186
225+  D3DF ~                  DB 000h,000h,00Eh,008h,00Eh,001h,00Eh,000h ; 187
226+  D3DF ~                  DB 000h,000h,006h,008h,00Eh,009h,006h,000h ; 188
227+  D3DF ~                  DB 000h,000h,00Fh,001h,002h,004h,004h,000h ; 189
228+  D3DF ~                  DB 000h,000h,006h,009h,006h,009h,006h,000h ; 190
229+  D3DF ~                  DB 000h,000h,006h,009h,007h,001h,006h,000h ; 191
230+  D3DF ~                  DB 000h,000h,012h,015h,01Dh,015h,012h,000h ; 192
231+  D3DF ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 193
232+  D3DF ~                  DB 001h,00Eh,010h,01Eh,011h,011h,00Eh,000h ; 194
233+  D3DF ~                  DB 000h,000h,012h,012h,012h,012h,00Fh,001h ; 195
234+  D3DF ~                  DB 00Eh,001h,001h,00Fh,011h,011h,00Eh,000h ; 196
235+  D3DF ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 197
236+  D3DF ~                  DB 000h,000h,00Eh,015h,015h,00Eh,004h,004h ; 198
237+  D3DF ~                  DB 000h,000h,00Ch,012h,004h,009h,006h,000h ; 199
238+  D3DF ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 200
239+  D3DF ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 201
240+  D3DF ~                  DB 00Ch,000h,012h,012h,012h,012h,00Dh,000h ; 202
241+  D3DF ~                  DB 000h,000h,011h,012h,01Ch,012h,011h,000h ; 203
242+  D3DF ~                  DB 000h,000h,007h,009h,009h,009h,011h,000h ; 204
243+  D3DF ~                  DB 000h,000h,011h,01Bh,015h,011h,011h,000h ; 205
244+  D3DF ~                  DB 000h,000h,011h,011h,01Fh,011h,011h,000h ; 206
245+  D3DF ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 207
246+  D3DF ~                  DB 000h,000h,01Fh,011h,011h,011h,011h,000h ; 208
247+  D3DF ~                  DB 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 209
248+  D3DF ~                  DB 000h,000h,01Eh,011h,011h,01Eh,010h,000h ; 210
249+  D3DF ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 211
250+  D3DF ~                  DB 000h,000h,01Fh,004h,004h,004h,004h,000h ; 212
251+  D3DF ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,00Eh ; 213
252+  D3DF ~                  DB 000h,000h,015h,015h,00Eh,015h,015h,000h ; 214
253+  D3DF ~                  DB 00Ch,014h,018h,01Eh,011h,011h,00Eh,000h ; 215
254+  D3DF ~                  DB 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 216
255+  D3DF ~                  DB 000h,000h,011h,011h,01Dh,013h,01Dh,000h ; 217
256+  D3DF ~                  DB 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 218
257+  D3DF ~                  DB 000h,000h,011h,015h,015h,015h,01Fh,000h ; 219
258+  D3DF ~                  DB 000h,000h,01Eh,001h,007h,001h,01Eh,000h ; 220
259+  D3DF ~                  DB 000h,000h,015h,015h,015h,015h,01Fh,001h ; 221
260+  D3DF ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,000h ; 222
261+  D3DF ~                  DB 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 223
262+  D3DF ~                  DB 012h,015h,015h,01Dh,015h,015h,012h,000h ; 224
263+  D3DF ~                  DB 00Eh,011h,011h,011h,01Fh,011h,011h,000h ; 225
264+  D3DF ~                  DB 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 226
265+  D3DF ~                  DB 012h,012h,012h,012h,012h,012h,01Fh,001h ; 227
266+  D3DF ~                  DB 006h,00Ah,00Ah,00Ah,00Ah,01Fh,011h,000h ; 228
267+  D3DF ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 229
268+  D3DF ~                  DB 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 230
269+  D3DF ~                  DB 01Fh,011h,010h,010h,010h,010h,010h,000h ; 231
270+  D3DF ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 232
271+  D3DF ~                  DB 011h,011h,013h,015h,019h,011h,011h,000h ; 233
272+  D3DF ~                  DB 015h,011h,013h,015h,019h,011h,011h,000h ; 234
273+  D3DF ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 235
274+  D3DF ~                  DB 007h,009h,009h,009h,009h,009h,019h,000h ; 236
275+  D3DF ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 237
276+  D3DF ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 238
277+  D3DF ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 239
278+  D3DF ~                  DB 01Fh,011h,011h,011h,011h,011h,011h,000h ; 240
279+  D3DF ~                  DB 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 241
280+  D3DF ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 242
281+  D3DF ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 243
282+  D3DF ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 244
283+  D3DF ~                  DB 011h,011h,011h,00Ah,004h,008h,010h,000h ; 245
284+  D3DF ~                  DB 011h,015h,015h,00Eh,015h,015h,011h,000h ; 246
285+  D3DF ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 247
286+  D3DF ~                  DB 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 248
287+  D3DF ~                  DB 011h,011h,011h,019h,015h,015h,019h,000h ; 249
288+  D3DF ~                  DB 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 250
289+  D3DF ~                  DB 011h,015h,015h,015h,015h,015h,01Fh,000h ; 251
290+  D3DF ~                  DB 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 252
291+  D3DF ~                  DB 015h,015h,015h,015h,015h,015h,01Fh,001h ; 253
292+  D3DF ~                  DB 011h,011h,011h,00Fh,001h,001h,001h,000h ; 254
293+  D3DF ~                  DB 000h,000h,000h,000h,000h,000h,000h,01Fh ; 255
294+  D3DF ~            fontEnd:
295+  D3DF ~
296+  D3DF                  ENDIF
297+  D3DF
228   D3DF                  ENDIF
229   D3DF
230   D3DF                  END
