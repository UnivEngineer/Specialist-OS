  1   0000              ;----------------------------------------------------------------------------
  2   0000              ; MXOS - BIOS и DOS
  3   0000              ;
  4   0000              ; 2013-12-12 Дизассемблировано и доработано vinxru
  5   0000              ; 2022-01-31 Доработано SpaceEngineer
  6   0000              ;----------------------------------------------------------------------------
  7   0000
  8   0000                  INCLUDE "../include/mxos.inc"
  1+  0000              ;-----------------------------------------------------------------------
  2+  0000              ; MXOS
  3+  0000              ; Точки входа и настройки сборки MXOS
  4+  0000              ;
  5+  0000              ; Карта памяти:
  6+  0000              ;   8FDF-8FFF - [  32  B] Переменные
  7+  0000              ;   9000-BFFF - [12   KB] Экран
  8+  0000              ;   C000-CFFF - [4    KB] DOS.SYS (в конце чуть чуть свободного места под доработки)
  9+  0000              ;   D000-E1FF - [4.5  KB] NC.COM (в конце место под список файлов и чуть чуть свободного места под доработки)
 10+  0000              ;   E200-E5FF - [1.0  KB] (свободно 1024 байт)
 11+  0000              ;   E600-E7FF - [0.5  KB] Драйвер магнитофона
 12+  0000              ;   E900-F0FF - [2    KB] Шрифт (можно отключить запуском ROMFNT.COM или опцией LOAD_FONT=0)
 13+  0000              ;   F100-F8FF - [2.0  KB] FORMAT.COM, FPAGE.COM, MON2.COM и прочие утилиты
 14+  0000              ;   F900-F9FF - [ 256  B] (Свободно 256 байт)
 15+  0000              ;   FA00-FAFF - [ 256  B] Драйвер флеш-диска
 16+  0000              ;   FB00-FDFF - [ 768  B] Дисковый буфер
 17+  0000              ;   FF00-FF81 - [ 129  B] Командная строка. Заполняется функцией bios_fileExec
 18+  0000              ;   FF82-FFBF - [ 130  B] Стек
 19+  0000              ;   FFC0-FFEF - [  32  B] Непереключаемое ОЗУ, драйвера обмена с RAM диском
 20+  0000              ;   FFE0-FFFF - [  32  B] Оборудование
 21+  0000              ;-----------------------------------------------------------------------
 22+  0000
 23+  0000
 24+  0000              ;-----------------------------------------------------------------------
 25+  0000              ; Конфигурация сборки
 26+  0000              ;-----------------------------------------------------------------------
 27+  0000
 28+  0000              RAMD_MAX_PAGE        =  0Fh     ; Максимальное количество страниц RAM диска (до 0Fh)
 29+  0000              RAMD_PAGE_END        =  0FFBBh  ; Включить поддержку ДОЗУ большего чем 64 Кб
 30+  0000              ROM_64K              =  1       ; Включить поддержку ПЗУ 64 Кб Специалиста МХ2
 31+  0000              ENABLE_COLOR         =  1       ; Включить поддержку цвета
 32+  0000              LOAD_FONT            =  1       ; Загружать шрифт в ОЗУ
 33+  0000              FONT_ADDR            =  0E900h  ; Адрес шрфита
 34+  0000              COLOR_BIOS           =  0F0h    ; Цвет командной строки
 35+  0000              RAMFOS_COMPATIBILITY =  1       ; Совместимость с RAMFOS (WIP)
 36+  0000              BOOT_FROM_TAPE       =  0       ; Включить загрузку с ленты при нажатой клавише после сброса
 37+  0000              FAT16                =  1       ; Включить поддержку FAT16
 38+  0000
 39+  0000                  IF  LOAD_FONT
 40+  0000              FONT_ADDR_DIV_8 = FONT_ADDR/8
 41+  0000                  ELSE
 42+  0000 ~            FONT_ADDR_DIV_8 = -1
 43+  0000                  ENDIF
 44+  0000
 45+  0000              ;-----------------------------------------------------------------------
 46+  0000              ; Переменные ОС в подэкранном пространстве и их начальные значения
 47+  0000              ; Доступ к переменным и программ польователя:
 48+  0000              ; ld a, bios_vars.lastKey
 49+  0000              ;-----------------------------------------------------------------------
 50+  0000
 51+  0000                  STRUCT BIOS_VARIABLES
 52+  0000 ~            _reserv_1     DW      -1
 53+  0000 ~            tapeError     DW      0C800h          ; Адрес, куда происходит переход при ошибке чтения с ленты
 54+  0000 ~            tapeAddr      DW      -1              ; Адрес программы загруженной с ленты
 55+  0000 ~            _reserv_2     DW      -1
 56+  0000 ~            charGen       DW      FONT_ADDR_DIV_8 ; Адрес альтернативного знакогенератора /8
 57+  0000 ~            cursorCfg     DB      0A9h            ; Внешний вид курсора (7 - бит видимость, 654 - положение, 3210 - высота)
 58+  0000 ~            koi8          DB      -1              ; 0FFh = включен KOI-8, 0 = включен KOI-7
 59+  0000 ~            escMode       DB      -1              ; Обработка ESC-последовательности
 60+  0000 ~            keyLocks      DB      3Ah
 61+  0000 ~            _reserv_3     DW      -1
 62+  0000 ~            lastLastKey   DB      -1
 63+  0000 ~            lastKey       DB      -1
 64+  0000 ~            beepDuration  DB      5Fh             ; Длительность звукового сигнала
 65+  0000 ~            beepFreq      DB      20h             ; Частота звукового сигнала
 66+  0000 ~            tapeInverse   DB      0FFh
 67+  0000 ~            cursorDelay   DB      020h
 68+  0000 ~            byte_8FF5     DB      0E0h
 69+  0000 ~            oldSP         DW      -1              ; Используется для сохранения SP некоторыми функциями
 70+  0000 ~            maxRamPage    DB      RAMD_MAX_PAGE   ; Максимальный детектированный номер страницы RAM-диска
 71+  0000 ~            flashPage     DB      0               ; Текущий номер страницы флеш-диска
 72+  0000 ~            inverse       DW      0               ; Инвертирование текста (0=нормальный текст, 0FFFFh=инверсный)
 73+  0000 ~            cursorY       DB      -1              ; Положение курсора по вертикали в пикселях
 74+  0000 ~            cursorX       DB      -1              ; Положение курсора по горизонтали в пикселях / 2
 75+  0000 ~            writeDelay    DB      28h             ; Скорость при записи на ленту
 76+  0000 ~            readDelay     DB      3Ch             ; Скорость при чтении с ленты
 77+  0000                  ENDS
 78+  0000
 79+  0000              ; Адрес структуры BIOS_VARIABLES
 80+  0000
 81+  0000              	ORG 08FDFh
 82+  8FDF
 83+  8FDF              bios_vars   BIOS_VARIABLES = $
 84+  8FDF
 85+  8FDF              ;-----------------------------------------------------------------------
 86+  8FDF              ; Буферы в памяти
 87+  8FDF              ;-----------------------------------------------------------------------
 88+  8FDF
 89+  8FDF              fat              = 0FB00h
 90+  8FDF              diskDirectory    = 0FC00h
 91+  8FDF              diskDirectoryEnd = 0FE00h
 92+  8FDF              v_cmdLine        = 0FF00h
 93+  8FDF              STACK_ADDR       = 0FFC0h
 94+  8FDF
 95+  8FDF              ;-----------------------------------------------------------------------
 96+  8FDF              ; Стандартные точки входа ОС
 97+  8FDF              ; Отмеченные * применять не рекомендуется
 98+  8FDF              ;-----------------------------------------------------------------------
 99+  8FDF
100+  8FDF              bios_init            = 0C000h ; Теплая перезагрузка
101+  8FDF
102+  8FDF              ; Устаревшие точки, лечше не применять
103+  8FDF              bios_keyScanOld      = 0C003h ; * Получить код нажатой клавиши, = bios_keyScan
104+  8FDF              bios_drawCursorOld   = 0C006h ; * Нарисовать/стереть курсор
105+  8FDF              bios_clearScreenOld  = 0C010h ; * Оистка экрана
106+  8FDF              bios_printCharOld    = 0C037h ; * Вывод символа на экран
107+  8FDF              bios_beep_Old        = 0C170h ; * Звуковой сигнал
108+  8FDF              bios_delay_l         = 0C18Fh ; * Задержка
109+  8FDF              bios_getchOld        = 0C337h ; * Ожидание ввода с клавиатуры
110+  8FDF              bios_tapeReadOld     = 0C377h ; * Чтение байта с магнитофона
111+  8FDF              bios_tapeWriteOld    = 0C3D0h ; * Запись байта на магнитофон
112+  8FDF              bios_cmp_hl_de       = 0C427h ; * Сравнить hl и de
113+  8FDF              bios_memcpy_bc_hl    = 0C42Dh ; * Скопировать блок памяти
114+  8FDF              bios_printStringOld  = 0C438h ; * Вывод строки на экран
115+  8FDF
116+  8FDF              bios_reboot          = 0C800h ; Запустить NC.COM
117+  8FDF              bios_getch           = 0C803h ; Ожидание ввода с клавиатуры
118+  8FDF              bios_tapeRead        = 0C806h ; Чтение байта с магнитофона
119+  8FDF              bios_printChar       = 0C809h ; Вывод символа на экран
120+  8FDF              bios_tapeWrite       = 0C80Ch ; Запись байта на магнитофон
121+  8FDF              bios_input           = 0C80Fh ; Ввод строки с клавиатуры
122+  8FDF              bios_keyCheck        = 0C812h ; Получить код нажатой клавиши, = bios_keyScan
123+  8FDF              bios_printHexByte    = 0C815h ; Вывод HEX числа на экран (байт)
124+  8FDF              bios_printString     = 0C818h ; Вывод строки на экран
125+  8FDF              bios_keyScan         = 0C81Bh ; Получить код нажатой клавиши
126+  8FDF              bios_getCursorPos    = 0C81Eh ; Получить координаты курсора в hl (координаты в пикселях)
127+  8FDF              bios_setCursorPos    = 0C821h ; Установить координаты курсора из hl (координаты в пикселях)
128+  8FDF              bios_tapeLoad        = 0C824h ; Загрузить программу с магнитофона
129+  8FDF              bios_tapeSave        = 0C827h ; Сохранить программу на магнитофон
130+  8FDF              bios_calcCS          = 0C82Ah ; Расчет контрольной суммы
131+  8FDF              bios_printHexWord    = 0C82Dh ; Вывод HEX числа на экран (слово)
132+  8FDF              bios_getMemTop       = 0C830h ; Получить объем доступной памяти
133+  8FDF              bios_setMemTop       = 0C833h ; Установить объем доступной памяти
134+  8FDF              bios_printer         = 0C836h ; Напечатать байт на принтере
135+  8FDF                  IF RAMFOS_COMPATIBILITY
136+  8FDF              bios_strToHex        = 0C839h ; Преобразвоние строки в HEX формате в число
137+  8FDF                  ELSE
138+  8FDF ~            bios_rebootAlt       = 0C839h ; Запустить NC.COM
139+  8FDF                  ENDIF
140+  8FDF              bios_rebootAlt2      = 0C83Ch ; Запустить NC.COM
141+  8FDF              bios_fileList        = 0C83Fh ; Получить список файлов
142+  8FDF              bios_fileGetSetDrive = 0C842h ; Получить/установить активное устройство
143+  8FDF              bios_fileCreate      = 0C845h ; Создать файл
144+  8FDF              bios_fileLoad        = 0C848h ; Загрузить файл по адресу из заголовка этого файла
145+  8FDF              bios_fileDelete      = 0C84Bh ; Удалить файл
146+  8FDF              bios_fileRename      = 0C84Eh ; Переименовать файл
147+  8FDF              bios_fileLoadInfo    = 0C851h ; Загрузить информацию о файле
148+  8FDF              bios_fileGetSetAddr  = 0C854h ; Получить/установить адрес загрузки файла
149+  8FDF              bios_fileGetSetAttr  = 0C857h ; Получить/установить атрибуты файла
150+  8FDF              bios_fileNamePrepare = 0C85Ah ; Преобразовать имя файла во внутренний формат
151+  8FDF              bios_fileExec        = 0C85Dh ; Запустить файл
152+  8FDF              bios_installDriver   = 0C860h ; Установить драйвер накопителя
153+  8FDF              bios_diskDriver      = 0C863h ; Драйвер выбранного диска
154+  8FDF              bios_fileLoad2       = 0C866h ; Загрузить файл по адресу de
155+  8FDF              bios_printCharReal   = 0C869h ; Вывод символа на экран (только реальные символы)
156+  8FDF              bios_printDecWord    = 0C86Ch ; Вывод числа экран в десятичной форме
157+  8FDF              bios_setRAMDDriver   = 0C86Fh ; Установить драйвр рам-диска
158+  8FDF
159+  8FDF              ;-----------------------------------------------------------------------
160+  8FDF              ; Точки входа драйвера доступа к ДОЗУ
161+  8FDF              ;-----------------------------------------------------------------------
162+  8FDF
163+  8FDF              bios_RAMDRead  = 0FFC0h ; чтение из ДОЗУ
164+  8FDF              bios_RAMDWrite = 0FFD0h ; запись в  ДОЗУ
165+  8FDF
166+  8FDF              ;-----------------------------------------------------------------------
167+  8FDF              ; Адрес таблицы переходов драйвера магнитофона
168+  8FDF              ;-----------------------------------------------------------------------
169+  8FDF
170+  8FDF              TAPE_DRIVER_JUMPS = bios_tapeReadOld    ; размещается на месте бывшей п/п чтения байта
171+  8FDF
172+  8FDF              ;-----------------------------------------------------------------------
173+  8FDF              ; Порты устройств ПК "Специалист-MX2"
174+  8FDF              ;-----------------------------------------------------------------------
175+  8FDF
176+  8FDF              IO_KEYB_A       =  0FFE0h   ; ВВ55 клавиатуры
177+  8FDF              IO_KEYB_B       =  0FFE1h
178+  8FDF              IO_KEYB_C       =  0FFE2h
179+  8FDF              IO_KEYB_MODE    =  0FFE3h
180+  8FDF              IO_PROG_A       =  0FFE4h   ; ВВ55 программатора/флеш диска
181+  8FDF              IO_PROG_B       =  0FFE5h
182+  8FDF              IO_PROG_C       =  0FFE6h
183+  8FDF              IO_PROG_MODE    =  0FFE7h
184+  8FDF              IO_FDD_CMD      =  0FFE8h   ; контроллер дисковода ВГ93
185+  8FDF              IO_FDD_TRACK    =  0FFE9h
186+  8FDF              IO_FDD_SECTOR   =  0FFEAh
187+  8FDF              IO_FDD_DATA     =  0FFEBh
188+  8FDF              IO_TIMER_CH0    =  0FFECh   ; таймер ВИ53
189+  8FDF              IO_TIMER_CH1    =  0FFEDh
190+  8FDF              IO_TIMER_CH2    =  0FFEEh
191+  8FDF              IO_TIMER_MODE   =  0FFEFh
192+  8FDF              IO_FDD_REQ      =  0FFF0h   ; контроллер дисковода
193+  8FDF              IO_FDD_MOTOR    =  0FFF1h
194+  8FDF              IO_FDD_SIDE     =  0FFF2h
195+  8FDF              IO_FDD_DRIVE    =  0FFF3h
196+  8FDF              IO_COLOR        =  0FFF8h   ; регистр цвета
197+  8FDF              IO_PAGE_RAM     =  0FFFCh   ; порт включения основного ОЗУ
198+  8FDF              IO_PAGE_RAMD    =  0FFFDh   ; порт включения ОЗУ RAM-дисков
199+  8FDF              IO_PAGE_ROM     =  0FFFEh   ; порт включения ПЗУ
200+  8FDF              IO_PAGE_STD     =  0FFFFh   ; порт включения STD режима
201+  8FDF
202+  8FDF              ;-----------------------------------------------------------------------
203+  8FDF              ; Структура файловой системы
204+  8FDF              ;-----------------------------------------------------------------------
205+  8FDF
206+  8FDF              ; Структура каталога
207+  8FDF
208+  8FDF                  IF FAT16
209+  8FDF
210+  8FDF              DIR_DESCR_SIZE  = 32    ; Размер дескриптора файла в каталоге
211+  8FDF              DIR_MAX_FILES   = 24    ; Максимум файлов в каталоге
212+  8FDF              DIR_NAME_LENGTH = 8     ; Длина имени файла
213+  8FDF
214+  8FDF              ;-----------------------------------------------------------------------
215+  8FDF              ; Десткриптор файла (одна запись в каталоге) FAT12/16/32
216+  8FDF              ;-----------------------------------------------------------------------
217+  8FDF
218+  8FDF                  STRUCT FILE_DESCRIPTOR  ; 32 байта
219+  8FDF ~            name            BLOCK   DIR_NAME_LENGTH     ; смещение 00h, 8 байт  - имя файла
220+  8FDF ~            ext             BLOCK   3                   ; смещение 08h, 3 байта - расширение имени файла
221+  8FDF ~            attrib          BLOCK   1                   ; смещение 0Bh, 1 байт  - атрибуты файла
222+  8FDF ~            checkSum        BLOCK   1  ; ntRes          ; смещение 0Ch, 1 байт  - контрольная сумма (!!! временный костыль, в FAT32 это ntRes - используются в Windows NT !!!)
223+  8FDF ~            ctrTimeTenth    BLOCK   1                   ; смещение 0Dh, 1 байт  - (только FAT32) время создания файла, десятки миллисекунд (0-199)
224+  8FDF ~            ctrTime         BLOCK   2                   ; смещение 0Eh, 2 байта - (только FAT32) время создания файла, секунды*2 (0-43200)
225+  8FDF ~            ctrDate         BLOCK   2                   ; смещение 10h, 2 байта - (только FAT32) дата  создания файла
226+  8FDF ~            loadAddress     BLOCK   2  ; accDate        ; смещение 12h, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый (!!! временный костыль, в FAT32 это accDate - дата доступа к файлу !!!)
227+  8FDF ~            firstClusterHi  BLOCK   2                   ; смещение 14h, 2 байта - номер первого кластера в FAT, старшее слово
228+  8FDF ~            wrtTime         BLOCK   2                   ; смещение 16h, 2 байта - время модификации файла, секунды*2 (0-43200)
229+  8FDF ~            wrtDate         BLOCK   2                   ; смещение 18h, 2 байта - дата  модификации файла
230+  8FDF ~            firstCluster    BLOCK   2                   ; смещение 1Ah, 2 байта - номер первого кластера в FAT, младшее слово
231+  8FDF ~            size            BLOCK   4                   ; смещение 1Ch, 4 байта - размер файла в байтах
232+  8FDF                  ENDS
233+  8FDF
234+  8FDF              ;-----------------------------------------------------------------------
235+  8FDF              ; Десткриптор файла (одна запись в каталоге) FAT12/16/32
236+  8FDF              ;-----------------------------------------------------------------------
237+  8FDF
238+  8FDF                  ELSE
239+  8FDF ~
240+  8FDF ~            DIR_DESCR_SIZE  = 16    ; Размер дескриптора файла в каталоге
241+  8FDF ~            DIR_MAX_FILES   = 48    ; Максимум файлов в каталоге
242+  8FDF ~            DIR_NAME_LENGTH = 6     ; Длина имени файла
243+  8FDF ~
244+  8FDF ~            ;-----------------------------------------------------------------------
245+  8FDF ~            ; Десткриптор файла (одна запись в каталоге) MXOS FAT8
246+  8FDF ~            ;-----------------------------------------------------------------------
247+  8FDF ~
248+  8FDF ~                STRUCT FILE_DESCRIPTOR  ; 16 байт
249+  8FDF ~            name            BLOCK   DIR_NAME_LENGTH     ; смещение 00h, 6 байт  - имя файла
250+  8FDF ~            ext             BLOCK   3                   ; смещение 06h, 3 байта - расширение имени файла
251+  8FDF ~            attrib          BLOCK   1                   ; смещение 09h, 1 байт  - атрибуты файла: 00h - обычный файл, 01h - системный файл
252+  8FDF ~            loadAddress     BLOCK   2                   ; смещение 0Ah, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый
253+  8FDF ~            size            BLOCK   2                   ; смещение 0Ch, 2 байта - размер файла в байтах - 1
254+  8FDF ~            checkSum        BLOCK   1                   ; смещение 0Eh, 1 байт  - контрольная сумма
255+  8FDF ~            firstCluster    BLOCK   1                   ; смещение 0Fh, 1 байт  - номер первого кластера в FAT
256+  8FDF ~                ENDS
257+  8FDF ~
258+  8FDF ~            ;-----------------------------------------------------------------------
259+  8FDF ~            ; Десткриптор файла (одна запись в каталоге) MXOS FAT8
260+  8FDF ~            ;-----------------------------------------------------------------------
261+  8FDF ~
262+  8FDF                  ENDIF
263+  8FDF
264+  8FDF              ;-----------------------------------------------------------------------
265+  8FDF              ; Всякие полезности
266+  8FDF              ;-----------------------------------------------------------------------
267+  8FDF
268+  8FDF              ; Макрос для заполнения памяти от текущего адреса до указанного
269+  8FDF                  MACRO ORG_PAD adr
270+  8FDF ~                     ; add padding + display warning
271+  8FDF ~                     IF $ > adr
272+  8FDF ~                       ; no padding
273+  8FDF ~                       ASSERT 0
274+  8FDF ~                       DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
275+  8FDF ~                     ELSE
276+  8FDF ~                       ; add padding
277+  8FDF ~                       BLOCK adr-$
278+  8FDF ~                     ENDIF
279+  8FDF ~                     ORG adr
280+  8FDF                  ENDM
281+  8FDF
282+  8FDF              ; Макросы для проверки текущего адреса
283+  8FDF                  MACRO ASSERT_EQUAL adr
284+  8FDF ~                     IF $ != adr
285+  8FDF ~                       ASSERT 0
286+  8FDF ~                       DISPLAY /l, "Error! Entry point has been shifted (", $, " != ", adr, ")"
287+  8FDF ~                     ENDIF
288+  8FDF                  ENDM
289+  8FDF
290+  8FDF                  MACRO ASSERT_DONT_FIT adr
291+  8FDF ~                     IF $ > adr
292+  8FDF ~                       ASSERT 0
293+  8FDF ~                       DISPLAY /l, "Error! Image did not fit (", $, " > ", adr, ")"
294+  8FDF ~                     ENDIF
295+  8FDF                  ENDM
296+  8FDF
297+  8FDF              ;-----------------------------------------------------------------------
298+  8FDF              ; Конец
299+  8FDF              ;-----------------------------------------------------------------------
300+  8FDF
  9   8FDF
 10   8FDF              ; -----------------------------------------------------------------------
 11   8FDF              ; Код
 12   8FDF              ; Стандартные подпрограммы должны иметь фиксированный адрес для
 13   8FDF              ; совместимости. Они начинаются с ORG_PAD xxxx. В случае, если
 14   8FDF              ; предыдущая продпрограмма залезает на эту, транслятор выдаст ошибку.
 15   8FDF              ; -----------------------------------------------------------------------
 16   8FDF
 17   8FDF              	ORG     0C000h
 18   C000              	INCLUDE "jmps_c000.inc"
  1+  C000              ;+---------------------------------------------------------------------------
  2+  C000              ; MXOS
  3+  C000              ; Стандартные точки входа C000
  4+  C000              ;
  5+  C000              ; 2013-12-12 Дизассемблировано vinxru
  6+  C000              ;----------------------------------------------------------------------------
  7+  C000
  8+  C000 C3 09 C0                 jp    reboot        ; C000: Теплая перезагрузка
  9+  C003 C3 C7 C1     j_keyScan:  jp    keyScan2      ; C003: Получить код нажатой клавиши
 10+  C006 C3 4E C3                 jp    drawCursor3   ; C006: Нарисовать/стереть курсор
 11+  C009 31 C0 FF     reboot:     ld    sp, STACK_ADDR; C009: Теплая перезагрузка
 12+  C00C C3 5B C4                 jp    reboot1
 13+  C00F
 19   C00F
 20   C00F                  ORG_PAD 0C010h
 20   C00F             >         ; add padding + display warning
 20   C00F             >         IF $ > 0C010h
 20   C00F ~           >           ; no padding
 20   C00F ~           >           ASSERT 0
 20   C00F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 20   C00F             >         ELSE
 20   C00F             >           ; add padding
 20   C00F 00          >           BLOCK 0C010h-$
 20   C010             >         ENDIF
 20   C010             >         ORG 0C010h
 21   C010              	INCLUDE "clearScreen.inc"
  1+  C010              ;+---------------------------------------------------------------------------
  2+  C010              ; MXOS
  3+  C010              ; Очистить экран
  4+  C010              ;
  5+  C010              ; На выходе
  6+  C010              ;  bc, de, hl - сохраняются
  7+  C010              ;
  8+  C010              ; 2013-12-12 Дизассемблировано vinxru
  9+  C010              ;----------------------------------------------------------------------------
 10+  C010
 11+  C010              clearScreen:
 12+  C010                          ; bc, hl - сохраняем. de - не используется
 13+  C010 E5                       push  hl
 14+  C011 C5                       push  bc
 15+  C012
 16+  C012                          ; Сохранение sp
 17+  C012 21 00 00                 ld    hl, 0
 18+  C015 39                       add   hl,sp
 19+  C016 22 F6 8F                 ld    (bios_vars.oldSP), hl
 20+  C019
 21+  C019                          ; Устанавливаем sp в конец видеопамяти
 22+  C019 31 00 C0                 ld    sp, 0C000h
 23+  C01C
 24+  C01C                          ; Байт (слово) для заполнения памяти
 25+  C01C 2A FA 8F                 ld    hl, (bios_vars.inverse)
 26+  C01F
 27+  C01F                          ; Помещаем в стек 3000h байт
 28+  C01F 01 00 03                 ld    bc, 3000h / 16
 29+  C022              clearScreen_0:
 30+  C022 E5                       push      hl
 31+  C023 E5                       push      hl
 32+  C024 E5                       push      hl
 33+  C025 E5                       push      hl
 34+  C026 E5                       push      hl
 35+  C027 E5                       push      hl
 36+  C028 E5                       push      hl
 37+  C029 E5                       push      hl
 38+  C02A 0B                       dec bc
 39+  C02B 78                       ld  a, b
 40+  C02C B1                       or  c
 41+  C02D C2 22 C0                 jp nz,  clearScreen_0
 42+  C030
 43+  C030                          ; Восстанавливаем sp
 44+  C030 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 45+  C033 F9                       ld    sp, hl
 46+  C034
 47+  C034                          ; bc, hl были сохранены. de - не используется
 48+  C034 C1                       pop   bc
 49+  C035 E1                       pop   hl
 50+  C036 C9                       ret
 51+  C037
 22   C037
 23   C037                  ORG_PAD 0C037h
 23   C037             >         ; add padding + display warning
 23   C037             >         IF $ > 0C037h
 23   C037 ~           >           ; no padding
 23   C037 ~           >           ASSERT 0
 23   C037 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 23   C037             >         ELSE
 23   C037             >           ; add padding
 23   C037             >           BLOCK 0C037h-$
 23   C037             >         ENDIF
 23   C037             >         ORG 0C037h
 24   C037              	INCLUDE "printChar.inc"
  1+  C037              ;+---------------------------------------------------------------------------
  2+  C037              ; MXOS
  3+  C037              ; Вывод символа на экран (или принтер)
  4+  C037              ;
  5+  C037              ; На входе
  6+  C037              ;  с - символ
  7+  C037              ;
  8+  C037              ; На выходе
  9+  C037              ;  Все регистры сохраняются
 10+  C037              ;
 11+  C037              ; 2013-12-12 Дизассемблировано vinxru
 12+  C037              ;----------------------------------------------------------------------------
 13+  C037
 14+  C037 F5           printChar:  push  af
 15+  C038 D5                       push  de
 16+  C039 C5                       push  bc
 17+  C03A E5                       push  hl
 18+  C03B CD C7 C5                 call  printChar2
 19+  C03E E1                       pop   hl
 20+  C03F C1                       pop   bc
 21+  C040 D1                       pop   de
 22+  C041 F1                       pop   af
 23+  C042 C9                       ret
 24+  C043
 25   C043
 26   C043                  ORG_PAD 0C045h
 26   C043             >         ; add padding + display warning
 26   C043             >         IF $ > 0C045h
 26   C043 ~           >           ; no padding
 26   C043 ~           >           ASSERT 0
 26   C043 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 26   C043             >         ELSE
 26   C043             >           ; add padding
 26   C043 00 00       >           BLOCK 0C045h-$
 26   C045             >         ENDIF
 26   C045             >         ORG 0C045h
 27   C045              	INCLUDE "printChar5.inc" ; Продолжается в drawChar
  1+  C045              ;+---------------------------------------------------------------------------
  2+  C045              ; MXOS
  3+  C045              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C045              ; Расчет адреса символа в знакогенераторе и адреса вывода на экран
  5+  C045              ;
  6+  C045              ; 2013-12-12 Дизассемблировано vinxru
  7+  C045              ;----------------------------------------------------------------------------
  8+  C045
  9+  C045              ; ---------------------------------------------------------------------------
 10+  C045              ; Обработка ESC+(. Выключение KOI-7
 11+  C045
 12+  C045 3E FF        printChar_e28:    ld    a, 0FFh
 13+  C047 32 EA 8F                 ld    (bios_vars.koi8), a
 14+  C04A C9                       ret
 15+  C04B
 16+  C04B              ; ---------------------------------------------------------------------------
 17+  C04B              ; Обработка ESC+). Включение KOI-7
 18+  C04B
 19+  C04B AF           printChar_e29:    xor   a
 20+  C04C 32 EA 8F                 ld    (bios_vars.koi8), a
 21+  C04F C9                       ret
 22+  C050
 23+  C050              ; ---------------------------------------------------------------------------
 24+  C050              ; Обработка кода 9. Табуляция
 25+  C050
 26+  C050 3A FD 8F     printChar_c9:     ld    a, (bios_vars.cursorX)
 27+  C053 C6 18                    add   a,24
 28+  C055 32 FD 8F                 ld    (bios_vars.cursorX),a
 29+  C058 C9                       ret
 30+  C059
 31+  C059              ; ---------------------------------------------------------------------------
 32+  C059              ; Вывод символа С из знакогенартора по адресу hl*8 на экран в положение
 33+  C059              ; курсора. Курсор при этом перемещается
 34+  C059
 35+  C059              printChar_alt:    ; de = (hl+c)*8
 36+  C059 06 00                    ld    b, 0
 37+  C05B 09                       add   hl, bc
 38+  C05C 29                       add   hl, hl
 39+  C05D 29                       add   hl, hl
 40+  C05E 29                       add   hl, hl
 41+  C05F EB                       ex    de, hl
 42+  C060
 43+  C060                          ; Продолжение в printChar_de
 44+  C060
 45+  C060              ; ---------------------------------------------------------------------------
 46+  C060              ; Вывод символа de на экран в положение курсора. Курсор при этом перемещается
 47+  C060              ; вправо.
 48+  C060
 49+  C060              printChar_de:     ; Рассчитываем адрес вывода (hl=v_cursorPos, a*256+l=адрес)
 50+  C060 CD 29 C3                 call  calcCursorAddr
 51+  C063
 52+  C063                          ; Перемещаем курсор вправо
 53+  C063 24                       inc   h
 54+  C064 24                       inc   h
 55+  C065 24                       inc   h
 56+  C066 22 FC 8F                 ld    (bios_vars.cursorY), hl
 57+  C069
 58+  C069                          ; Корректируем адрес вывода (bc = al - 7)
 59+  C069 47                       ld    b, a
 60+  C06A 7D                       ld    a, l
 61+  C06B D6 07                    sub   7
 62+  C06D 4F                       ld    c, a
 63+  C06E
 64+  C06E                          ; Продолжение в drawChar
 65+  C06E
 28   C06E              	INCLUDE "drawChar.inc"
  1+  C06E              ;+---------------------------------------------------------------------------
  2+  C06E              ; MXOS
  3+  C06E              ; Рисование символа на экране
  4+  C06E              ;
  5+  C06E              ; На входе
  6+  C06E              ;  bc - адрес символа
  7+  C06E              ;  de - адрес в видеопамяти
  8+  C06E              ;  h  - координата X в пикселях / 2
  9+  C06E              ;
 10+  C06E              ; 2013-12-12 Дизассемблировано vinxru
 11+  C06E              ;----------------------------------------------------------------------------
 12+  C06E
 13+  C06E                          ; Высота символа
 14+  C06E 2E 08                    ld    l, 8
 15+  C070
 16+  C070                          ; Переходим в одной из функций вывода
 17+  C070 7C                       ld    a, h
 18+  C071 E6 03                    and   3
 19+  C073 CA B5 C0                 jp z, drawChar0   ; a==0
 20+  C076 3D                       dec   a
 21+  C077 CA C5 C0                 jp z, drawChar1   ; a==1
 22+  C07A 3D                       dec   a
 23+  C07B CA 82 C0                 jp z, drawChar2   ; a==2
 24+  C07E 3D                       dec   a
 25+  C07F CA A3 C0                 jp z, drawChar3   ; a==3
 26+  C082                          ; Продолжение на drawChar2
 27+  C082
 28+  C082              ; ---------------------------------------------------------------------------
 29+  C082
 30+  C082 0A           drawChar2:  ld    a, (bc)
 31+  C083 E6 FC                    and   0FCh
 32+  C085 67                       ld    h, a
 33+  C086 1A                       ld    a, (de)
 34+  C087 0F                       rrca
 35+  C088 0F                       rrca
 36+  C089 0F                       rrca
 37+  C08A 0F                       rrca
 38+  C08B 2F           drawChar2_cma:    CPL
 39+  C08C F5                       push  af
 40+  C08D E6 03                    and   3
 41+  C08F AC                       xor   h
 42+  C090 02                       ld    (bc),a
 43+  C091 04                       inc   b
 44+  C092 0A                       ld    a, (bc)
 45+  C093 E6 0F                    and   0Fh
 46+  C095 67                       ld    h, a
 47+  C096 F1                       pop   af
 48+  C097 E6 F0                    and   0F0h
 49+  C099 AC                       xor   h
 50+  C09A 02                       ld    (bc),a
 51+  C09B 05                       dec   b
 52+  C09C
 53+  C09C                          ; Цикл
 54+  C09C 03                       inc   bc
 55+  C09D 13                       inc   de
 56+  C09E 2D                       dec   l
 57+  C09F C2 82 C0                 jp nz,  drawChar2
 58+  C0A2 C9                       ret
 59+  C0A3
 60+  C0A3              ; ---------------------------------------------------------------------------
 61+  C0A3
 62+  C0A3 0A           drawChar3:  ld    a, (bc)
 63+  C0A4 E6 03                    and   3
 64+  C0A6 67                       ld    h, a
 65+  C0A7 1A                       ld    a, (de)
 66+  C0A8 07                       rlca
 67+  C0A9 07                       rlca
 68+  C0AA EE FC        drawChar3_xri:    xor   0FCh
 69+  C0AC AC                       xor   h
 70+  C0AD 02                       ld    (bc),a
 71+  C0AE
 72+  C0AE                          ; Цикл
 73+  C0AE 13                       inc   de
 74+  C0AF 03                       inc   bc
 75+  C0B0 2D                       dec   l
 76+  C0B1 C2 A3 C0                 jp nz,  drawChar3
 77+  C0B4 C9                       ret
 78+  C0B5
 79+  C0B5              ; ---------------------------------------------------------------------------
 80+  C0B5
 81+  C0B5 0A           drawChar0:  ld    a, (bc)
 82+  C0B6 E6 C0                    and   0C0h
 83+  C0B8 67                       ld    h, a
 84+  C0B9 1A                       ld    a, (de)
 85+  C0BA EE 3F        drawChar0_xri:    xor   3Fh
 86+  C0BC AC                       xor   h
 87+  C0BD 02                       ld    (bc),a
 88+  C0BE
 89+  C0BE                          ; Цикл
 90+  C0BE 13                       inc   de
 91+  C0BF 03                       inc   bc
 92+  C0C0 2D                       dec   l
 93+  C0C1 C2 B5 C0                 jp nz,  drawChar0
 94+  C0C4 C9                       ret
 95+  C0C5
 96+  C0C5              ; ---------------------------------------------------------------------------
 97+  C0C5
 98+  C0C5 0A           drawChar1:  ld    a, (bc)
 99+  C0C6 E6 F0                    and   0F0h
100+  C0C8 67                       ld    h, a
101+  C0C9 1A                       ld    a, (de)
102+  C0CA 0F                       rrca
103+  C0CB 0F                       rrca
104+  C0CC 2F           drawChar1_cma:    CPL
105+  C0CD E6 0F                    and   0Fh
106+  C0CF AC                       xor   h
107+  C0D0 02                       ld    (bc),a
108+  C0D1 04                       inc   b
109+  C0D2 0A                       ld    a, (bc)
110+  C0D3 E6 3F                    and   3Fh
111+  C0D5 67                       ld    h, a
112+  C0D6 1A                       ld    a, (de)
113+  C0D7 0F                       rrca
114+  C0D8 0F                       rrca
115+  C0D9 2F           drawChar1_cma2:   CPL
116+  C0DA E6 C0                    and   0C0h
117+  C0DC AC                       xor   h
118+  C0DD 02                       ld    (bc),a
119+  C0DE 05                       dec   b
120+  C0DF
121+  C0DF                          ; Цикл
122+  C0DF 03                       inc   bc
123+  C0E0 13                       inc   de
124+  C0E1 2D                       dec   l
125+  C0E2 C2 C5 C0                 jp nz,  drawChar1
126+  C0E5 C9                       ret
127+  C0E6
128+  C0E6              ; ---------------------------------------------------------------------------
129+  C0E6              ; Вызывается из printChar_real2
130+  C0E6
131+  C0E6              normalVideo:      ; Меняем CZ normalVideo на CNZ inverseVideo
132+  C0E6 21 02 C1                 ld    hl, inverseVideo
133+  C0E9 22 04 C6                 ld    (printChar_poly+1), hl
134+  C0EC 3E C4                    ld    a, 0C4h
135+  C0EE 32 03 C6                 ld    (printChar_poly),a
136+  C0F1
137+  C0F1                          ; Аргумент XRI
138+  C0F1 AF                       xor   a
139+  C0F2 32 BB C0                 ld    (drawChar0_xri+1),a
140+  C0F5 32 AB C0                 ld    (drawChar3_xri+1),a
141+  C0F8              normalVideo_1:    ; Меняем CMA на NOP
142+  C0F8 32 8B C0                 ld    (drawChar2_cma),a
143+  C0FB 32 CC C0                 ld    (drawChar1_cma),a
144+  C0FE 32 D9 C0                 ld    (drawChar1_cma2),a
145+  C101 C9                       ret
146+  C102
147+  C102              ; ---------------------------------------------------------------------------
148+  C102              ; Вызывается из printChar_real2
149+  C102
150+  C102              inverseVideo:     ; Меняем CNZ inverseVideo на CZ normalVideo
151+  C102 21 E6 C0                 ld    hl, normalVideo
152+  C105 22 04 C6                 ld    (printChar_poly+1), hl
153+  C108 3E CC                    ld    a, 0CCh
154+  C10A 32 03 C6                 ld    (printChar_poly),a
155+  C10D
156+  C10D                          ; Меняем аргумент XRI
157+  C10D 3E FC                    ld    a, 0FCh
158+  C10F 32 AB C0                 ld    (drawChar3_xri+1),a
159+  C112 3E 3F                    ld    a, 3Fh
160+  C114 32 BB C0                 ld    (drawChar0_xri+1),a
161+  C117
162+  C117                          ; Меняем NOP на CMA
163+  C117 3E 2F                    ld    a, 2Fh
164+  C119 C3 F8 C0                 jp    normalVideo_1
165+  C11C
 29   C11C              	INCLUDE "printChar3.inc"
  1+  C11C              ;+---------------------------------------------------------------------------
  2+  C11C              ; MXOS
  3+  C11C              ; Обработка служебных кодов при выводе символа
  4+  C11C              ;
  5+  C11C              ; На входе
  6+  C11C              ;  a - символ
  7+  C11C              ;
  8+  C11C              ; 2013-12-12 Дизассемблировано vinxru
  9+  C11C              ;----------------------------------------------------------------------------
 10+  C11C
 11+  C11C              printChar3: ; Код 7
 12+  C11C D6 07                    sub   7
 13+  C11E CA 70 C1                 jp z, beep
 14+  C121                          ; Код 8
 15+  C121 3D                       dec   a
 16+  C122 CA 4E C1                 jp z, printChar_c08
 17+  C125                          ; Код 10
 18+  C125 D6 02                    sub   2
 19+  C127 CA 96 C1                 jp z, printChar_c0A
 20+  C12A                          ; Код 12
 21+  C12A D6 02                    sub   2
 22+  C12C CA 46 C1                 jp z, printChar_c0C
 23+  C12F                          ; Код 13
 24+  C12F 3D                       dec   a
 25+  C130 CA 48 C1                 jp z, printChar_c0D
 26+  C133                          ; Код 24
 27+  C133 D6 0B                    sub   11
 28+  C135 CA 64 C1                 jp z, printChar_c18
 29+  C138                          ; Код 25
 30+  C138 3D                       dec   a
 31+  C139 CA 59 C1                 jp z, printChar_c19
 32+  C13C                          ; Код 26
 33+  C13C 3D                       dec   a
 34+  C13D CA 98 C1                 jp z, printChar_c1A
 35+  C140                          ; Продолжение, если код 31
 36+  C140 D6 05                    sub   5
 37+  C142 C0                       ret NZ
 38+  C143                          ; Код 31 очищает экран
 39+  C143 CD 10 C0                 call  clearScreen
 40+  C146
 41+  C146                          ; Продолжение в printChar_c0C
 42+  C146
 43+  C146              ; ---------------------------------------------------------------------------
 44+  C146              ; Обработка кода 0Ch. Курсор в левый верхний угол экрана
 45+  C146
 46+  C146              printChar_c0C:    ; bios_vars.cursorY = 8
 47+  C146 2E 08                    ld    l, 8
 48+  C148
 49+  C148                          ; Продолжение в printChar_c0D
 50+  C148
 51+  C148              ; ---------------------------------------------------------------------------
 52+  C148              ; Обработка кода 0Dh. Курсор в начало строки
 53+  C148
 54+  C148              printChar_c0D:    ; bios_vars.cursorX = 0
 55+  C148 AF                       xor   a
 56+  C149 67           saveVCursorHA:    ld    h, a
 57+  C14A 22 FC 8F     saveVCursor:      ld    (bios_vars.cursorY), hl
 58+  C14D C9                       ret
 59+  C14E
 60+  C14E              ; ---------------------------------------------------------------------------
 61+  C14E              ; Обработка кода 8h. Влево
 62+  C14E
 63+  C14E              printChar_c08:    ; cursorX -= 3
 64+  C14E 7C                       ld    a, h
 65+  C14F D6 03                    sub   3
 66+  C151
 67+  C151                          ; Если нет переноса, сохранить положение курсора и выйти
 68+  C151 D2 49 C1                 jp nc,  saveVCursorHA
 69+  C154
 70+  C154                          ; cursorX = 189
 71+  C154 26 BD                    ld    h, 189
 72+  C156 22 FC 8F                 ld    (bios_vars.cursorY), hl
 73+  C159
 74+  C159                          ; Продолжение в printChar_c19
 75+  C159
 76+  C159              ; ---------------------------------------------------------------------------
 77+  C159              ; Обработка кода 19h. Вверх
 78+  C159
 79+  C159              printChar_c19:    ; Если cursorY < 18, то выйти. Иначе cursorY -= 10
 80+  C159 7D                       ld    a, l
 81+  C15A D6 0A                    sub   0Ah
 82+  C15C D8                       ret c
 83+  C15D FE 08                    cp    8
 84+  C15F D8                       ret c
 85+  C160
 86+  C160              saveVCursorLA:    ; Сохранить положение курсора и выйти
 87+  C160 6F                       ld    l, a
 88+  C161 C3 4A C1                 jp    saveVCursor
 89+  C164
 90+  C164              ; ---------------------------------------------------------------------------
 91+  C164              ; Обработка кода 18h. Вправо
 92+  C164
 93+  C164              printChar_c18:    ; Если cursorX+3 >= 192, то перейти на printChar_c0A
 94+  C164                          ; Иначе cursorX += 3
 95+  C164 7C                       ld    a, h
 96+  C165 C6 03                    add   a,3
 97+  C167 FE C0                    cp    0C0h
 98+  C169 DA 49 C1                 jp c, saveVCursorHA
 99+  C16C C3 96 C1                 jp    printChar_c0A
100+  C16F
 30   C16F
 31   C16F                  ORG_PAD 0C170h
 31   C16F             >         ; add padding + display warning
 31   C16F             >         IF $ > 0C170h
 31   C16F ~           >           ; no padding
 31   C16F ~           >           ASSERT 0
 31   C16F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 31   C16F             >         ELSE
 31   C16F             >           ; add padding
 31   C16F 00          >           BLOCK 0C170h-$
 31   C170             >         ENDIF
 31   C170             >         ORG 0C170h
 32   C170              	INCLUDE "beep.inc"
  1+  C170              ;+---------------------------------------------------------------------------
  2+  C170              ; MXOS
  3+  C170              ; Звуковой сигнал (вызывается при выводе кода 7)
  4+  C170              ;
  5+  C170              ; Все регистры сохраняются
  6+  C170              ;
  7+  C170              ; 2013-12-12 Дизассемблировано vinxru
  8+  C170              ;----------------------------------------------------------------------------
  9+  C170
 10+  C170              beep:       ; Сохраняем все регистры. de не используется ниже
 11+  C170 F5                       push  af
 12+  C171 C5                       push  bc
 13+  C172 E5                       push  hl
 14+  C173
 15+  C173                          ; Частота и длительность сигнала
 16+  C173 2A F1 8F                 ld    hl, (bios_vars.beepDuration)
 17+  C176
 18+  C176              beep_0:     ; Единицу на динамик
 19+  C176 3E 0B                    ld    a, 0Bh
 20+  C178 32 E3 FF                 ld    (IO_KEYB_MODE),a
 21+  C17B
 22+  C17B                          ; Задержка l тактов
 23+  C17B CD 8F C1                 call  delay_l
 24+  C17E
 25+  C17E                          ; Ноль на динамик
 26+  C17E 3E 0A                    ld    a, 0Ah
 27+  C180 32 E3 FF                 ld    (IO_KEYB_MODE),a
 28+  C183
 29+  C183                          ; Задержка l тактов
 30+  C183 CD 8F C1                 call  delay_l
 31+  C186
 32+  C186                          ; Повторяем h раз
 33+  C186 25                       dec   h
 34+  C187 C2 76 C1                 jp nz,  beep_0
 35+  C18A
 36+  C18A                          ; Ничего не делаем
 37+  C18A 00                       nop
 38+  C18B
 39+  C18B                          ; Восстаналиваем все регистры и выходим. de не используется
 40+  C18B E1                       pop   hl
 41+  C18C C1                       pop   bc
 42+  C18D F1                       pop   af
 43+  C18E C9                       ret
 44+  C18F
 33   C18F
 34   C18F                  ORG_PAD 0C18Fh
 34   C18F             >         ; add padding + display warning
 34   C18F             >         IF $ > 0C18Fh
 34   C18F ~           >           ; no padding
 34   C18F ~           >           ASSERT 0
 34   C18F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 34   C18F             >         ELSE
 34   C18F             >           ; add padding
 34   C18F             >           BLOCK 0C18Fh-$
 34   C18F             >         ENDIF
 34   C18F             >         ORG 0C18Fh
 35   C18F              	INCLUDE "delay_l.inc"
  1+  C18F              ;+---------------------------------------------------------------------------
  2+  C18F              ; MXOS
  3+  C18F              ; Задержка
  4+  C18F              ;
  5+  C18F              ; На входе
  6+  C18F              ;  l - задержка
  7+  C18F              ;
  8+  C18F              ; На выходе
  9+  C18F              ;  b - 0
 10+  C18F              ;
 11+  C18F              ; 2013-12-12 Дизассемблировано vinxru
 12+  C18F              ;----------------------------------------------------------------------------
 13+  C18F
 14+  C18F 45           delay_l:    ld    b, l
 15+  C190 05           delay_l_0:  dec   b
 16+  C191 C2 90 C1                 jp nz,  delay_l_0
 17+  C194 C9                       ret
 18+  C195
 36   C195
 37   C195                  ORG_PAD 0C196h
 37   C195             >         ; add padding + display warning
 37   C195             >         IF $ > 0C196h
 37   C195 ~           >           ; no padding
 37   C195 ~           >           ASSERT 0
 37   C195 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 37   C195             >         ELSE
 37   C195             >           ; add padding
 37   C195 00          >           BLOCK 0C196h-$
 37   C196             >         ENDIF
 37   C196             >         ORG 0C196h
 38   C196              	INCLUDE "printChar4.inc" ; Продолжается в scrollUp
  1+  C196              ;+---------------------------------------------------------------------------
  2+  C196              ; MXOS
  3+  C196              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C196              ;
  5+  C196              ; 2013-12-12 Дизассемблировано vinxru
  6+  C196              ;----------------------------------------------------------------------------
  7+  C196
  8+  C196              ; ---------------------------------------------------------------------------
  9+  C196              ; Обработка кода 0Ah. Перевод строки
 10+  C196
 11+  C196              printChar_c0A:    ; cursorX = 0
 12+  C196 26 00                    ld    h, 0
 13+  C198
 14+  C198                          ; Продолжение в printChar_c1A
 15+  C198
 16+  C198              ; ---------------------------------------------------------------------------
 17+  C198              ; Обработка кода 1Ah. Вниз
 18+  C198
 19+  C198              printChar_c1A:    ; Если cursorY < 246, то cursorY += 10 и выход
 20+  C198 7D                       ld    a, l
 21+  C199 C6 0A                    add   a,10
 22+  C19B D2 60 C1                 jp nc,  saveVCursorLA
 23+  C19E
 24+  C19E                          ; Сохраняем положение курсора (изменен только cursorX)
 25+  C19E 22 FC 8F                 ld    (bios_vars.cursorY), hl
 26+  C1A1
 27+  C1A1                          ; Далее прокрутка экрана вверх
 28+  C1A1
 39   C1A1              	INCLUDE "scrollUp.inc"
  1+  C1A1              ;+---------------------------------------------------------------------------
  2+  C1A1              ; MXOS
  3+  C1A1              ; Прокрутка экрана вверх
  4+  C1A1              ;
  5+  C1A1              ; На выходе
  6+  C1A1              ;   af, bc - сохраняются
  7+  C1A1              ;
  8+  C1A1              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1A1              ;----------------------------------------------------------------------------
 10+  C1A1
 11+  C1A1                          ; Сохраняем регистры
 12+  C1A1 C5                       push  bc
 13+  C1A2 F5                       push  af
 14+  C1A3
 15+  C1A3                          ; Сохраняем sp
 16+  C1A3 21 00 00                 ld    hl, 0
 17+  C1A6 39                       add   hl,sp
 18+  C1A7 22 F6 8F                 ld    (bios_vars.oldSP), hl
 19+  C1AA
 20+  C1AA                          ; Прокрутка экрана вверх
 21+  C1AA 31 0A 90                 ld    sp, 900Ah   ; Откуда
 22+  C1AD 26 90                    ld    h, 90h      ; Куда
 23+  C1AF 06 30                    ld    b, 48       ; Столбцов
 24+  C1B1 C3 7C C7                 jp    scrollUp2
 25+  C1B4
 40   C1B4
 41   C1B4                  ; Буфер для копирования изображения символов при использовании шрифта в ПЗУ
 42   C1B4              v_char:
 43   C1B4 FF FF FF FF      DB 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh
 43   C1B8 FF FF FF FF
 43   C1BC FF FF FF FF
 43   C1C0 FF
 44   C1C1
 45   C1C1              	INCLUDE "keyScan.inc"
  1+  C1C1              ;+---------------------------------------------------------------------------
  2+  C1C1              ; MXOS
  3+  C1C1              ; Получить код нажатой клавиши
  4+  C1C1              ;
  5+  C1C1              ; На выходе
  6+  C1C1              ;  a - код
  7+  C1C1              ;
  8+  C1C1              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1C1              ;----------------------------------------------------------------------------
 10+  C1C1
 11+  C1C1 3E 83        setKeybMode83:    ld    a, 83h
 12+  C1C3 32 E3 FF                 ld    (IO_KEYB_MODE),a
 13+  C1C6 C9                       ret
 14+  C1C7
 15+  C1C7              ; ---------------------------------------------------------------------------
 16+  C1C7
 17+  C1C7              keyScan2:   ; Режим чтения ряда
 18+  C1C7 CD 54 C2                 call  setKeybMode82
 19+  C1CA
 20+  C1CA                          ; Одним чтением првоеряем все клавиши
 21+  C1CA 3A E1 FF                 ld    a, (IO_KEYB_B)
 22+  C1CD
 23+  C1CD                          ; Эти биты не используются в сканировании
 24+  C1CD F6 03                    or    3
 25+  C1CF
 26+  C1CF                          ; Ни одна клавиша не нажата
 27+  C1CF FE FF                    cp    0FFh
 28+  C1D1 C8                       ret Z
 29+  C1D2
 30+  C1D2                          ; Сохраняем регистры
 31+  C1D2 E5                       push  hl
 32+  C1D3 C5                       push  bc
 33+  C1D4 D5                       push  de
 34+  C1D5
 35+  C1D5                          ; Перебираем 12 столбцов кнопок
 36+  C1D5 21 FE 0F                 ld    hl, 0FFEh
 37+  C1D8 11 A8 C4                 ld    de, v_keybTbl + 11
 38+  C1DB 06 FF                    ld    b, 0FFh
 39+  C1DD 7C           loc_C1DD:   ld    a, h
 40+  C1DE 32 E2 FF                 ld    (IO_KEYB_C),a
 41+  C1E1 7D                       ld    a, l
 42+  C1E2 32 E0 FF                 ld    (IO_KEYB_A),a
 43+  C1E5 0F                       RRCA
 44+  C1E6 2F                       CPL
 45+  C1E7 E6 04                    and   4
 46+  C1E9 4F                       ld    c, a
 47+  C1EA 3A E1 FF                 ld    a, (IO_KEYB_B)
 48+  C1ED B1                       or    c
 49+  C1EE
 50+  C1EE                          ; Перебираем 6 кнопок в столбце
 51+  C1EE 0E 06                    ld    c, 6
 52+  C1F0 0F                       RRCA
 53+  C1F1 0F                       RRCA
 54+  C1F2 0F           loc_C1F2:   RRCA
 55+  C1F3 D4 0C C2                 call NC,    keybScan3
 56+  C1F6 0D                       dec   c
 57+  C1F7 C2 F2 C1                 jp nz,  loc_C1F2
 58+  C1FA
 59+  C1FA                          ; Цикл
 60+  C1FA 1B                       dec   de
 61+  C1FB 29                       add   hl, hl
 62+  C1FC 23                       inc   hl
 63+  C1FD 7C                       ld    a, h
 64+  C1FE C6 F0                    add   a,0F0h
 65+  C200 67                       ld    h, a
 66+  C201 DA DD C1                 jp c, loc_C1DD
 67+  C204
 68+  C204                          ; Режим ВВ55 по уполчанию
 69+  C204 CD 54 C2                 call  setKeybMode82
 70+  C207
 71+  C207                          ; Результат
 72+  C207 78                       ld    a, b
 73+  C208
 74+  C208                          ; Восстаналвиаем регистры
 75+  C208 D1                       pop   de
 76+  C209 C1                       pop   bc
 77+  C20A E1                       pop   hl
 78+  C20B C9                       ret
 79+  C20C
 80+  C20C              ;----------------------------------------------------------------------------
 81+  C20C
 82+  C20C D5           keybScan3:  push  de
 83+  C20D F5                       push  af
 84+  C20E 3E 06                    ld    a, 6        ; e += (6 - c) * 16
 85+  C210 91                       sub   c
 86+  C211 87                       add   a, a
 87+  C212 87                       add   a, a
 88+  C213 87                       add   a, a
 89+  C214 87                       add   a, a
 90+  C215 83                       add   a, e
 91+  C216 5F                       ld    e, a
 92+  C217 1A                       ld    a, (de)            ; b = *de;
 93+  C218 47                       ld    b, a
 94+  C219 F1                       pop   af
 95+  C21A D1                       pop   de
 96+  C21B C9                       ret
 97+  C21C
 46   C21C              	INCLUDE "getch2.inc"
  1+  C21C              ;----------------------------------------------------------------------------
  2+  C21C              ; MXOS
  3+  C21C              ; Ожидание ввода с клавиатуры
  4+  C21C              ;
  5+  C21C              ; На выходе
  6+  C21C              ;  ? - код
  7+  C21C              ;
  8+  C21C              ; 2013-12-12 Дизассемблировано vinxru
  9+  C21C              ;----------------------------------------------------------------------------
 10+  C21C
 11+  C21C              getch2:           ; Сохраняем регистры
 12+  C21C E5                       push  hl
 13+  C21D C5                       push  bc
 14+  C21E D5                       push  de
 15+  C21F
 16+  C21F                          ; Получаем код нажатой клавиши и сохраняем его в bios_vars.lastKey
 17+  C21F CD C7 C1                 call  keyScan2
 18+  C222 32 F0 8F                 ld    (bios_vars.lastKey),a
 19+  C225
 20+  C225              getch_retry:      ; Тут будет признак, нарисован курсор или нет
 21+  C225 0E 01                    ld    c, 1
 22+  C227
 23+  C227              loc_C227:   ; Рисуем курсор
 24+  C227 CD 4D C3                 call  drawCursor2
 25+  C22A
 26+  C22A                          ; Задержка
 27+  C22A 3A F4 8F                 ld    a, (bios_vars.cursorDelay)
 28+  C22D 06 40        loc_C22D:   ld    b, 40h
 29+  C22F CD 90 C1                 call  delay_l_0
 30+  C232 3D                       dec   a
 31+  C233 C2 2D C2                 jp nz,  loc_C22D
 32+  C236
 33+  C236              loc_C236:   ; Рисуем/стираем курсор
 34+  C236 CD 48 C3                 call  drawCursor
 35+  C239
 36+  C239                          ; Задержка мерцания курсора
 37+  C239 11 00 05                 ld    de, 500h
 38+  C23C
 39+  C23C              loc_C23C:   ; Получаем код нажатой клавиши
 40+  C23C CD C7 C1                 call  keyScan2
 41+  C23F FE 80                    cp    80h         ; х.з.
 42+  C241 FE FF                    cp    0FFh
 43+  C243 C2 60 C2                 jp nz,  getch2_pressed
 44+  C246
 45+  C246                          ; Записываем bios_vars.lastKey=0FFh
 46+  C246 32 F0 8F                 ld    (bios_vars.lastKey),a
 47+  C249
 48+  C249                          ; Повторяем 500h раз
 49+  C249 1B                       dec   de
 50+  C24A 7A                       ld    a, d
 51+  C24B B3                       or    e
 52+  C24C C2 3C C2                 jp nz,  loc_C23C
 53+  C24F
 54+  C24F                          ; Повтор всего
 55+  C24F C3 36 C2                 jp    loc_C236
 56+  C252
 57+  C252              ; ---------------------------------------------------------------------------
 58+  C252
 59+  C252 FF FF            DB 0FFh, 0FFh
 60+  C254
 61+  C254              ; ---------------------------------------------------------------------------
 62+  C254
 63+  C254 3E 82        setKeybMode82:    ld    a, 82h
 64+  C256 32 E3 FF                 ld    (IO_KEYB_MODE),a
 65+  C259 C9                       ret
 66+  C25A
 67+  C25A              ; ---------------------------------------------------------------------------
 68+  C25A
 69+  C25A 3E 91        setKeybMode91:    ld    a, 91h
 70+  C25C 32 E3 FF                 ld    (IO_KEYB_MODE),a
 71+  C25F C9                       ret
 72+  C260
 73+  C260              ; ---------------------------------------------------------------------------
 74+  C260              ; Была нажата клавиша
 75+  C260
 76+  C260              getch2_pressed:   ; Сохраняем код
 77+  C260 47                       ld    b, a
 78+  C261
 79+  C261                          ; Если нарисован курсор, стираем его
 80+  C261 79                       ld    a, c
 81+  C262 0F                       RRCA
 82+  C263 DA 69 C2                 jp c, loc_C269
 83+  C266 CD 4D C3                 call  drawCursor2
 84+  C269              loc_C269:
 85+  C269 2A EF 8F                 ld    hl, (bios_vars.lastLastKey)   ; h = bios_vars.lastKey, l = bios_vars.lastLastKey
 86+  C26C 78                       ld    a, b        ; a = b = код нажатой клавиши
 87+  C26D BC                       cp    h
 88+  C26E C2 8D C2                 jp nz,  loc_C28D    ; Код нажатой клавиши изменился
 89+  C271 BD                       cp    l
 90+  C272 CA 95 C2                 jp z, loc_C295
 91+  C275
 92+  C275                          ; Рисуем курсор
 93+  C275 CD 48 C3                 call  drawCursor
 94+  C278
 95+  C278                          ; Ждем, пока отпустят клавишу
 96+  C278 3A F5 8F                 ld    a, (bios_vars.byte_8FF5)
 97+  C27B 57                       ld    d, a
 98+  C27C CD C7 C1     loc_C27C:   call  keyScan2
 99+  C27F BC                       cp    h
100+  C280 C2 27 C2                 jp nz,  loc_C227    ; Быстро нажали другую клавишу
101+  C283 15                       dec   d
102+  C284 C2 7C C2                 jp nz,  loc_C27C
103+  C287
104+  C287                          ; Долго держали
105+  C287
106+  C287                          ; Стираем курсор
107+  C287 CD 48 C3                 call  drawCursor
108+  C28A
109+  C28A C3 90 C2                 jp    loc_C290
110+  C28D              ; ---------------------------------------------------------------------------
111+  C28D
112+  C28D              loc_C28D:   ; Звуковой сигнал
113+  C28D CD 70 C1                 call  beep
114+  C290
115+  C290              loc_C290:   ;
116+  C290 6C                       ld    l, h
117+  C291 60                       ld    h, b  ; код нажатой и предыдущей клавиши сохраняем в bios_vars.lastKey
118+  C292 22 EF 8F                 ld    (bios_vars.lastLastKey), hl
119+  C295
120+  C295              loc_C295:   ; Не служеюбные клавиши CAPS LOCK, SHIFT и РУС/LAT не влияют
121+  C295 78                       ld    a, b
122+  C296 FE 21                    cp    21h
123+  C298 DA 10 C3                 jp c, getch_noShift
124+  C29B                              ; На клавиши c кодами 21h-3Fh влияет SHIFT
125+  C29B FE 40                    cp    40h
126+  C29D DA FE C2                 jp c, getch_shift
127+  C2A0                              ; На символьные клавиши (40h-7Eh) влияют CAPS LOCK, SHIFT и РУС/LAT
128+  C2A0 FE 7F                    cp    7Fh
129+  C2A2 DA DE C2                 jp c, getch_chars
130+  C2A5                              ; Не служеюбные клавиши (7Fh+) CAPS LOCK, SHIFT и РУС/LAT не влияют
131+  C2A5 CA 10 C3                 jp z, getch_noShift
132+  C2A8
133+  C2A8                          ; ...
134+  C2A8 00                       nop
135+  C2A9 00                       nop
136+  C2AA
137+  C2AA                              ; Переходим, если код клавиши не 81h
138+  C2AA FE 81                    cp    81h
139+  C2AC C2 10 C3                 jp nz,  getch_noShift
140+  C2AF
141+  C2AF                              ; Код клавиши 81h
142+  C2AF
143+  C2AF                          ; Если шифт не нажат
144+  C2AF 3A E1 FF                 ld    a, (IO_KEYB_B)
145+  C2B2 E6 02                    and   2
146+  C2B4 C2 6B C5                 jp nz,  loc_C55C
147+  C2B7
148+  C2B7                              ; Код клавиши 81h с шифтом
149+  C2B7
150+  C2B7                          ; Звуковой сигнал
151+  C2B7 CD 70 C1                 call  beep
152+  C2BA
153+  C2BA                          ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
154+  C2BA C3 AA C5                 jp    getch_rc
155+  C2BD
156+  C2BD              ; ---------------------------------------------------------------------------
157+  C2BD              ; Нажата комбинация РУС/LAT
158+  C2BD
159+  C2BD              getch_rusLat:     ; на входе a = bios_vars.keyLocks
160+  C2BD EE 81                    xor   81h
161+  C2BF 32 EC 8F                 ld    (bios_vars.keyLocks),a
162+  C2C2
163+  C2C2                          ; Особый звуковой сигнал
164+  C2C2 3A F1 8F                 ld    a, (bios_vars.beepDuration)
165+  C2C5 F5                       push  af
166+  C2C6 3E 4F                    ld    a, 4Fh
167+  C2C8 32 F1 8F                 ld    (bios_vars.beepDuration),a
168+  C2CB CD 70 C1                 call  beep
169+  C2CE 3E 5F                    ld    a, 5Fh
170+  C2D0 32 F1 8F                 ld    (bios_vars.beepDuration),a
171+  C2D3 CD 70 C1                 call  beep
172+  C2D6 F1                       pop   af
173+  C2D7 32 F1 8F                 ld    (bios_vars.beepDuration),a
174+  C2DA
175+  C2DA                          ; ...
176+  C2DA 00                       nop
177+  C2DB
178+  C2DB C3 25 C2                 jp    getch_retry
179+  C2DE
180+  C2DE              ; ---------------------------------------------------------------------------
181+  C2DE              ; Включаем кирилицу или строчные буквы
182+  C2DE
183+  C2DE              getch_chars:      ; Если не нажат CAPS LOCK, пропускаем код ниже
184+  C2DE 3A EC 8F                 ld    a, (bios_vars.keyLocks)
185+  C2E1 4F                       ld    c, a
186+  C2E2 A7                       and   a
187+  C2E3 FA EA C2                 jp M, loc_C2EA    ; CAPS LOCK
188+  C2E6
189+  C2E6                          ; Превращаем заглавные в строчные
190+  C2E6 78                       ld    a, b
191+  C2E7 EE 20                    xor   20h
192+  C2E9 47                       ld    b, a
193+  C2EA
194+  C2EA              loc_C2EA:   ; Если зафиксирвоан ли РУС/ЛАТ, помещаем в c=1
195+  C2EA 79                       ld    a, c
196+  C2EB E6 01                    and   1
197+  C2ED 4F                       ld    c, a
198+  C2EE
199+  C2EE                          ; Если шифт нажат, помещаем в a=0
200+  C2EE 3A E1 FF                 ld    a, (IO_KEYB_B)
201+  C2F1 E6 02                    and   2
202+  C2F3 0F                       RRCA                    ;! Как на счет флага c ?
203+  C2F4
204+  C2F4                          ; Превращаем английские символы в русские если a^c==0
205+  C2F4 A9                       xor   c
206+  C2F5 78                       ld    a, b
207+  C2F6 C2 B7 C5                 jp nz,  loc_C5A8
208+  C2F9 C6 80                    add   a,80h
209+  C2FB C3 B7 C5                 jp    loc_C5A8
210+  C2FE
211+  C2FE              ; ---------------------------------------------------------------------------
212+  C2FE              ; Меняем цифры на символы
213+  C2FE
214+  C2FE              getch_shift:      ; Если не нажат шифт, пропускаем код ниже
215+  C2FE 3A E1 FF                 ld    a, (IO_KEYB_B)
216+  C301 E6 02                    and   2
217+  C303 78                       ld    a, b
218+  C304 C2 B7 C5                 jp nz,  loc_C5A8
219+  C307
220+  C307                          ; Меняем цифры на символы
221+  C307 EE 10                    xor   10h
222+  C309
223+  C309                          ; Одно исключение 30h должен меняться на 5Fh
224+  C309 FE 20                    cp    20h
225+  C30B C2 10 C3                 jp nz,  getch_noShift
226+  C30E 3E 5F                    ld    a, 5Fh
227+  C310
228+  C310                          ; Прододжение getch_noShift
229+  C310
230+  C310              ; ---------------------------------------------------------------------------
231+  C310              ; Символы без изменений
232+  C310
233+  C310              getch_noShift:  ; Сохраняем код нажатой клавиши в b
234+  C310 47                       ld    b, a
235+  C311
236+  C311 CD C1 C1     loc_C311:   call  setKeybMode83
237+  C314 3E F7                    ld    a, 0F7h
238+  C316 32 E0 FF                 ld    (IO_KEYB_A),a
239+  C319 3A E1 FF                 ld    a, (IO_KEYB_B)
240+  C31C 2F                       CPL
241+  C31D 0F                       RRCA
242+  C31E 0F                       RRCA
243+  C31F 0F                       RRCA
244+  C320 CD 54 C2                 call  setKeybMode82
245+  C323 00                       nop
246+  C324
247+  C324                          ; Восстаналиваем код нажатой клавиши
248+  C324 78                       ld    a, b
249+  C325
250+  C325              popa_ret_2: ; Восстаналиваем регистры и выходим
251+  C325 D1                       pop   de
252+  C326 C1                       pop   bc
253+  C327 E1                       pop   hl
254+  C328 C9                       ret
255+  C329
 47   C329              	INCLUDE "calcCursorAddr.inc"
  1+  C329              ;+---------------------------------------------------------------------------
  2+  C329              ; MXOS
  3+  C329              ; Расчет адреса курсора в видеопамяти. И перевод строки, если курсор был
  4+  C329              ; за правым краем экрана.
  5+  C329              ;
  6+  C329              ; На выходе
  7+  C329              ;  hl - координаты курсора
  8+  C329              ;  a * 256 + l - адрес в видеопамяти
  9+  C329              ;
 10+  C329              ; 2013-12-12 Дизассемблировано vinxru
 11+  C329              ;----------------------------------------------------------------------------
 12+  C329
 13+  C329              calcCursorAddr:   ; В hl положение курсора
 14+  C329 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 15+  C32C
 16+  C32C                          ; Если cursorX >= 190, то перевод строки (вывод кода 10)
 17+  C32C                          ; Иначе рассчитываем адрес старшего байта a = cursorX / 4 + 90h
 18+  C32C 7C                       ld    a, h
 19+  C32D FE BE                    cp    190
 20+  C32F DA 41 C3                 jp c, calcCursorAd_1
 21+  C332 0E 0A                    ld    c, 10
 22+  C334 C3 3A C3                 jp    calcCursorAd_0
 23+  C337
 48   C337
 49   C337                  ORG_PAD 0C337h
 49   C337             >         ; add padding + display warning
 49   C337             >         IF $ > 0C337h
 49   C337 ~           >           ; no padding
 49   C337 ~           >           ASSERT 0
 49   C337 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 49   C337             >         ELSE
 49   C337             >           ; add padding
 49   C337             >           BLOCK 0C337h-$
 49   C337             >         ENDIF
 49   C337             >         ORG 0C337h
 50   C337              	INCLUDE "getch.inc"
  1+  C337              ;----------------------------------------------------------------------------
  2+  C337              ; MXOS
  3+  C337              ; Ожидание ввода с клавиатуры
  4+  C337              ;
  5+  C337              ; На выходе
  6+  C337              ;  ? - код
  7+  C337              ;
  8+  C337              ; 2013-12-12 Дизассемблировано vinxru
  9+  C337              ;----------------------------------------------------------------------------
 10+  C337
 11+  C337 C3 1C C2     getch:            jp    getch2
 12+  C33A
 51   C33A              	INCLUDE "calcCursorAddr2.inc"
  1+  C33A              ;+---------------------------------------------------------------------------
  2+  C33A              ; MXOS
  3+  C33A              ; Расчет адреса курсора в видеопамяти (продолжение);
  4+  C33A              ;
  5+  C33A              ; 2013-12-12 Дизассемблировано vinxru
  6+  C33A              ;----------------------------------------------------------------------------
  7+  C33A
  8+  C33A              calcCursorAd_0:   ; Перевод строки (на входе c=10)
  9+  C33A CD 37 C0                 call  printChar
 10+  C33D
 11+  C33D                          ; Восстановление регистров после printChar (хотя он не портит регистры)
 12+  C33D 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 13+  C340 7C                       ld    a, h
 14+  C341
 15+  C341              calcCursorAd_1:   ; Расчет старшего байта адреса
 16+  C341                          ; a = cursorX / 4 + 90h
 17+  C341 0F                       RRCA
 18+  C342 0F                       RRCA
 19+  C343 E6 3F                    and   3Fh
 20+  C345 C6 90                    add   a,90h
 21+  C347 C9                       ret
 22+  C348
 52   C348              	INCLUDE "drawCursor.inc"
  1+  C348              ;+---------------------------------------------------------------------------
  2+  C348              ; MXOS
  3+  C348              ; Рисование курсора на экране
  4+  C348              ;
  5+  C348              ; На выходе
  6+  C348              ;  bc, de, hl - сохраняются
  7+  C348              ;
  8+  C348              ; 2013-12-12 Дизассемблировано vinxru
  9+  C348              ;----------------------------------------------------------------------------
 10+  C348
 11+  C348              drawCursor: ; Если установлен 7-ой бит bios_vars.cursorCfg & 0x80, выходим
 12+  C348 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 13+  C34B A7                       and   a
 14+  C34C F8                       ret m
 15+  C34D
 16+  C34D              drawCursor2:      ; Курсор нарисован/стерт
 17+  C34D 0C                       inc   c
 18+  C34E
 19+  C34E              drawCursor3:      ; Сохраняем регистры
 20+  C34E E5                       push  hl
 21+  C34F C5                       push  bc
 22+  C350 D5                       push  de
 23+  C351
 24+  C351                          ; Рассчитываем адрес на экране
 25+  C351 CD 29 C3                 call  calcCursorAddr
 26+  C354 57                       ld    d, a
 27+  C355
 28+  C355                          ; Положение курсора от +2 до -5 (при битах 654 от 0 до 7)
 29+  C355                          ; b = bios_vars.cursorCfg
 30+  C355                          ; e = ~((bios_vars.cursorCfg / 16) % 8 - 3) + l
 31+  C355 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 32+  C358 47                       ld    b, a
 33+  C359 0F                       RRCA
 34+  C35A 0F                       RRCA
 35+  C35B 0F                       RRCA
 36+  C35C 0F                       RRCA
 37+  C35D E6 07                    and   7
 38+  C35F D6 03                    sub   3
 39+  C361 2F                       CPL
 40+  C362 85                       add   a, l
 41+  C363 5F                       ld    e, a
 42+  C364
 43+  C364                          ; Рассчитыаем маску курсора
 44+  C364                          ;  hl = 011111100b << (((~h) % 4 +1)*2)
 45+  C364 7C                       ld    a, h
 46+  C365 2F                       CPL
 47+  C366 E6 03                    and   3
 48+  C368 21 FC 00                 ld    hl, 011111100b ; FCh
 49+  C36B 3C                       inc   a
 50+  C36C 29           drawCursor_0:     add   hl, hl
 51+  C36D 29                       add   hl, hl
 52+  C36E C3 43 C4                 jp    drawCursor_1
 53+  C371
 53   C371
 54   C371                  ORG_PAD 0C377h
 54   C371             >         ; add padding + display warning
 54   C371             >         IF $ > 0C377h
 54   C371 ~           >           ; no padding
 54   C371 ~           >           ASSERT 0
 54   C371 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 54   C371             >         ELSE
 54   C371             >           ; add padding
 54   C371 00 00 00... >           BLOCK 0C377h-$
 54   C375             >         ENDIF
 54   C377             >         ORG 0C377h
 55   C377                  INCLUDE "tape.inc"
  1+  C377              ;----------------------------------------------------------------------------
  2+  C377              ; MXOS
  3+  C377              ; Таблица перехвата вызовов драйвера магнитофона
  4+  C377              ;
  5+  C377              ; Изначально все функции просто перезапускают систему.
  6+  C377              ; Адреса заменяются на реальные при установке драйвера.
  7+  C377              ;
  8+  C377              ; 2022-02-03 SpaceEngineer
  9+  C377              ;----------------------------------------------------------------------------
 10+  C377
 11+  C377 C3 00 C8     t_tapeRead:      jp bios_reboot
 12+  C37A C3 00 C8     t_tapeWrite:     jp bios_reboot
 13+  C37D C3 00 C8     t_tapeLoad:      jp bios_reboot
 14+  C380 C3 00 C8     t_tapeSave:      jp bios_reboot
 15+  C383 C3 00 C8     t_tapeLoadInt:   jp bios_reboot
 16+  C386 C3 00 C8     t_tapeReadError: jp bios_reboot
 17+  C389
 56   C389
 57   C389                  ORG_PAD 0C3D0h
 57   C389             >         ; add padding + display warning
 57   C389             >         IF $ > 0C3D0h
 57   C389 ~           >           ; no padding
 57   C389 ~           >           ASSERT 0
 57   C389 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 57   C389             >         ELSE
 57   C389             >           ; add padding
 57   C389 00 00 00... >           BLOCK 0C3D0h-$
 57   C38D             >         ENDIF
 57   C3D0             >         ORG 0C3D0h
 58   C3D0 C3 7A C3         jp  t_tapeWrite
 59   C3D3
 60   C3D3                  ORG_PAD 0C427h
 60   C3D3             >         ; add padding + display warning
 60   C3D3             >         IF $ > 0C427h
 60   C3D3 ~           >           ; no padding
 60   C3D3 ~           >           ASSERT 0
 60   C3D3 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 60   C3D3             >         ELSE
 60   C3D3             >           ; add padding
 60   C3D3 00 00 00... >           BLOCK 0C427h-$
 60   C3D7             >         ENDIF
 60   C427             >         ORG 0C427h
 61   C427              	INCLUDE "cmp_hl_de.inc"
  1+  C427              ;+---------------------------------------------------------------------------
  2+  C427              ; MXOS
  3+  C427              ; Сравнить hl и de
  4+  C427              ;
  5+  C427              ; 2013-12-12 Дизассемблировано vinxru
  6+  C427              ;----------------------------------------------------------------------------
  7+  C427
  8+  C427              cmp_hl_de:
  9+  C427 7C                   ld    a, h
 10+  C428 BA                   cp    d
 11+  C429 C0                   ret   nz
 12+  C42A 7D                   ld    a, l
 13+  C42B BB                   cp    e
 14+  C42C C9                   ret
 15+  C42D
 62   C42D
 63   C42D                  ORG_PAD 0C42Dh
 63   C42D             >         ; add padding + display warning
 63   C42D             >         IF $ > 0C42Dh
 63   C42D ~           >           ; no padding
 63   C42D ~           >           ASSERT 0
 63   C42D ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 63   C42D             >         ELSE
 63   C42D             >           ; add padding
 63   C42D             >           BLOCK 0C42Dh-$
 63   C42D             >         ENDIF
 63   C42D             >         ORG 0C42Dh
 64   C42D              	INCLUDE "memcpy_bc_hl.inc"
  1+  C42D              ;+---------------------------------------------------------------------------
  2+  C42D              ; MXOS
  3+  C42D              ; Скопировать блок памяти
  4+  C42D              ;
  5+  C42D              ; На входе
  6+  C42D              ;  hl - откуда начало
  7+  C42D              ;  de - откуда конец + 1
  8+  C42D              ;  (de-hl) - длина
  9+  C42D              ;  bc - куда
 10+  C42D              ;
 11+  C42D              ; На выходе
 12+  C42D              ;  de - сохраняется
 13+  C42D              ;
 14+  C42D              ; 2013-12-12 Дизассемблировано vinxru
 15+  C42D              ;----------------------------------------------------------------------------
 16+  C42D
 17+  C42D              memcpy_bc_hl:
 18+  C42D 7E                       ld      a, (hl)
 19+  C42E 02                       ld      (bc),a
 20+  C42F 23                       inc     hl
 21+  C430 03                       inc     bc
 22+  C431 CD 27 C4                 call    cmp_hl_de
 23+  C434 C2 2D C4                 jp nz,  memcpy_bc_hl
 24+  C437 C9                       ret
 25+  C438
 65   C438
 66   C438                  ORG_PAD 0C438h
 66   C438             >         ; add padding + display warning
 66   C438             >         IF $ > 0C438h
 66   C438 ~           >           ; no padding
 66   C438 ~           >           ASSERT 0
 66   C438 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 66   C438             >         ELSE
 66   C438             >           ; add padding
 66   C438             >           BLOCK 0C438h-$
 66   C438             >         ENDIF
 66   C438             >         ORG 0C438h
 67   C438              	INCLUDE "printString1.inc"
  1+  C438              ;+---------------------------------------------------------------------------
  2+  C438              ; MXOS
  3+  C438              ; Вывод строки на экран
  4+  C438              ;
  5+  C438              ; На входе
  6+  C438              ;  hl - строка
  7+  C438              ;
  8+  C438              ; На выходе
  9+  C438              ;  af, bc, de - сохраняются
 10+  C438              ;
 11+  C438              ; 2013-12-12 Дизассемблировано vinxru
 12+  C438              ;----------------------------------------------------------------------------
 13+  C438
 14+  C438 C3 26 C5     printString1:     jp    printString
 15+  C43B
 68   C43B              	INCLUDE "printChar6.inc"
  1+  C43B              ;+---------------------------------------------------------------------------
  2+  C43B              ; MXOS
  3+  C43B              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C43B              ;
  5+  C43B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C43B              ;----------------------------------------------------------------------------
  7+  C43B
  8+  C43B              ; ---------------------------------------------------------------------------
  9+  C43B              ; Обработка ESC+F
 10+  C43B
 11+  C43B 3E 80        printChar_eF:   ld    a, 80h
 12+  C43D 32 EB 8F                     ld    (bios_vars.escMode), a
 13+  C440 C9                           ret
 14+  C441
 69   C441
 70   C441                  ORG_PAD 0C443h
 70   C441             >         ; add padding + display warning
 70   C441             >         IF $ > 0C443h
 70   C441 ~           >           ; no padding
 70   C441 ~           >           ASSERT 0
 70   C441 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 70   C441             >         ELSE
 70   C441             >           ; add padding
 70   C441 00 00       >           BLOCK 0C443h-$
 70   C443             >         ENDIF
 70   C443             >         ORG 0C443h
 71   C443                  INCLUDE "drawCursor2.inc"
  1+  C443              ;+---------------------------------------------------------------------------
  2+  C443              ; MXOS
  3+  C443              ; Рисование курсора на экране (продолжение)
  4+  C443              ;
  5+  C443              ; 2013-12-12 Дизассемблировано vinxru
  6+  C443              ;----------------------------------------------------------------------------
  7+  C443
  8+  C443              drawCursor_1:     ; Цикл
  9+  C443 3D                       dec   a
 10+  C444 C2 6C C3                 jp nz,  drawCursor_0
 11+  C447
 12+  C447                          ; b = vars.cursorCfg & 0xF
 13+  C447 78                       ld    a, b
 14+  C448 E6 0F                    and   0Fh
 15+  C44A 47                       ld    b, a
 16+  C44B
 17+  C44B                          ; Вывод курсора (b - высота, de - адрес на экране, hl - курсор)
 18+  C44B
 19+  C44B              drawCursor_2:     ; Повторить код ниже b раз
 20+  C44B 05                       dec   b
 21+  C44C FA 25 C3                 jp M, popa_ret_2
 22+  C44F
 23+  C44F                          ; *de--     ^= hl;
 24+  C44F 1A                       ld    a, (de)
 25+  C450 AC                       xor   h
 26+  C451 12                       ld    (de),a
 27+  C452 14                       inc   d
 28+  C453 1A                       ld    a, (de)
 29+  C454 AD                       xor   l
 30+  C455 12                       ld    (de),a
 31+  C456 15                       dec   d
 32+  C457 1D                       dec   e
 33+  C458 C3 4B C4                 jp    drawCursor_2
 34+  C45B
 72   C45B              	INCLUDE "reboot1.inc"
  1+  C45B              ;+---------------------------------------------------------------------------
  2+  C45B              ; MXOS
  3+  C45B              ; Перезагрузка (продолжение)
  4+  C45B              ;
  5+  C45B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C45B              ;----------------------------------------------------------------------------
  7+  C45B
  8+  C45B              reboot1:    ; Для выключения звука
  9+  C45B 3E 36                    ld    a, 36h
 10+  C45D
 11+  C45D                          ; Включаем ОЗУ
 12+  C45D 32 FC FF                 ld    (IO_PAGE_RAM), a
 13+  C460
 14+  C460                          ; Выключаем звук
 15+  C460 32 EF FF                 ld    (IO_TIMER_MODE), a
 16+  C463
 17+  C463                          ; Инициализация переменных
 18+  C463 21 7B C4                 ld    hl, initVars      ; Откуда
 19+  C466 11 9C C4                 ld    de, initVarsEnd   ; Конец
 20+  C469 01 DF 8F                 ld    bc, bios_vars     ; Куда
 21+  C46C CD 2D C4                 call  memcpy_bc_hl
 22+  C46F
 23+  C46F                          ; Установка цвета
 24+  C46F                  IF ENABLE_COLOR
 25+  C46F 3E F0                    ld    a, COLOR_BIOS
 26+  C471 32 F8 FF                 ld    (IO_COLOR), a
 27+  C474                  ELSE
 28+  C474 ~                        ld    a, 0Fh
 29+  C474 ~                        ld    (IO_KEYB_MODE), a
 30+  C474                  ENDIF
 31+  C474
 32+  C474                  IF LOAD_FONT
 33+  C474              onceInitFont:
 34+  C474 C3 CD CF                 jp    initFont
 35+  C477                  ELSE
 36+  C477 ~                        jp    reboot2
 37+  C477                  ENDIF
 38+  C477
 73   C477
 74   C477                  ORG_PAD 0C478h
 74   C477             >         ; add padding + display warning
 74   C477             >         IF $ > 0C478h
 74   C477 ~           >           ; no padding
 74   C477 ~           >           ASSERT 0
 74   C477 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 74   C477             >         ELSE
 74   C477             >           ; add padding
 74   C477 00          >           BLOCK 0C478h-$
 74   C478             >         ENDIF
 74   C478             >         ORG 0C478h
 75   C478 C3 86 C3         jp  t_tapeReadError
 76   C47B
 77   C47B              ;---------------------------------------------------------------------------
 78   C47B              ; Переменые
 79   C47B              ;---------------------------------------------------------------------------
 80   C47B
 81   C47B              ; Начальные значения переменных хранятся здесь, и при сбросе
 82   C47B              ; копируются на адрес bios_vars (=8FDFh) функцией reboot1
 83   C47B
 84   C47B FF FF 00 C8  initVars    BIOS_VARIABLES
 84   C47F FF FF FF FF
 84   C483 20 1D A9 FF
 84   C487 FF 3A FF FF
 84   C48B FF FF 5F 20
 84   C48F FF 20 E0 FF
 84   C493 FF 0F 00 00
 84   C497 00 FF FF 28
 84   C49B 3C
 85   C49C
 86   C49C              initVarsEnd:
 87   C49C 00               DB 00h
 88   C49D
 89   C49D              ; Таблица кодов клавиатуры
 90   C49D
 91   C49D              v_keybTbl:
 92   C49D 81 0C 19 1A      DB 81h, 0Ch, 19h, 1Ah, 09h, 1Bh, 20h,  8,  80h, 18h, 0Ah, 0Dh, 0, 0, 0, 0
 92   C4A1 09 1B 20 08
 92   C4A5 80 18 0A 0D
 92   C4A9 00 00 00 00
 93   C4AD 71 7E 73 6D      DB 71h, 7Eh, 73h, 6Dh, 69h, 74h, 78h, 62h, 60h, 2Ch, 2Fh, 7Fh, 0, 0, 0, 0
 93   C4B1 69 74 78 62
 93   C4B5 60 2C 2F 7F
 93   C4B9 00 00 00 00
 94   C4BD 66 79 77 61      DB 66h, 79h, 77h, 61h, 70h, 72h, 6Fh, 6Ch, 64h, 76h, 7Ch, 2Eh, 0, 0, 0, 0
 94   C4C1 70 72 6F 6C
 94   C4C5 64 76 7C 2E
 94   C4C9 00 00 00 00
 95   C4CD 6A 63 75 6B      DB 6Ah, 63h, 75h, 6Bh, 65h, 6Eh, 67h, 7Bh, 7Dh, 7Ah, 68h, 3Ah, 0, 0, 0, 0
 95   C4D1 65 6E 67 7B
 95   C4D5 7D 7A 68 3A
 95   C4D9 00 00 00 00
 96   C4DD 3B 31 32 33      DB 3Bh, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh, 0, 0, 0, 0
 96   C4E1 34 35 36 37
 96   C4E5 38 39 30 2D
 96   C4E9 00 00 00 00
 97   C4ED 00 01 02 03      DB 00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 8Ah, 8Bh, 8Ch, 1Fh, 0, 0, 0, 0
 97   C4F1 04 05 06 07
 97   C4F5 8A 8B 8C 1F
 97   C4F9 00 00 00 00
 98   C4FD
 99   C4FD                  ORG_PAD 0C500h
 99   C4FD             >         ; add padding + display warning
 99   C4FD             >         IF $ > 0C500h
 99   C4FD ~           >           ; no padding
 99   C4FD ~           >           ASSERT 0
 99   C4FD ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 99   C4FD             >         ELSE
 99   C4FD             >           ; add padding
 99   C4FD 00 00 00    >           BLOCK 0C500h-$
 99   C500             >         ENDIF
 99   C500             >         ORG 0C500h
100   C500              	INCLUDE "printer.inc"
  1+  C500              ;+---------------------------------------------------------------------------
  2+  C500              ; MXOS
  3+  C500              ; Вывод байта на принтер
  4+  C500              ;
  5+  C500              ; На входе
  6+  C500              ;   c - байт
  7+  C500              ;
  8+  C500              ; На выходе
  9+  C500              ;   af, bc, de, hl - cохраняются
 10+  C500              ;
 11+  C500              ; 2013-12-12 Дизассемблировано vinxru
 12+  C500              ;----------------------------------------------------------------------------
 13+  C500
 14+  C500              printer:    ; Сохраняем регистры
 15+  C500 F5                       push  af
 16+  C501
 17+  C501                          ; Режим порта расширения
 18+  C501 3E 90                    ld    a, 90h
 19+  C503 32 E7 FF                 ld    (IO_PROG_MODE), a
 20+  C506
 21+  C506                          ; Выводим байт на принтер
 22+  C506 79                       ld    a, c
 23+  C507 2F                       CPL
 24+  C508 32 E5 FF                 ld    (IO_PROG_B), a
 25+  C50B
 26+  C50B              printer_loop:     ; Выход     при нажатии любой клавиши
 27+  C50B 3A E1 FF                 ld    a, (IO_KEYB_B)
 28+  C50E E6 02                    and   2
 29+  C510 CA 24 C5                 jp z, printer_ret
 30+  C513
 31+  C513                          ; Ждем пока принтер не будет готов
 32+  C513 3A E4 FF                 ld    a, (IO_PROG_A)
 33+  C516 E6 40                    and   40h
 34+  C518 C2 0B C5                 jp nz,  printer_loop
 35+  C51B
 36+  C51B                          ; Строб
 37+  C51B 3E 03                    ld    a, 3
 38+  C51D 32 E6 FF                 ld    (IO_PROG_C), a
 39+  C520 AF                       xor   a
 40+  C521 32 E6 FF                 ld    (IO_PROG_C), a
 41+  C524
 42+  C524              printer_ret:      ; Восстаналвиаем регистры
 43+  C524 F1                       pop   af
 44+  C525 C9                       ret
 45+  C526
101   C526              	INCLUDE "printString.inc"
  1+  C526              ;+---------------------------------------------------------------------------
  2+  C526              ; MXOS
  3+  C526              ; Вывод строки на экран
  4+  C526              ;
  5+  C526              ; На входе
  6+  C526              ;  hl - строка
  7+  C526              ;
  8+  C526              ; На выходе
  9+  C526              ;  af, bc, de - сохраняются
 10+  C526              ;
 11+  C526              ; 2013-12-12 Дизассемблировано vinxru
 12+  C526              ;----------------------------------------------------------------------------
 13+  C526
 14+  C526              printString:      ; Сохраняем регистры
 15+  C526 C5                       push  bc
 16+  C527 F5                       push  af
 17+  C528
 18+  C528              printString_1:    ; Читаем очередной байт
 19+  C528 7E                       ld  a, (hl)
 20+  C529
 21+  C529                          ; Если прочитан 0, выходим
 22+  C529 B7                       or    a
 23+  C52A CA 35 C5                 jp z, printString_2
 24+  C52D
 25+  C52D                          ; Выводим байт на экран
 26+  C52D 4F                       ld    c, a
 27+  C52E CD 37 C0                 call  printChar
 28+  C531
 29+  C531                          ; Следующий байт
 30+  C531 23                       inc   hl
 31+  C532 C3 28 C5                 jp    printString_1
 32+  C535
 33+  C535              ; ---------------------------------------------------------------------------
 34+  C535
 35+  C535              printString_2:    ; Восстанавливаем регистры
 36+  C535 F1                       pop   af
 37+  C536 C1                       pop   bc
 38+  C537 C9                       ret
 39+  C538
102   C538              	INCLUDE "reboot2.inc"
  1+  C538              ;+---------------------------------------------------------------------------
  2+  C538              ; MXOS
  3+  C538              ; Перезагрузка (продолжение)
  4+  C538              ;
  5+  C538              ; 2013-12-12 Дизассемблировано vinxru
  6+  C538              ;----------------------------------------------------------------------------
  7+  C538
  8+  C538              reboot2:
  9+  C538                          ; Очищаем экран
 10+  C538 CD 10 C0                 call    clearScreen
 11+  C53B
 12+  C53B                  IF BOOT_FROM_TAPE
 13+  C53B ~                        ; Проверяем, нажата ли какая нибудь клавиша
 14+  C53B ~                        call    j_keyScan
 15+  C53B ~                        push    af
 16+  C53B                  ENDIF
 17+  C53B
 18+  C53B                          ; Выводим версию ОС на экран
 19+  C53B 21 1B CF                 ld      hl, txtBiosVer
 20+  C53E CD 38 C4                 call    printString1
 21+  C541
 22+  C541                          ; Определяем размер ДОЗУ
 23+  C541 21 BB FF                 ld      hl, RAMD_PAGE_END
 24+  C544 3A F8 8F                 ld      a, (bios_vars.maxRamPage)
 25+  C547 CD AE C7                 call    checkRAMD
 26+  C54A
 27+  C54A                          ; Выводим объем ДОЗУ на экран
 28+  C54A 21 2C CF                 ld      hl, txtRAM
 29+  C54D CD 38 C4                 call    printString1
 30+  C550
 31+  C550                          ; Вычисляем объем ДОЗУ в байтах
 32+  C550 3A F8 8F                 ld      a, (bios_vars.maxRamPage)
 33+  C553 26 00                    ld      h, 0
 34+  C555 6F                       ld      l, a
 35+  C556 2C                       inc     l       ; hl = объём в страницах
 36+  C557 2C                       inc     l       ; +1 страница - основная память
 37+  C558 29                       add     hl, hl
 38+  C559 29                       add     hl, hl
 39+  C55A 29                       add     hl, hl
 40+  C55B 29                       add     hl, hl
 41+  C55C 29                       add     hl, hl
 42+  C55D 29                       add     hl, hl  ; hl = hl * 64
 43+  C55E EB                       ex      hl, de
 44+  C55F CD BC CE                 call    printDecWord
 45+  C562
 46+  C562 21 32 CF                 ld      hl, txtKB
 47+  C565 CD 38 C4                 call    printString1
 48+  C568
 49+  C568                      IF BOOT_FROM_TAPE==0
 50+  C568
 51+  C568                          ; Продолжаем загрузку системы
 52+  C568 C3 00 C8                 jp      j_reboot3
 53+  C56B
 54+  C56B                      ELSE
 55+  C56B ~
 56+  C56B ~                        ; Если не нажата ни одна клавиша, продолжаем загрузку системы
 57+  C56B ~                        pop     af
 58+  C56B ~                        inc     a
 59+  C56B ~                        jp z,   j_reboot3
 60+  C56B ~
 61+  C56B ~                        ; Загружаем драйвер магнитофона
 62+  C56B ~                        ld      hl, aATape_com
 63+  C56B ~                        call    fileExec
 64+  C56B ~
 65+  C56B ~                        ; Загружаем программу с ленты (без контроля КС) и запускаем
 66+  C56B ~                        ld      hl, txtLoadingFromTape
 67+  C56B ~                        call    printString1
 68+  C56B ~                        call    t_tapeLoadInt
 69+  C56B ~                        ld      hl, (bios_vars.tapeAddr)
 70+  C56B ~                        jp      (hl)
 71+  C56B ~
 72+  C56B                      ENDIF
 73+  C56B
103   C56B              	INCLUDE "getch3.inc"
  1+  C56B              ;----------------------------------------------------------------------------
  2+  C56B              ; MXOS
  3+  C56B              ; Ожидание ввода с клавиатуры (продолжение)
  4+  C56B              ;
  5+  C56B              ; На выходе
  6+  C56B              ;  ? - код
  7+  C56B              ;
  8+  C56B              ; 2013-12-12 Дизассемблировано vinxru
  9+  C56B              ;----------------------------------------------------------------------------
 10+  C56B
 11+  C56B              loc_C55C:   ; Если нажат лишь РУС/LAT - то обрабатываем его как CAPS/LOCK
 12+  C56B CD 5A C2                 call  setKeybMode91
 13+  C56E 3E F8                    ld    a, 0F8h
 14+  C570 32 E1 FF                 ld    (IO_KEYB_B),a
 15+  C573 3A E0 FF                 ld    a, (IO_KEYB_A)
 16+  C576 F5                       push  af
 17+  C577 CD 54 C2                 call  setKeybMode82
 18+  C57A F1                       pop   af
 19+  C57B E6 08                    and   8
 20+  C57D C2 97 C5                 jp nz,  getch_capsLock
 21+  C580
 22+  C580                          ; Меняем KOI-7 / KOI-8
 23+  C580 3A EA 8F                 ld    a, (bios_vars.koi8)
 24+  C583 2F                       CPL
 25+  C584 32 EA 8F                 ld    (bios_vars.koi8),a
 26+  C587
 27+  C587                          ; Звуковой сигнал
 28+  C587 CD 70 C1                 call  beep
 29+  C58A
 30+  C58A 3E 3A                    ld    a, 3Ah
 31+  C58C 32 EC 8F                 ld    (bios_vars.keyLocks),a
 32+  C58F
 33+  C58F                          ; Меняем частоту
 34+  C58F 3E 5F                    ld    a, 5Fh
 35+  C591 32 F1 8F                 ld    (bios_vars.beepDuration),a
 36+  C594
 37+  C594 C3 25 C2                 jp    getch_retry
 38+  C597
 39+  C597              ; ---------------------------------------------------------------------------
 40+  C597              ; CAPS LOCK для KOI-7
 41+  C597
 42+  C597              getch_capsLock:   ; Переключаем capsLock
 43+  C597 3A EC 8F                 ld    a, (bios_vars.keyLocks)
 44+  C59A EE 80                    xor   80h
 45+  C59C 32 EC 8F                 ld    (bios_vars.keyLocks),a
 46+  C59F
 47+  C59F                          ; Изменяем высоту звуковго сигнала
 48+  C59F 3A F1 8F                 ld    a, (bios_vars.beepDuration)
 49+  C5A2 EE 10                    xor   10h
 50+  C5A4 32 F1 8F                 ld    (bios_vars.beepDuration),a
 51+  C5A7
 52+  C5A7                          ; Ждем следующую клавишу
 53+  C5A7 C3 25 C2                 jp    getch_retry
 54+  C5AA
 55+  C5AA              ; ---------------------------------------------------------------------------
 56+  C5AA              ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
 57+  C5AA
 58+  C5AA              getch_rc:   ; В режиме KOI-8 мы переключаем кодировку
 59+  C5AA 3A EA 8F                 ld    a, (bios_vars.koi8)
 60+  C5AD 3C                       inc   a
 61+  C5AE
 62+  C5AE 3A EC 8F                 ld    a, (bios_vars.keyLocks) ; Требуется в getch_rusLat
 63+  C5B1 C2 BD C2                 jp nz,  getch_rusLat
 64+  C5B4
 65+  C5B4                          ; В режиме KOI-7 мы перключаем регистр
 66+  C5B4 C3 97 C5                 jp    getch_capsLock
 67+  C5B7
 68+  C5B7              ; ---------------------------------------------------------------------------
 69+  C5B7
 70+  C5B7              loc_C5A8:   ; Включен KOI-7
 71+  C5B7 47                       ld    b, a
 72+  C5B8
 73+  C5B8 3A E1 FF                 ld    a, (IO_KEYB_B)
 74+  C5BB E6 02                    and   2
 75+  C5BD C2 11 C3                 jp nz,  loc_C311
 76+  C5C0
 77+  C5C0 3E A0                    ld    a, 0A0h
 78+  C5C2 A8                       xor   b
 79+  C5C3 47                       ld    b, a
 80+  C5C4
 81+  C5C4 C3 11 C3                 jp    loc_C311
 82+  C5C7
104   C5C7              	INCLUDE "printChar2.inc"	; Продолжается в scrollDown
  1+  C5C7              ;+---------------------------------------------------------------------------
  2+  C5C7              ; MXOS
  3+  C5C7              ; Вывод символа на экран (или принтер)
  4+  C5C7              ;
  5+  C5C7              ; На входе
  6+  C5C7              ;  с - символ
  7+  C5C7              ;
  8+  C5C7              ; На выходе
  9+  C5C7              ;  регистры не сохраняются
 10+  C5C7              ;
 11+  C5C7              ; 2013-12-12 Дизассемблировано vinxru
 12+  C5C7              ;----------------------------------------------------------------------------
 13+  C5C7
 14+  C5C7              printChar2:
 15+  C5C7                          ; Помещаем в hl координаты курсора
 16+  C5C7 2A FC 8F                 ld  hl, (bios_vars.cursorY)
 17+  C5CA
 18+  C5CA                          ; Продолжаем, если не включен режим обработки ESC последовательности (bios_vars.escMode==0FFh)
 19+  C5CA 3A EB 8F                 ld  a, (bios_vars.escMode)
 20+  C5CD 3C                       inc a
 21+  C5CE C2 6C C6                 jp  nz,  printChar_esc
 22+  C5D1
 23+  C5D1                          ; Тут bios_vars.escMode==0FFh
 24+  C5D1
 25+  C5D1                          ; Если это печатные символы (>=20h), переходим к печати
 26+  C5D1 79                       ld  a, c
 27+  C5D2 FE 20                    cp  ' '
 28+  C5D4 D2 E6 C5                 jp  nc, printChar_real
 29+  C5D7
 30+  C5D7                          ; Это табуляция
 31+  C5D7 FE 09                    cp  9
 32+  C5D9 CA 50 C0                 jp  z, printChar_c9      ; там bios_vars.cursorX+=24 и ret
 33+  C5DC
 34+  C5DC                          ; Любой символ кроме ESC
 35+  C5DC FE 1B                    cp  1Bh
 36+  C5DE C2 1C C1                 jp  nz, printChar3
 37+  C5E1
 38+  C5E1                          ; Далее ESC. Включаем режим обработки ESC последовательности (bios_vars.escMode=0)
 39+  C5E1 AF                       xor a
 40+  C5E2 32 EB 8F                 ld  (bios_vars.escMode),a
 41+  C5E5 C9                       ret
 42+  C5E6
 43+  C5E6              ; ---------------------------------------------------------------------------
 44+  C5E6              ; Преобразование символа из KOI-7 в KOI-8 и вывод на экран (служебные коды
 45+  C5E6              ; так же будут выводится)
 46+  C5E6
 47+  C5E6              printChar_real:
 48+  C5E6                          ; Символ для печати
 49+  C5E6 4F                       ld  c, a
 50+  C5E7
 51+  C5E7                          ; Продолжаем, если включен режим KOI-7
 52+  C5E7 3A EA 8F                 ld  a, (bios_vars.koi8)
 53+  C5EA 3C                       inc a
 54+  C5EB C2 FF C5                 jp  nz, printChar_real2
 55+  C5EE
 56+  C5EE                          ; Если символ больше или равен 0C0h просто выходим
 57+  C5EE 79                       ld  a, c
 58+  C5EF FE C0                    cp  0C0h
 59+  C5F1 D0                       ret nc
 60+  C5F2
 61+  C5F2                          ; Если символ находится в пределах 60h ... 7Fh, увеличиваем его код на 80h
 62+  C5F2 FE 60                    cp  60h
 63+  C5F4 DA FF C5                 jp  c, printChar_real2
 64+  C5F7 FE 80                    cp  80h
 65+  C5F9 D2 FF C5                 jp  nc,  printChar_real2
 66+  C5FC C6 80                    add a, 80h
 67+  C5FE 4F                       ld  c, a
 68+  C5FF
 69+  C5FF              ; ---------------------------------------------------------------------------
 70+  C5FF              ; Вывод символа на экран в KOI-8 (служебные коды так же будут выводится)
 71+  C5FF
 72+  C5FF              printChar_real2:
 73+  C5FF                          ; Тут полиморфизм
 74+  C5FF 3A FA 8F                 ld    a, (bios_vars.inverse)
 75+  C602 A7                       and   a
 76+  C603
 77+  C603              printChar_poly:
 78+  C603 CC E6 C0                 call z, normalVideo
 79+  C606
 80+  C606                          ; Если bios_vars.charGen не равен 0FFFFh, то используется знакогнератор по адресу bios_vars.charGen*8
 81+  C606 2A E7 8F                 ld    hl, (bios_vars.charGen)
 82+  C609 7C                       ld    a, h
 83+  C60A 3C                       inc   a
 84+  C60B C2 59 C0                 jp nz,  printChar_alt
 85+  C60E 7D                       ld    a, l
 86+  C60F 3C                       inc   a
 87+  C610 C2 59 C0                 jp nz,  printChar_alt
 88+  C613
 89+  C613                          ; Иначе используем символы из ПЗУ.
 90+  C613                          ; Адрес символа в ПЗУ (de = 0x800 + c*8)
 91+  C613 21 00 01                 ld    hl, 100h
 92+  C616 06 00                    ld    b,  0
 93+  C618 09                       add   hl, bc
 94+  C619 29                       add   hl, hl
 95+  C61A 29                       add   hl, hl
 96+  C61B 29                       add   hl, hl
 97+  C61C EB                       ex    de, hl
 98+  C61D
 99+  C61D                          ; Промежуточное место для символа
100+  C61D 21 B4 C1                 ld    hl, v_char
101+  C620 E5                       push  hl
102+  C621
103+  C621                          ; Копируем 8 байт из ПЗУ
104+  C621 32 FE FF                 ld    (IO_PAGE_ROM),a
105+  C624 1A                       ld    a, (de)
106+  C625 77                       ld    (hl), a
107+  C626 23                       inc   hl
108+  C627 13                       inc   de
109+  C628 1A                       ld    a, (de)
110+  C629 77                       ld    (hl), a
111+  C62A 23                       inc   hl
112+  C62B 13                       inc   de
113+  C62C 1A                       ld    a, (de)
114+  C62D 77                       ld    (hl), a
115+  C62E 23                       inc   hl
116+  C62F 13                       inc   de
117+  C630 1A                       ld    a, (de)
118+  C631 77                       ld    (hl), a
119+  C632 23                       inc   hl
120+  C633 13                       inc   de
121+  C634 1A                       ld    a, (de)
122+  C635 77                       ld    (hl), a
123+  C636 23                       inc   hl
124+  C637 13                       inc   de
125+  C638 1A                       ld    a, (de)
126+  C639 77                       ld    (hl), a
127+  C63A 23                       inc   hl
128+  C63B 13                       inc   de
129+  C63C 1A                       ld    a, (de)
130+  C63D 77                       ld    (hl), a
131+  C63E 23                       inc   hl
132+  C63F 13                       inc   de
133+  C640 1A                       ld    a, (de)
134+  C641 77                       ld    (hl), a
135+  C642 32 FC FF                 ld    (IO_PAGE_RAM),a
136+  C645
137+  C645                          ; Вывод символа
138+  C645 D1                       pop   de
139+  C646 C3 60 C0                 jp    printChar_de
140+  C649
141+  C649              ; ---------------------------------------------------------------------------
142+  C649              ; Обработка режима ESC+F
143+  C649
144+  C649              printChar_esc80:; Если символ с кодом 0, выключаем режим обработки ESC
145+  C649 79                       ld    a, c
146+  C64A B7                       or    a
147+  C64B CA 67 C6                 jp z, printChar_esc80_exit
148+  C64E
149+  C64E                          ; Обработка кодов < 20h
150+  C64E FE 20                    cp    20h
151+  C650 DA 1C C1                 jp c, printChar3
152+  C653
153+  C653                          ; Если код >= 80h, выйти
154+  C653 FE 80                    cp    80h
155+  C655 D0                       ret nc
156+  C656
157+  C656                          ; Если c >= 40h, вывести на экран c+40h
158+  C656 FE 40                    cp    40h
159+  C658 D2 61 C6                 jp nc,  printChar_esc80_2
160+  C65B
161+  C65B                          ; Иначе вывести c - 20h
162+  C65B D6 20                    sub   20h ; ' '
163+  C65D 4F                       ld    c, a
164+  C65E C3 FF C5                 jp    printChar_real2
165+  C661
166+  C661              ; ---------------------------------------------------------------------------
167+  C661
168+  C661              printChar_esc80_2:
169+  C661                          ; Если c >= 40h, вывести на экран c+40h
170+  C661 C6 40                    add   a,40h
171+  C663 4F                       ld    c, a
172+  C664 C3 FF C5                 jp    printChar_real2
173+  C667
174+  C667              ; ---------------------------------------------------------------------------
175+  C667
176+  C667              printChar_esc80_exit:
177+  C667 3D                       dec   a
178+  C668 32 EB 8F                 ld    (bios_vars.escMode),a
179+  C66B C9                       ret
180+  C66C
181+  C66C              ; ---------------------------------------------------------------------------
182+  C66C              ; Печать символа в ESC-режиме
183+  C66C
184+  C66C              printChar_esc:    ; Перейти если bios_vars.escMode=80h
185+  C66C 3A EB 8F                 ld    a, (bios_vars.escMode)
186+  C66F FE 80                    cp    80h
187+  C671 CA 49 C6                 jp z, printChar_esc80
188+  C674
189+  C674                          ; Выключить режим обработки ESC последовательности
190+  C674 F5                       push  af
191+  C675 3E FF                    ld    a, 0FFh
192+  C677 32 EB 8F                 ld    (bios_vars.escMode),a
193+  C67A F1                       pop   af
194+  C67B
195+  C67B                          ; Перейти если bios_vars.escMode==0
196+  C67B B7                       or    a
197+  C67C CA B6 C6                 jp z, printChar_esc0
198+  C67F
199+  C67F                          ; Перейти если обработка ESC+Y (bios_vars.escMode==1)
200+  C67F 3D                       dec   a
201+  C680 CA 8C C6                 jp z, printChar_esc1
202+  C683
203+  C683                          ; Перейти если bios_vars.escMode==2
204+  C683 3D                       dec   a
205+  C684 CA A8 C6                 jp z, printChar_esc2
206+  C687
207+  C687                          ; Перейти если bios_vars.escMode==3
208+  C687 3D                       dec   a
209+  C688 CA 1C C7                 jp z, printChar_esc3
210+  C68B
211+  C68B                          ; Выйти
212+  C68B C9                       ret
213+  C68C
214+  C68C              ; ---------------------------------------------------------------------------
215+  C68C              ; Обработка ESC+Y
216+  C68C
217+  C68C              printChar_esc1:   ; Если код меньше 20h или больше 20h + 24, то пропускаем установку Y
218+  C68C 79                       ld    a, c
219+  C68D FE 39                    cp    20h + 25
220+  C68F D2 A2 C6                 jp nc,  loc_C693
221+  C692 D6 20                    sub   20h
222+  C694 DA A2 C6                 jp c, loc_C693
223+  C697
224+  C697                          ; cursorY = 8 + a*10
225+  C697 87                       add   a, a
226+  C698 4F                       ld    c, a
227+  C699 81                       add   a, c
228+  C69A 81                       add   a, c
229+  C69B 81                       add   a, c
230+  C69C 81                       add   a, c
231+  C69D C6 08                    add   a,8
232+  C69F 32 FC 8F                 ld    (bios_vars.cursorY),a
233+  C6A2
234+  C6A2              loc_C693:   ; Следующий символ будет обработан в printChar_esc2
235+  C6A2 3E 02                    ld    a, 2
236+  C6A4 32 EB 8F                 ld    (bios_vars.escMode),a
237+  C6A7 C9                       ret
238+  C6A8
239+  C6A8              ; ---------------------------------------------------------------------------
240+  C6A8              ; Обработка ESC+Y
241+  C6A8
242+  C6A8              printChar_esc2:   ; Если код меньше 20h или больше 20h + 63, то пропускаем установку X
243+  C6A8 79                       ld    a, c
244+  C6A9 FE 60                    cp    60h
245+  C6AB D0                       ret nc
246+  C6AC D6 20                    sub   20h
247+  C6AE D8                       ret c
248+  C6AF
249+  C6AF                          ; cursorX = c*3;
250+  C6AF 4F                       ld    c, a
251+  C6B0 87                       add   a, a
252+  C6B1 81                       add   a, c
253+  C6B2 32 FD 8F                 ld    (bios_vars.cursorX),a
254+  C6B5 C9                       ret
255+  C6B6
256+  C6B6              ; ---------------------------------------------------------------------------
257+  C6B6              ; Обработка первого символа ESC последовательности
258+  C6B6
259+  C6B6              printChar_esc0:   ; Если код больше 20h
260+  C6B6 79                       ld    a, c
261+  C6B7 FE 28                    cp    '(' ; 28h
262+  C6B9 CA 45 C0                 jp z, printChar_e28
263+  C6BC FE 29                    cp    ')' ; 29h
264+  C6BE CA 4B C0                 jp z, printChar_e29
265+  C6C1 FE 50                    cp    'P' ; 50h
266+  C6C3 CA 0C C7                 jp z, printChar_eP
267+  C6C6 D6 41                    sub   'A' ; 41h
268+  C6C8 CA 12 C7                 jp z, printChar19
269+  C6CB 3D                       dec   a ; 'b' 42h
270+  C6CC CA 17 C7                 jp z, printChar1A
271+  C6CF 3D                       dec   a ; 'c' 43h
272+  C6D0 CA F8 C6                 jp z, printChar18
273+  C6D3 3D                       dec   a ; 'd' 44h
274+  C6D4 CA FD C6                 jp z, printChar08
275+  C6D7 3D                       dec   a ; 'e' 45h
276+  C6D8 CA 02 C7                 jp z, printChar1F
277+  C6DB 3D                       dec   a ; 'F' 46h
278+  C6DC CA 3B C4                 jp z, printChar_eF
279+  C6DF 3D                       dec   a
280+  C6E0 3D                       dec   a ; 'h' 48h
281+  C6E1 CA 07 C7                 jp z, printChar0C
282+  C6E4 3D                       dec   a ; 'I' 49h
283+  C6E5 CA 36 C7                 jp z, printChar_eI
284+  C6E8 3D                       dec   a
285+  C6E9 3D                       dec   a
286+  C6EA D6 0E                    sub   14 ; 'Y' 59h
287+  C6EC CA F2 C6                 jp z, setEscMode_eY
288+  C6EF
289+  C6EF                          ; Вывод символа
290+  C6EF C3 C7 C5                 jp    printChar2
291+  C6F2
292+  C6F2              ; ---------------------------------------------------------------------------
293+  C6F2              ; Обработка ESC+Y.
294+  C6F2
295+  C6F2              setEscMode_eY:    ; Следующий символ будет обработан в printChar_esc1
296+  C6F2 3E 01                    ld    a, 1
297+  C6F4 32 EB 8F                 ld    (bios_vars.escMode),a
298+  C6F7 C9                       ret
299+  C6F8
300+  C6F8              ; ---------------------------------------------------------------------------
301+  C6F8
302+  C6F8              printChar18:
303+  C6F8 0E 18                    ld    c, 18h
304+  C6FA C3 C7 C5                 jp    printChar2
305+  C6FD
306+  C6FD              ; ---------------------------------------------------------------------------
307+  C6FD
308+  C6FD              printChar08:
309+  C6FD 0E 08                    ld    c, 8
310+  C6FF C3 C7 C5                 jp    printChar2
311+  C702
312+  C702              ; ---------------------------------------------------------------------------
313+  C702
314+  C702 0E 1F        printChar1F:      ld    c, 1Fh
315+  C704 C3 C7 C5                 jp    printChar2
316+  C707
317+  C707              ; ---------------------------------------------------------------------------
318+  C707
319+  C707              printChar0C:
320+  C707 0E 0C                    ld    c, 0Ch
321+  C709 C3 C7 C5                 jp    printChar2
322+  C70C
323+  C70C              ; ---------------------------------------------------------------------------
324+  C70C              ; Обработка ESP+P. Вклчюение режима эхопечати на принтере
325+  C70C
326+  C70C              printChar_eP:
327+  C70C 3E 03                    ld    a, 3
328+  C70E 32 EB 8F                 ld    (bios_vars.escMode),a
329+  C711 C9                       ret
330+  C712
331+  C712              ; ---------------------------------------------------------------------------
332+  C712
333+  C712              printChar19:
334+  C712 0E 19                    ld    c, 19h
335+  C714 C3 C7 C5                 jp    printChar2
336+  C717
337+  C717              ; ---------------------------------------------------------------------------
338+  C717
339+  C717              printChar1A:
340+  C717 0E 1A                    ld    c, 1Ah
341+  C719 C3 C7 C5                 jp    printChar2
342+  C71C
343+  C71C              ; ---------------------------------------------------------------------------
344+  C71C              ; Режим эхопечати на принтере. Включается ESC+P
345+  C71C
346+  C71C              printChar_esc3:
347+  C71C                          ; Выходим, из режима, если код нулевой
348+  C71C 79                       ld    a, c
349+  C71D B7                       or    a
350+  C71E C8                       ret z
351+  C71F
352+  C71F                          ; Печать на принтере
353+  C71F CD 00 C5                 call  printer
354+  C722
355+  C722                          ; Печать на экране
356+  C722 CD C7 C5                 call  printChar2
357+  C725
358+  C725                          ; Находимся в этом режиме до кода 0 или ESC
359+  C725 3E 03                    ld    a, 3
360+  C727 32 EB 8F                 ld    (bios_vars.escMode),a
361+  C72A C9                       ret
362+  C72B
363+  C72B              ; ---------------------------------------------------------------------------
364+  C72B              ; Продолжение обработки ESC+I. Перемещение курсора вверх с прокруткой экрана
365+  C72B
366+  C72B              printChar_eI_2:
367+  C72B                          ; Если cursorY > 18, перемещаем курсор вверх и выходим
368+  C72B FE 13                    cp    19
369+  C72D D2 C7 C5                 jp nc,  printChar2
370+  C730
371+  C730                          ; Устанаваливаем bios_vars.cursorY=8
372+  C730 3E 08                    ld    a, 8
373+  C732 32 FC 8F                 ld    (bios_vars.cursorY),a
374+  C735 C9                       ret
375+  C736
376+  C736              ; ---------------------------------------------------------------------------
377+  C736              ; Обработка ESC+I. Перемещение курсора вверх с прокруткой экрана
378+  C736
379+  C736              printChar_eI:
380+  C736                          ; Используется дальше функцией printChar2
381+  C736 0E 19                    ld    c, 19h
382+  C738
383+  C738                          ; Прокручиваем экран вних, только если bios_vars.cursorY == 8.
384+  C738                          ; иначе переходим на printChar_eI_2
385+  C738 3A FC 8F                 ld    a, (bios_vars.cursorY)
386+  C73B FE 08                    cp    8
387+  C73D C2 2B C7                 jp nz,  printChar_eI_2
388+  C740
105   C740              	INCLUDE "scrollDown.inc"
  1+  C740              ;+---------------------------------------------------------------------------
  2+  C740              ; MXOS
  3+  C740              ; Прокрутка экрана вниз
  4+  C740              ;
  5+  C740              ; На выходе
  6+  C740              ;   af, bc - сохраняются
  7+  C740              ;
  8+  C740              ; 2013-12-12 Дизассемблировано vinxru
  9+  C740              ;----------------------------------------------------------------------------
 10+  C740
 11+  C740                          ; Сохраняем регистры
 12+  C740 C5                       push    bc
 13+  C741 F5                       push    af
 14+  C742 21 00 00                 ld      hl, 0
 15+  C745 39                       add     hl,sp
 16+  C746 22 F6 8F                 ld      (bios_vars.oldSP), hl
 17+  C749
 18+  C749                          ; Подготовка переменных
 19+  C749 31 00 C0                 ld      sp, 0C000h    ; Куда
 20+  C74C 26 BF                    ld      h, 0BFh       ; Откуда
 21+  C74E 06 30                    ld      b, 48         ; Столбцов
 22+  C750 0E 29        loc_C741:   ld      c, 246 / 6    ; 246 строк
 23+  C752 2E F5                    ld      l, 245        ; Начинаем с 245 строки
 24+  C754
 25+  C754              loc_C745:   ; Копируем 6 байт из hl в sp
 26+  C754 56                       ld      d, (hl)
 27+  C755 2B                       dec     hl
 28+  C756 5E                       ld      e, (hl)
 29+  C757 2B                       dec     hl
 30+  C758 D5                       push    de
 31+  C759 56                       ld      d, (hl)
 32+  C75A 2B                       dec     hl
 33+  C75B 5E                       ld      e, (hl)
 34+  C75C 2B                       dec     hl
 35+  C75D D5                       push    de
 36+  C75E 56                       ld      d, (hl)
 37+  C75F 2B                       dec     hl
 38+  C760 5E                       ld      e, (hl)
 39+  C761 2B                       dec     hl
 40+  C762 D5                       push    de
 41+  C763
 42+  C763                          ; Цикл
 43+  C763 0D                       dec     c
 44+  C764 C2 54 C7                 jp nz,  loc_C745
 45+  C767
 46+  C767                          ; Сохраняем h
 47+  C767 7C                       ld      a, h
 48+  C768
 49+  C768                          ; Очищаем верхние 10 строк
 50+  C768 2A FA 8F                 ld      hl, (bios_vars.inverse)
 51+  C76B E5                       push    hl
 52+  C76C E5                       push    hl
 53+  C76D E5                       push    hl
 54+  C76E E5                       push    hl
 55+  C76F E5                       push    hl
 56+  C770
 57+  C770                          ; Восстанавливаем h
 58+  C770 67                       ld      h, a
 59+  C771
 60+  C771                          ; Следующий столбец
 61+  C771 05                       dec     b
 62+  C772 C2 50 C7                 jp nz,  loc_C741
 63+  C775
 64+  C775                          ; Восстанавлиаем регистры и выходим
 65+  C775 2A F6 8F                 ld      hl, (bios_vars.oldSP)
 66+  C778 F9                       ld      sp, hl
 67+  C779 F1                       pop     af
 68+  C77A C1                       pop     bc
 69+  C77B C9                       ret
 70+  C77C
106   C77C              	INCLUDE "scrollUp2.inc"
  1+  C77C              ;+---------------------------------------------------------------------------
  2+  C77C              ; MXOS
  3+  C77C              ; Прокрутка экрана вверх (продолжение)
  4+  C77C              ;
  5+  C77C              ; 2013-12-12 Дизассемблировано vinxru
  6+  C77C              ;----------------------------------------------------------------------------
  7+  C77C
  8+  C77C              scrollUp2:  ; Копируем 246 байт из sp в H0
  9+  C77C 0E 29                    ld    c, 246 / 6
 10+  C77E 2E 00                    ld    l, 0
 11+  C780
 12+  C780              scrollUp2_0:      ; Копирование 6 байт из sp в hl
 13+  C780 D1                       pop   de
 14+  C781 73                       ld  (hl), e
 15+  C782 23                       inc   hl
 16+  C783 72                       ld  (hl), d
 17+  C784 23                       inc   hl
 18+  C785 D1                       pop   de
 19+  C786 73                       ld  (hl), e
 20+  C787 23                       inc   hl
 21+  C788 72                       ld  (hl), d
 22+  C789 23                       inc   hl
 23+  C78A D1                       pop   de
 24+  C78B 73                       ld  (hl), e
 25+  C78C 23                       inc   hl
 26+  C78D 72                       ld  (hl), d
 27+  C78E 23                       inc   hl
 28+  C78F
 29+  C78F                          ; Цикл
 30+  C78F 0D                       dec   c
 31+  C790 C2 80 C7                 jp nz,  scrollUp2_0
 32+  C793
 33+  C793                          ; Сохраняем h
 34+  C793 7C                       ld    a, h
 35+  C794
 36+  C794                          ; Заполняем 10 байт
 37+  C794 2A FA 8F                 ld    hl, (bios_vars.inverse)
 38+  C797 E5                       push  hl
 39+  C798 E5                       push  hl
 40+  C799 E5                       push  hl
 41+  C79A E5                       push  hl
 42+  C79B E5                       push  hl
 43+  C79C
 44+  C79C                          ; Следующий столбец (sp += 20)
 45+  C79C 21 14 00                 ld    hl, 14h
 46+  C79F 39                       add   hl,sp
 47+  C7A0 F9                       ld    sp, hl
 48+  C7A1
 49+  C7A1                          ; Восстанавливаем h
 50+  C7A1 67                       ld    h, a
 51+  C7A2
 52+  C7A2                          ; Следующий столбец
 53+  C7A2 24                       inc   h
 54+  C7A3
 55+  C7A3                          ; Цикл
 56+  C7A3 05                       dec   b
 57+  C7A4 C2 7C C7                 jp nz,  scrollUp2
 58+  C7A7
 59+  C7A7                          ; Восстановление регистров и выход
 60+  C7A7 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 61+  C7AA F9                       ld    sp, hl
 62+  C7AB F1                       pop   af
 63+  C7AC C1                       pop   bc
 64+  C7AD C9                       ret
 65+  C7AE
107   C7AE              	INCLUDE "checkRAMD.inc"
  1+  C7AE              ;+---------------------------------------------------------------------------
  2+  C7AE              ; MXOS
  3+  C7AE              ; Исправленная функция определения размера ДОЗУ
  4+  C7AE              ; Заимствовано из RAMFOS
  5+  C7AE              ;
  6+  C7AE              ; На входе
  7+  C7AE              ;  а  = максимальный номер страницы, константа MAX_ARAM_PAGE
  8+  C7AE              ;  hl = адрес в странице ДОЗУ для записи тестового байта
  9+  C7AE              ;
 10+  C7AE              ; На выходе
 11+  C7AE              ;  bios_vars.maxRamPage = максимальный номер страницы
 12+  C7AE              ;  NZ - ДОЗУ найдено (наоборот относительно стандратной функции Ramfos)
 13+  C7AE              ;   Z - ДОЗУ не найдено
 14+  C7AE              ;
 15+  C7AE              ; 2013-11-01 Разработано vinxru
 16+  C7AE              ; 2022-02-02 Доработано SpaceEnigneer
 17+  C7AE              ;----------------------------------------------------------------------------
 18+  C7AE
 19+  C7AE              checkRAMD:  ; Устанавливаем побайтный драйвер.
 20+  C7AE                          ; Восстанавливать блочный драйвер не надо,
 21+  C7AE                          ; т.к. он будет установлен в reboot3
 22+  C7AE 06 01                    ld    b, 1
 23+  C7B0 CD CE CA                 call  setRAMDDriver
 24+  C7B3
 25+  C7B3                          ; Записываем во все страницы порядковые номера от большей к меньшей
 26+  C7B3              checkRAMD_0:
 27+  C7B3 4F                       ld      c, a
 28+  C7B4 0C                       inc     c
 29+  C7B5 CD D0 FF                 call    bios_RAMDWrite
 30+  C7B8 3D                       dec     a
 31+  C7B9 F2 B3 C7                 jp p,   checkRAMD_0
 32+  C7BC
 33+  C7BC                          ; Читаем номера. Если номер прочитан корректно, значит есть такая страница
 34+  C7BC                          ; a = -1
 35+  C7BC
 36+  C7BC              checkRAMD_1:
 37+  C7BC                          ; Читаем следующую страницу
 38+  C7BC 3C                       inc     a
 39+  C7BD CD C0 FF                 call    bios_RAMDRead
 40+  C7C0
 41+  C7C0                           ; Должен быть записан номер страницы+1, если нет, то выходим
 42+  C7C0 0D                       dec     c
 43+  C7C1 B9                       cp      c
 44+  C7C2 C2 CD C7                 jp nz,  checkRAMD_2
 45+  C7C5
 46+  C7C5                          ; Сохраняем номер последней страницы RAM-диска
 47+  C7C5 32 F8 8F                 ld     (bios_vars.maxRamPage), a
 48+  C7C8
 49+  C7C8                          ; Это максимум, выходим
 50+  C7C8 FE 0F                    cp      RAMD_MAX_PAGE          ; RAMD_MAX_PAGE не может быть нулем!
 51+  C7CA C2 BC C7                 jp nz,  checkRAMD_1
 52+  C7CD
 53+  C7CD              checkRAMD_2:
 54+  C7CD                          ; Если ДОЗУ найдено, выходим c флагом NZ
 55+  C7CD B7                       or      a
 56+  C7CE C0                       ret nz
 57+  C7CF
 58+  C7CF                          ; В случае ошибки заносим в v_aramPages=0 и выходим с флагом Z
 59+  C7CF 32 F8 8F                 ld      (bios_vars.maxRamPage), a
 60+  C7D2 C9                       ret
 61+  C7D3
108   C7D3
109   C7D3              ;---------------------------------------------------------------------------
110   C7D3              ; Точки входа 0C800h
111   C7D3              ;---------------------------------------------------------------------------
112   C7D3
113   C7D3              	ORG_PAD 0C800h
113   C7D3             >         ; add padding + display warning
113   C7D3             >         IF $ > 0C800h
113   C7D3 ~           >           ; no padding
113   C7D3 ~           >           ASSERT 0
113   C7D3 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
113   C7D3             >         ELSE
113   C7D3             >           ; add padding
113   C7D3 00 00 00... >           BLOCK 0C800h-$
113   C7D7             >         ENDIF
113   C800             >         ORG 0C800h
114   C800              	INCLUDE "jmps_c800.inc"
  1+  C800              ;+---------------------------------------------------------------------------
  2+  C800              ; MXOS
  3+  C800              ; Стандартные точки входа C800
  4+  C800              ;
  5+  C800              ; 2013-12-12 Дизассемблировано vinxru
  6+  C800              ;---------------------------------------------------------------------------
  7+  C800
  8+  C800 C3 A4 C9     j_reboot3:      jp  reboot3         ; C800: Запустить NC.COM
  9+  C803 C3 37 C3     j_getch:        jp  getch           ; C803: Ожидание ввода с клавиатуры
 10+  C806 C3 77 C3     j_tapeRead:     jp  t_tapeRead      ; C806: Чтение байта с магнитофона
 11+  C809 C3 37 C0     j_printChar:    jp  printChar       ; C809: Вывод символа на экран
 12+  C80C C3 7A C3     j_tapeWrite:    jp  t_tapeWrite      ; C80C: Запись байта на магнитофон
 13+  C80F C3 B4 C8                     jp  input           ; C80F: Ввод строки с клавиатуры
 14+  C812 C3 03 C0                     jp  j_keyScan       ; C812: Получить код нажатой клавиши
 15+  C815 C3 94 C8                     jp  printHexByte    ; C815: Вывести 16-ричное число (байт)
 16+  C818 C3 38 C4     j_printString:  jp  printString1    ; C818: Вывести строку на экран
 17+  C81B C3 03 C0                     jp  j_keyScan       ; C81B: Получить код нажатой клавиши
 18+  C81E C3 75 C8                     jp  getCursorPos    ; C81E: Получить координаты курсора в hl (координаты в пикселях)
 19+  C821 C3 72 C8                     jp  setCursorPos    ; C821: Установить координаты курсора из hl (координаты в пикселях)
 20+  C824 C3 7D C3                     jp  t_tapeLoad      ; C824: Загрузить программу с магнитофона
 21+  C827 C3 80 C3                     jp  t_tapeSave      ; C827: Сохранить программу на магнитофон
 22+  C82A C3 8D C9                     jp  calcCS          ; C82A: Расчет контрольной суммы
 23+  C82D C3 89 C8                     jp  printHexWord    ; C82D: Вывести 16-ричное число (слово)
 24+  C830 C3 85 C8                     jp  getMemTop       ; C830: Получить объем доступной памяти
 25+  C833 C3 79 C8                     jp  setMemTop       ; C833: Установить объем доступной памяти
 26+  C836 C3 00 C5                     jp  printer         ; C836: Напечатать байт на принтере
 27+  C839                  IF RAMFOS_COMPATIBILITY
 28+  C839 C3 77 CE                     jp  strToHex        ; C839: [NEW] Преобразвоние строки в HEX формате в число
 29+  C83C                  ELSE
 30+  C83C ~                            jp  j_reboot3       ; C839: Запустить NC.COM
 31+  C83C                  ENDIF
 32+  C83C C3 A4 C9                     jp  reboot3         ; C83C: Запустить NC.COM
 33+  C83F C3 DB CD                     jp  fileList        ; C83F: Получить список файлов
 34+  C842 C3 AD CB                     jp  fileGetSetDrive ; C842: Получить/установить активное устройство
 35+  C845 C3 0A CC                     jp  fileCreate      ; C845: Создать файл
 36+  C848 C3 F9 CC                     jp  fileLoad        ; C848: Загрузить файл по адресу из заголовка этого файла
 37+  C84B C3 4F CD                     jp  fileDelete      ; C84B: Удалить файл
 38+  C84E C3 75 CD                     jp  fileRename      ; C84E: Переименовать файл
 39+  C851 C3 31 CD                     jp  fileLoadInfo    ; C851: Загрузить информацию о файле
 40+  C854 C3 B9 CD                     jp  fileGetSetAddr  ; C854: Получить/установить адрес загрузки файла
 41+  C857 C3 97 CD                     jp  fileGetSetAttr  ; C857: Получить/установить атрибуты файла
 42+  C85A C3 08 CE                     jp  fileNamePrepare ; C85A: Преобразовать имя файла во внутренний формат
 43+  C85D C3 49 CA                     jp  fileExec        ; C85D: Запустить файл
 44+  C860 C3 99 CB                     jp  installDriver   ; C860: Установить драйвер накопителя
 45+  C863 C3 30 CB     j_diskDriver:   jp  diskDriver      ; C863: Драйвер выбранного диска
 46+  C866 C3 EF CC                     jp  fileLoad2       ; C866: Загрузить файл по адресу de
 47+  C869 C3 E6 C5                     jp  printChar_real  ; C869: [NEW] Вывод символа на экран (только реальные символы)
 48+  C86C C3 BC CE                     jp  printDecWord    ; C86C: [NEW] Вывод числа экран в десятичной форме
 49+  C86F C3 CE CA                     jp  setRAMDDriver   ; C86F: [NEW] Установить драйвер доступа к ДОЗУ
 50+  C872
115   C872
116   C872              	INCLUDE "setGetCursorPos.inc"
  1+  C872              ;+---------------------------------------------------------------------------
  2+  C872              ; MXOS
  3+  C872              ; Установить положение курсора
  4+  C872              ;
  5+  C872              ; На входе
  6+  C872              ;  h - координата X в пикселях / 2
  7+  C872              ;  l - координата Y в пикселях
  8+  C872              ;
  9+  C872              ; На выходе
 10+  C872              ;  af, bc, de, hl - Сохраняются
 11+  C872              ;
 12+  C872              ; 2013-12-12 Дизассемблировано vinxru
 13+  C872              ;----------------------------------------------------------------------------
 14+  C872
 15+  C872 22 FC 8F     setCursorPos:     ld    (bios_vars.cursorY), hl
 16+  C875
 17+  C875              ;----------------------------------------------------------------------------
 18+  C875              ; Получить положение курсора
 19+  C875              ;
 20+  C875              ; На выходе
 21+  C875              ;  af, bc, de - Сохраняются
 22+  C875              ;  h - координата X в пикселях / 2
 23+  C875              ;  l - координата Y в пикселях
 24+  C875              ;----------------------------------------------------------------------------
 25+  C875
 26+  C875 2A FC 8F     getCursorPos:     ld    hl, (bios_vars.cursorY)
 27+  C878 C9                       ret
 28+  C879
117   C879              	INCLUDE "setGetMemTop.inc"
  1+  C879              ;+---------------------------------------------------------------------------
  2+  C879              ; MXOS
  3+  C879              ; Установить объем доступной памяти
  4+  C879              ;
  5+  C879              ; На входе
  6+  C879              ;  hl - доступная память. Если меньше 0D000h, то значение не изменяется.
  7+  C879              ;
  8+  C879              ; На выходе
  9+  C879              ;  все регистры сохраняются
 10+  C879              ;
 11+  C879              ; 2013-12-12 Дизассемблировано vinxru
 12+  C879              ;----------------------------------------------------------------------------
 13+  C879
 14+  C879 F5           setMemTop:  push  af
 15+  C87A 7C                       ld    a, h
 16+  C87B FE D0                    cp    0D0h
 17+  C87D DA 83 C8                 jp c, setMemTop_0
 18+  C880 22 54 CF                   ld  (v_memTop), hl
 19+  C883 F1           setMemTop_0:      pop   af
 20+  C884 C9                       ret
 21+  C885
 22+  C885              ;----------------------------------------------------------------------------
 23+  C885              ; Получить объем доступной памяти
 24+  C885              ;
 25+  C885              ; На выходе
 26+  C885              ;  hl - доступная память
 27+  C885              ;
 28+  C885              ; На выходе
 29+  C885              ;  все регистры сохраняются
 30+  C885              ;----------------------------------------------------------------------------
 31+  C885
 32+  C885 2A 54 CF     getMemTop:  ld    hl, (v_memTop)
 33+  C888 C9                       ret
 34+  C889
118   C889              	INCLUDE "printHex.inc"
  1+  C889              ;+---------------------------------------------------------------------------
  2+  C889              ; MXOS
  3+  C889              ; Вывод 16-ричного числа на экран (слово)
  4+  C889              ;
  5+  C889              ; На входе
  6+  C889              ;  hl - число
  7+  C889              ;
  8+  C889              ; На выходе
  9+  C889              ;  все регистры сохраняются
 10+  C889              ;
 11+  C889              ; 2013-12-12 Дизассемблировано vinxru
 12+  C889              ;----------------------------------------------------------------------------
 13+  C889
 14+  C889              printHexWord:     ; Сохраняем регистры
 15+  C889 F5                       push  af
 16+  C88A
 17+  C88A                          ; Старший байт
 18+  C88A 7C                       ld    a, h
 19+  C88B CD 94 C8                 call  printHexByte
 20+  C88E
 21+  C88E                          ; Младшйи байт
 22+  C88E 7D                       ld    a, l
 23+  C88F CD 94 C8                 call  printHexByte
 24+  C892
 25+  C892                          ; Восстаналиваем регистры
 26+  C892 F1                       pop   af
 27+  C893 C9                       ret
 28+  C894
 29+  C894              ;----------------------------------------------------------------------------
 30+  C894              ; Вывод 16-ричного числа на экран (байт)
 31+  C894              ;
 32+  C894              ; На входе
 33+  C894              ;  a - число
 34+  C894              ;
 35+  C894              ; На выходе
 36+  C894              ;  все регистры сохраняются
 37+  C894              ;----------------------------------------------------------------------------
 38+  C894
 39+  C894              printHexByte:     ; Сохраняем регистры
 40+  C894 C5                       push  bc
 41+  C895 F5                       push  af
 42+  C896
 43+  C896                          ; Сохраняем a для вывода второй цифры
 44+  C896 47                       ld    b, a
 45+  C897
 46+  C897                          ; Первая цифра - старшие 4 бита
 47+  C897 07                       rlca
 48+  C898 07                       rlca
 49+  C899 07                       rlca
 50+  C89A 07                       rlca
 51+  C89B CD A5 C8                 call  printHexNibble
 52+  C89E
 53+  C89E                          ; Вторая цифра - младщие 4 бита
 54+  C89E 78                       ld    a, b
 55+  C89F CD A5 C8                 call  printHexNibble
 56+  C8A2
 57+  C8A2                          ; Восстаналиваем регистры
 58+  C8A2 F1                       pop   af
 59+  C8A3 C1                       pop   bc
 60+  C8A4 C9                       ret
 61+  C8A5
 62+  C8A5              ;----------------------------------------------------------------------------
 63+  C8A5              ; Вывод 16-ричного числа на экран (цифра)
 64+  C8A5              ;
 65+  C8A5              ; На входе
 66+  C8A5              ;  a - число, используются младшие 4 бита
 67+  C8A5              ;
 68+  C8A5              ; На выходе
 69+  C8A5              ;  c, a - изменяются, остальные регистры сохраняются
 70+  C8A5              ;----------------------------------------------------------------------------
 71+  C8A5
 72+  C8A5 E6 0F        printHexNibble:   and   0Fh
 73+  C8A7 C6 30                    add   a, '0'
 74+  C8A9 FE 3A                    cp    '9'+1
 75+  C8AB DA B0 C8                 jp c, printHexNib_0
 76+  C8AE C6 07                      add a, 'A'-'0'-10
 77+  C8B0 4F           printHexNib_0:    ld    c, a
 78+  C8B1 C3 09 C8                 jp    j_printChar
 79+  C8B4
119   C8B4              	INCLUDE "input.inc"
  1+  C8B4              ;+---------------------------------------------------------------------------
  2+  C8B4              ; MXOS
  3+  C8B4              ; Ввод строки
  4+  C8B4              ;
  5+  C8B4              ; На входе
  6+  C8B4              ;  hl - начало буфера
  7+  C8B4              ;  de - конец буфера
  8+  C8B4              ;
  9+  C8B4              ; На выходе
 10+  C8B4              ;  bc, de, hl - сохраняются
 11+  C8B4              ;
 12+  C8B4              ; 2013-12-12 Дизассемблировано vinxru
 13+  C8B4              ;----------------------------------------------------------------------------
 14+  C8B4
 15+  C8B4              input:            ; Сохраняем регистры
 16+  C8B4 E5                       push  hl
 17+  C8B5 C5                       push  bc
 18+  C8B6 F5                       push  af
 19+  C8B7
 20+  C8B7                          ; Сохраняем значения
 21+  C8B7 22 4A CF                 ld    (v_input_start), hl
 22+  C8BA EB                       ex    de, hl
 23+  C8BB 22 50 CF                 ld    (v_input_end), hl
 24+  C8BE
 25+  C8BE                          ; Помещаем в конец буфера 0
 26+  C8BE 62                       ld    h, d
 27+  C8BF 6B                       ld    l, e
 28+  C8C0 36 00                    ld  (hl), 0
 29+  C8C2
 30+  C8C2              input_loop: ; Ждем клавиашу
 31+  C8C2 CD 03 C8                 call  j_getch
 32+  C8C5 4F                       ld    c, a
 33+  C8C6
 34+  C8C6                          ; Нажата служебная клавиша
 35+  C8C6 FE 20                    cp    20h
 36+  C8C8 DA 1D C9                 jp c, input_spec
 37+  C8CB
 38+  C8CB                          ; Нажата клавиша Back space
 39+  C8CB FE 7F                    cp    7Fh
 40+  C8CD CA 0C C9                 jp z, input_bkspc
 41+  C8D0
 42+  C8D0                          ; ...
 43+  C8D0 00                       nop
 44+  C8D1 00                       nop
 45+  C8D2 00                       nop
 46+  C8D3
 47+  C8D3                          ; Это конец буфера
 48+  C8D3 E5                       push  hl
 49+  C8D4 2A 50 CF                 ld    hl, (v_input_end)
 50+  C8D7 CD 4F C9                 call  cmp_hl_de_2
 51+  C8DA E1                       pop   hl
 52+  C8DB C2 E7 C8                 jp nz,  loc_C8DE
 53+  C8DE CD 4F C9                 call  cmp_hl_de_2
 54+  C8E1 CA C2 C8                 jp z, input_loop
 55+  C8E4 1A                       ld    a, (de)
 56+  C8E5 1B                       dec   de
 57+  C8E6 12                       ld    (de),a
 58+  C8E7 C5           loc_C8DE:   push  bc
 59+  C8E8 44                       ld    b, h
 60+  C8E9 4D                       ld    c, l
 61+  C8EA 03                       inc   bc
 62+  C8EB CD 5D C9                 call  memmove_bc_hl
 63+  C8EE C1                       pop   bc
 64+  C8EF 71                       ld  (hl), c       ; *hl++     = c;
 65+  C8F0 CD 09 C8                 call  j_printChar ; Вывод     символа     на экран
 66+  C8F3 23                       inc   hl
 67+  C8F4 13                       inc   de
 68+  C8F5 E5           loc_C8EC:   push  hl
 69+  C8F6 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 70+  C8F9 E3                       ex    (sp), hl
 71+  C8FA E5                       push  hl
 72+  C8FB CD 18 C8                 call  j_printString
 73+  C8FE 0E 20                    ld    c, ' '
 74+  C900 CD 09 C8                 call  j_printChar
 75+  C903 E1                       pop   hl
 76+  C904 E3                       ex    (sp), hl
 77+  C905 22 FC 8F                 ld    (bios_vars.cursorY), hl
 78+  C908 E1                       pop   hl
 79+  C909
 80+  C909                          ; Продолжение
 81+  C909 C3 C2 C8                 jp    input_loop
 82+  C90C
 83+  C90C              ; ---------------------------------------------------------------------------
 84+  C90C
 85+  C90C              input_bkspc:      ; Если курсор в начале строки ничего не удаляем
 86+  C90C CD 4F C9                 call  cmp_hl_de_2
 87+  C90F CA C2 C8                 jp z, input_loop
 88+  C912
 89+  C912                          ; Сдвигаем строку
 90+  C912 44                       ld    b, h
 91+  C913 4D                       ld    c, l
 92+  C914 23                       inc   hl
 93+  C915 CD 5D C9                 call  memmove_bc_hl
 94+  C918
 95+  C918                          ; Уменьшаем положение курсора
 96+  C918 2B                       dec   hl
 97+  C919
 98+  C919 1B                       dec   de
 99+  C91A C3 F5 C8                 jp    loc_C8EC
100+  C91D
101+  C91D              ; ---------------------------------------------------------------------------
102+  C91D
103+  C91D              input_spec: ; Нажато влево
104+  C91D FE 08                    cp    8
105+  C91F CA 31 C9                 jp z, input_left
106+  C922
107+  C922                          ; Нажато вправо
108+  C922 FE 18                    cp    18h
109+  C924 CA 45 C9                 jp z, input_right
110+  C927
111+  C927                          ; Нажат не ввод
112+  C927 FE 0D                    cp    0Dh
113+  C929 C2 C2 C8                 jp nz,  input_loop
114+  C92C
115+  C92C                          ; Нажат ввод
116+  C92C
117+  C92C                          ; Сохраняем в конец стрки 0D
118+  C92C 12                       ld    (de),a
119+  C92D
120+  C92D                          ; Восстанавливаем регистры и выходим
121+  C92D F1                       pop   af
122+  C92E C1                       pop   bc
123+  C92F E1                       pop   hl
124+  C930 C9                       ret
125+  C931
126+  C931              ; ---------------------------------------------------------------------------
127+  C931
128+  C931              input_left: ; Если курсор в начале строки (hl==v_input_start) не перемещаем курсор
129+  C931 EB                       ex    de, hl
130+  C932 E5                       push  hl
131+  C933 2A 4A CF                 ld    hl, (v_input_start)
132+  C936 CD 4F C9                 call  cmp_hl_de_2
133+  C939 E1                       pop   hl
134+  C93A EB                       ex    de, hl
135+  C93B CA C2 C8                 jp z, input_loop
136+  C93E
137+  C93E                          ; Уменьшаем положение курсора
138+  C93E 2B                       dec   hl
139+  C93F
140+  C93F              input_lr:   ; Перемещаем курсор вправо/влево
141+  C93F CD 09 C8                 call  j_printChar
142+  C942
143+  C942                          ; Продолжаем ввод
144+  C942 C3 C2 C8                 jp    input_loop
145+  C945
146+  C945              ; ---------------------------------------------------------------------------
147+  C945
148+  C945              input_right:      ; Если курсор в конце строк (hl==de) не перемещаем курсор
149+  C945 CD 4F C9                 call  cmp_hl_de_2
150+  C948 CA C2 C8                 jp z, input_loop
151+  C94B
152+  C94B                          ; Увеличиваем положение курсора
153+  C94B 23                       inc   hl
154+  C94C
155+  C94C                          ; Общее продолжение
156+  C94C C3 3F C9                 jp    input_lr
157+  C94F
120   C94F              	INCLUDE "cmp_hl_de_2.inc"
  1+  C94F              ;+---------------------------------------------------------------------------
  2+  C94F              ; MXOS
  3+  C94F              ; Сравнить hl и de
  4+  C94F              ;
  5+  C94F              ; 2013-12-12 Дизассемблировано vinxru
  6+  C94F              ;----------------------------------------------------------------------------
  7+  C94F
  8+  C94F              cmp_hl_de_2:
  9+  C94F 7C                   ld    a, h
 10+  C950 BA                   cp    d
 11+  C951 D8                   ret   c
 12+  C952 C0                   ret   nz
 13+  C953 7D                   ld    a, l
 14+  C954 BB                   cp    e
 15+  C955 C9                   ret
 16+  C956
121   C956              	INCLUDE "sbb_de_hl_to_hl.inc"
  1+  C956              ;+---------------------------------------------------------------------------
  2+  C956              ; MXOS
  3+  C956              ; hl = de - hl
  4+  C956              ;
  5+  C956              ; 2013-12-12 Дизассемблировано vinxru
  6+  C956              ;----------------------------------------------------------------------------
  7+  C956
  8+  C956              sbb_de_hl_to_hl:
  9+  C956 7B                       ld    a, e
 10+  C957 95                       sub   l
 11+  C958 6F                       ld    l, a
 12+  C959 7A                       ld    a, d
 13+  C95A 9C                       sbc   h
 14+  C95B 67                       ld    h, a
 15+  C95C C9                       ret
 16+  C95D
122   C95D              	INCLUDE "memmove_bc_hl.inc"
  1+  C95D              ;+---------------------------------------------------------------------------
  2+  C95D              ; MXOS
  3+  C95D              ; Копирование накладывающихся блоков памяти (с ошибкой)
  4+  C95D              ;
  5+  C95D              ; На входе
  6+  C95D              ;  hl - откуда
  7+  C95D              ;  de - откуда, конечный адрес не включая
  8+  C95D              ;  bc - куда, с увеличением адресов
  9+  C95D              ;
 10+  C95D              ; 2013-12-12 Дизассемблировано vinxru
 11+  C95D              ;----------------------------------------------------------------------------
 12+  C95D
 13+  C95D              memmove_bc_hl:    ; Сохраняем регистры
 14+  C95D E5                       push  hl
 15+  C95E C5                       push  bc
 16+  C95F D5                       push  de
 17+  C960
 18+  C960                          ; Если b<h или c<l, то
 19+  C960 78                       ld    a, b
 20+  C961 BC                       cp    h
 21+  C962 DA 7F C9                 jp c, memcpy_bc_hl2
 22+  C965                          ; Тут не хватает jnz
 23+  C965 79                       ld    a, c
 24+  C966 BD                       cp    l
 25+  C967 DA 7F C9                 jp c, memcpy_bc_hl2
 26+  C96A
 27+  C96A                          ; bc = bc + de - hl
 28+  C96A E5                       push  hl
 29+  C96B CD 56 C9                 call  sbb_de_hl_to_hl
 30+  C96E 09                       add   hl, bc
 31+  C96F 44                       ld    b, h
 32+  C970 4D                       ld    c, l
 33+  C971 E1                       pop   hl
 34+  C972
 35+  C972              memcpyb_bc_de:    ; Копируем из de в bc с уменьшением адресов, пока hl не равно de
 36+  C972 1A                       ld    a, (de)
 37+  C973 02                       ld    (bc),a
 38+  C974 CD 4F C9                 call  cmp_hl_de_2
 39+  C977 1B                       dec   de
 40+  C978 0B                       dec   bc
 41+  C979 C2 72 C9                 jp nz,  memcpyb_bc_de
 42+  C97C
 43+  C97C                          ; Восстановление регистров и выход
 44+  C97C C3 89 C9                 jp    popDBh_ret2
 45+  C97F
 46+  C97F              ; ---------------------------------------------------------------------------
 47+  C97F
 48+  C97F              memcpy_bc_hl2:    ; Копируем из hl в bc с увеличением адресов, пока hl не равно de
 49+  C97F 7E                       ld  a, (hl)
 50+  C980 02                       ld    (bc),a
 51+  C981 CD 4F C9                 call  cmp_hl_de_2
 52+  C984 23                       inc   hl
 53+  C985 03                       inc   bc
 54+  C986 C2 7F C9                 jp nz,  memcpy_bc_hl2
 55+  C989
 56+  C989              popDBh_ret2:      ; Восстановление регистров и выход
 57+  C989 D1                       pop   de
 58+  C98A C1                       pop   bc
 59+  C98B E1                       pop   hl
 60+  C98C C9                       ret
 61+  C98D
123   C98D              	INCLUDE "calcCS.inc"
  1+  C98D              ;+---------------------------------------------------------------------------
  2+  C98D              ; MXOS
  3+  C98D              ; Расчет контрольной суммы
  4+  C98D              ;
  5+  C98D              ; На входе
  6+  C98D              ;  hl - начальный адрес
  7+  C98D              ;  de - конечный адрес
  8+  C98D              ;
  9+  C98D              ; На выходе
 10+  C98D              ;  bc - контрольная сумма
 11+  C98D              ;
 12+  C98D              ; 2013-12-12 Дизассемблировано vinxru
 13+  C98D              ;----------------------------------------------------------------------------
 14+  C98D
 15+  C98D 01 00 00     calcCS:     ld      bc, 0
 16+  C990 7E           calcCS_1:   ld      a, (hl)
 17+  C991 81                       add     a, c
 18+  C992 4F                       ld      c, a
 19+  C993 F5                       push    af
 20+  C994 CD 4F C9                 call    cmp_hl_de_2
 21+  C997 CA A2 C9                 jp z,   calcCS_2
 22+  C99A F1                       pop     af
 23+  C99B 78                       ld      a, b
 24+  C99C 8E                       ADC     a, (hl)
 25+  C99D 47                       ld      b, a
 26+  C99E 23                       inc     hl
 27+  C99F C3 90 C9                 jp      calcCS_1
 28+  C9A2 F1           calcCS_2:   pop     af
 29+  C9A3 C9                       ret
 30+  C9A4
124   C9A4              	INCLUDE "reboot3.inc"
  1+  C9A4              ;+---------------------------------------------------------------------------
  2+  C9A4              ; MXOS
  3+  C9A4              ; Обновление драйвера по адресу 0FFC0h и запуск NC.COM
  4+  C9A4              ;
  5+  C9A4              ; А так же однократный запуск AUTOEX.BAT, если не нажата клавиша.
  6+  C9A4              ;
  7+  C9A4              ; 2013-12-12 Дизассемблировано vinxru
  8+  C9A4              ;----------------------------------------------------------------------------
  9+  C9A4
 10+  C9A4              reboot3:    ; Инициализация стека
 11+  C9A4 31 C0 FF                 ld      sp, STACK_ADDR
 12+  C9A7
 13+  C9A7                          ; Устанавливаем блочный драйвер
 14+  C9A7 06 00                    ld      b, 0
 15+  C9A9 CD CE CA                 call    setRAMDDriver
 16+  C9AC
 17+  C9AC                          ; Обновляем переменные
 18+  C9AC 21 00 C8                 ld      hl, j_reboot3
 19+  C9AF 22 E1 8F                 ld      (bios_vars.tapeError), hl
 20+  C9B2
 21+  C9B2              reboot3_0:
 22+  C9B2 C3 B5 C9                 jp      reboot3_1
 23+  C9B5
 24+  C9B5              ; -------------------------------------
 25+  C9B5              ; Код ниже будет выполнен лишь один раз после холодной перезагрузки.
 26+  C9B5              ; То есть при теплой перезагрузке он не вызывается.
 27+  C9B5
 28+  C9B5              reboot3_1:
 29+  C9B5                          ; Патчим предыдущую инструкцию - теперь она стала jp reboot3_2
 30+  C9B5 21 EC C9                 ld      hl, reboot3_2
 31+  C9B8 22 B3 C9                 ld      (reboot3_0+1), hl
 32+  C9BB
 33+  C9BB                          ; Устанавливаем побайтовый драйвер
 34+  C9BB 06 01                    ld      b, 1
 35+  C9BD CD CE CA                 call    setRAMDDriver
 36+  C9C0
 37+  C9C0                          ; Если в рам-диске по адресу 0FF00h (последний неполный сектор)
 38+  C9C0                          ; нет специальной метки, значит, не запускали форматирование
 39+  C9C0 21 BF FF                 ld      hl, 0FFBFh      ; адрес в странице
 40+  C9C3 AF                       xor     a               ; 0 страница
 41+  C9C4 CD C0 FF                 call    bios_RAMDRead
 42+  C9C7 79                       ld      a, c            ; считанный байт в c
 43+  C9C8 FE 5A                    cp      5Ah
 44+  C9CA CA DE C9                 jp z,   skipFormat      ; метка есть - пропускаем форматирование
 45+  C9CD
 46+  C9CD                          ; Записываем метку
 47+  C9CD AF                       xor     a               ; 0 страница
 48+  C9CE 0E 5A                    ld      c, 5Ah          ; записываемый байт
 49+  C9D0 CD D0 FF                 call    bios_RAMDWrite
 50+  C9D3
 51+  C9D3                          ; Устанавливаем блочный драйвер
 52+  C9D3 06 00                    ld      b, 0
 53+  C9D5 CD CE CA                 call    setRAMDDriver
 54+  C9D8
 55+  C9D8                          ; Запуск файла "A:FORMAT.BAT"
 56+  C9D8 21 77 CF                 ld      hl, pathFormatBat
 57+  C9DB CD 49 CA                 call    fileExec
 58+  C9DE
 59+  C9DE              skipFormat:
 60+  C9DE                          ; Если нажата клавиша, пропустить запуск A:AUTOEX.BAT
 61+  C9DE 3A E1 FF                 ld      a, (IO_KEYB_B)
 62+  C9E1 E6 02                    and     2
 63+  C9E3 CA EC C9                 jp z,   reboot3_2
 64+  C9E6
 65+  C9E6                          ; Запуск файла A:AUTOEX.BAT
 66+  C9E6 21 6A CF                 ld      hl, pathAutoexecBat
 67+  C9E9 CD 49 CA                 call    fileExec
 68+  C9EC
 69+  C9EC              ; -------------------------------------
 70+  C9EC
 71+  C9EC              reboot3_2:
 72+  C9EC                          ; Запуск файла A:NC.COM
 73+  C9EC 21 61 CF                 ld      hl, pathNcCom
 74+  C9EF CD 49 CA                 call    fileExec
 75+  C9F2
 76+  C9F2                          ; Теплая перезагрузка
 77+  C9F2 C3 00 C8                 jp      j_reboot3
 78+  C9F5
125   C9F5              	INCLUDE "fileExecBat.inc"
  1+  C9F5              ;+---------------------------------------------------------------------------
  2+  C9F5              ; MXOS
  3+  C9F5              ; Запустить BAT файл. Вызывается функцией fileExec
  4+  C9F5              ;
  5+  C9F5              ; 2013-12-12 Дизассемблировано vinxru
  6+  C9F5              ;----------------------------------------------------------------------------
  7+  C9F5
  8+  C9F5              execBat:
  9+  C9F5 D1                       pop   de
 10+  C9F6
 11+  C9F6                          ; Устанавливаем адрес загрузки BAT-файла на diskDirectory (= FC00h)
 12+  C9F6 21 00 FC                 ld      hl, diskDirectory
 13+  C9F9 22 52 CF                 ld      (v_batPtr), hl
 14+  C9FC EB                       ex      de, hl
 15+  C9FD
 16+  C9FD                          ; Изменяем адрес загрузки BAT-файла
 17+  C9FD                          ; TODO: это не работает с ром-диском (A: без поддержки записи). Поэтому
 18+  C9FD                          ; нельзя запустить BAT-файл с диска A:, если его адрес загрузки в каталоге
 19+  C9FD                          ; уже не прошит как FC00h (= &diskDirectory)
 20+  C9FD 21 8D CF                 ld      hl, v_curFileDescr
 21+  CA00 0E 01                    ld      c, 1
 22+  CA02 CD B9 CD                 call    fileGetSetAddr
 23+  CA05 DA AA CA                 jp c,   badCommand
 24+  CA08
 25+  CA08                          ; Сохраняем имя BAT-файла
 26+  CA08 21 8D CF                 ld      hl, v_curFileDescr
 27+  CA0B 11 98 CF                 ld      de, v_curFileDescr + DIR_NAME_LENGTH + 3
 28+  CA0E 01 AD CF                 ld      bc, v_batFileDescr
 29+  CA11 CD 5D C9                 call    memmove_bc_hl
 30+  CA14
 31+  CA14                          ; Сохраняем диск содержащий BAT-файл
 32+  CA14 3A 49 CF                 ld      a, (v_drive)
 33+  CA17 32 1F CA                 ld      (v_batDrive+1), a   ; самомодификация кода
 34+  CA1A
 35+  CA1A                          ; Этот цикл выполняется для каждой строки BAT-файла
 36+  CA1A              execBat_loop:
 37+  CA1A
 38+  CA1A                          ; Сохраняем текущий диск в регистре b
 39+  CA1A 3A 49 CF                 ld  a, (v_drive)
 40+  CA1D 47                       ld   b, a
 41+  CA1E
 42+  CA1E              v_batDrive:
 43+  CA1E                          ; Выбрать диск содержащий BAT файл
 44+  CA1E 3E 01                    ld   a, 1 ; << сюда вместо 1 пишется диск, содержащий BAT файл
 45+  CA20 CD B5 CB                 call fileSelectDrive
 46+  CA23
 47+  CA23                          ; Загрузить BAT-файл в память
 48+  CA23 21 AD CF                 ld  hl, v_batFileDescr
 49+  CA26 CD F9 CC                 call fileLoad
 50+  CA29 2A 52 CF                 ld hl, (v_batPtr)
 51+  CA2C
 52+  CA2C                          ; Сохраняем начало строки
 53+  CA2C 54                       ld    d, h
 54+  CA2D 5D                       ld    e, l
 55+  CA2E
 56+  CA2E                          ; Ищем конец строки
 57+  CA2E              execBat_0:
 58+  CA2E 7E                       ld  a, (hl)
 59+  CA2F 23                       inc   hl
 60+  CA30
 61+  CA30                          ; Найден конец строки, запускаем файл
 62+  CA30 FE 0D                    cp    0Dh
 63+  CA32 CA 3B CA                 jp z, execBat_1
 64+  CA35
 65+  CA35                          ; Конец     файла
 66+  CA35 FE FF                    cp    0FFh
 67+  CA37 C2 2E CA                 jp nz,  execBat_0
 68+  CA3A C9                       ret
 69+  CA3B
 70+  CA3B              ; ---------------------------------------------------------------------------
 71+  CA3B
 72+  CA3B              execBat_1:
 73+  CA3B                          ; Сохраняем указатель
 74+  CA3B 22 52 CF                 ld (v_batPtr), hl
 75+  CA3E
 76+  CA3E                          ; Восстановление активного диска
 77+  CA3E 78                       ld   a, b
 78+  CA3F CD B5 CB                 call fileSelectDrive
 79+  CA42
 80+  CA42                          ; Запустить файл
 81+  CA42 EB                       ex    de, hl
 82+  CA43 CD 49 CA                 call fileExec
 83+  CA46
 84+  CA46 C3 1A CA                 jp execBat_loop
 85+  CA49
126   CA49              	INCLUDE "fileExec.inc"
  1+  CA49              ;+---------------------------------------------------------------------------
  2+  CA49              ; MXOS
  3+  CA49              ; Запустить файл
  4+  CA49              ;
  5+  CA49              ; На входе
  6+  CA49              ;  hl - ком строка в формате [Диск:]файл[ аргументы]
  7+  CA49              ;
  8+  CA49              ; На выходе
  9+  CA49              ;  сf - ошибка
 10+  CA49              ;
 11+  CA49              ; 2013-12-12 Дизассемблировано vinxru
 12+  CA49              ;----------------------------------------------------------------------------
 13+  CA49
 14+  CA49              fileExec:   ; Сюда будем записывать результат
 15+  CA49 11 00 FF                 ld      de, v_cmdLine
 16+  CA4C
 17+  CA4C                          ; Если первый символ меньше пробела, выходим c CF
 18+  CA4C 7E                       ld      a, (hl)
 19+  CA4D FE 20                    cp      ' '
 20+  CA4F DA B0 CA                 jp      c, stc_ret
 21+  CA52
 22+  CA52                          ; Максимальный размер ком строки (+2 терминатора, итого 82h)
 23+  CA52 0E 80                    ld      c, 80h
 24+  CA54
 25+  CA54              fileExec_0: ; Если символ меньше пробела, выходим
 26+  CA54 7E                       ld      a, (hl)
 27+  CA55 FE 20                    cp      20h
 28+  CA57 DA 61 CA                 jp c,   fileExec_1
 29+  CA5A
 30+  CA5A                          ; Копируем симовол из hl в de
 31+  CA5A 12                       ld      (de),a
 32+  CA5B 23                       inc     hl
 33+  CA5C 13                       inc     de
 34+  CA5D
 35+  CA5D                          ; Повторяем 80h раз
 36+  CA5D 0D                       dec     c
 37+  CA5E C2 54 CA                 jp nz,  fileExec_0
 38+  CA61
 39+  CA61              fileExec_1: ; В конец имени помещаем 13, 0
 40+  CA61 3E 0D                    ld      a, 0Dh
 41+  CA63 12                       ld      (de), a
 42+  CA64 13                       inc     de
 43+  CA65 AF                       xor     a
 44+  CA66 12                       ld      (de), a
 45+  CA67
 46+  CA67                          ; Выводим на экран 0Ah
 47+  CA67 CD B2 CA                 call    printCharA
 48+  CA6A
 49+  CA6A                          ; Выводим на экран имя файла
 50+  CA6A 21 00 FF                 ld      hl, v_cmdLine
 51+  CA6D CD 18 C8                 call    j_printString
 52+  CA70
 53+  CA70                          ; Подготовка имени файла
 54+  CA70 21 00 FF                 ld      hl, v_cmdLine
 55+  CA73 11 8D CF                 ld      de, v_curFileDescr
 56+  CA76 CD 08 CE                 call    fileNamePrepare
 57+  CA79
 58+  CA79                          ; Запоминаем в стеке текущий адрес командной строки (начало списка аргументов)
 59+  CA79 E5                       push    hl
 60+  CA7A
 61+  CA7A                          ; Если это BAT файл
 62+  CA7A 11 84 CF                 ld      de, aBat ; "BAT"
 63+  CA7D CD B7 CA                 call    cmpFileExt
 64+  CA80 CA F5 C9                 jp z,   execBat
 65+  CA83
 66+  CA83                          ; Если это COM или EXE файл
 67+  CA83 CD B7 CA                 call    cmpFileExt
 68+  CA86 CA 8F CA                 jp z,   execExeCom
 69+  CA89 CD B7 CA                 call    cmpFileExt
 70+  CA8C C2 A9 CA                 jp nz,  execError
 71+  CA8F
 72+  CA8F              execExeCom:
 73+  CA8F                          ; Вытаскиваем из стека текущий адрес командной строки (начало списка аргументов)
 74+  CA8F D1                       pop     de
 75+  CA90
 76+  CA90                          ; Загрузить файл
 77+  CA90 21 8D CF                 ld      hl, v_curFileDescr
 78+  CA93 CD F9 CC                 call    fileLoad
 79+  CA96 DA AA CA                 jp c,   badCommand
 80+  CA99
 81+  CA99                          ; Адрес командной строки
 82+  CA99 D5                       push    de
 83+  CA9A
 84+  CA9A                          ; Выводим на экран 0Ah
 85+  CA9A                          ;call printCharA
 86+  CA9A
 87+  CA9A                          ; hl = указатель на адрес загрузки (= адрес запуска) файла
 88+  CA9A 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress   ; смещение поля с адресом загрузки
 89+  CA9D 19                       add     hl, de
 90+  CA9E
 91+  CA9E                          ; de = адрес загрузки (= адрес запуска) файла
 92+  CA9E 5E                       ld      e, (hl)
 93+  CA9F 23                       inc     hl
 94+  CAA0 56                       ld      d, (hl)
 95+  CAA1
 96+  CAA1                          ; Адрес возврата
 97+  CAA1 21 A7 CA                 ld      hl, defAppReturn
 98+  CAA4 E3                       ex      (sp), hl
 99+  CAA5
100+  CAA5                          ; Запуск программы (переход на de)
101+  CAA5 EB                       ex      de, hl  ; hl <--> de
102+  CAA6 E9                       jp      (hl)    ; pc <-- hl
103+  CAA7
104+  CAA7              ; ---------------------------------------------------------------------------
105+  CAA7
106+  CAA7              defAppReturn:
107+  CAA7 B7                       or  a
108+  CAA8 C9                       ret
109+  CAA9
110+  CAA9              ; ---------------------------------------------------------------------------
111+  CAA9
112+  CAA9              execError:
113+  CAA9 D1                       pop     de
114+  CAAA              badCommand:
115+  CAAA 21 01 CF                 ld      hl, txtBadCommand; "\nBAD COMMAND or FILE NAME"
116+  CAAD CD 18 C8                 call    j_printString
117+  CAB0              stc_ret:
118+  CAB0 37                       scf
119+  CAB1 C9                       ret
120+  CAB2
121+  CAB2              ; ---------------------------------------------------------------------------
122+  CAB2
123+  CAB2              printCharA:
124+  CAB2 0E 0A                    ld  c, 0Ah
125+  CAB4 C3 09 C8                 jp  j_printChar
126+  CAB7
127   CAB7              	INCLUDE "fileCmpExt.inc"
  1+  CAB7              ;+---------------------------------------------------------------------------
  2+  CAB7              ; MXOS
  3+  CAB7              ; Сранивать расширения файлов
  4+  CAB7              ;
  5+  CAB7              ; На входе
  6+  CAB7              ;  de - адрес расширения 1
  7+  CAB7              ;  v_curFileDescr - имя с расширением 2
  8+  CAB7              ;
  9+  CAB7              ; На выходе
 10+  CAB7              ;  zf=0 - расширения равны
 11+  CAB7              ;  de - de+3
 12+  CAB7              ;
 13+  CAB7              ; 2013-12-12 Дизассемблировано vinxru
 14+  CAB7              ;----------------------------------------------------------------------------
 15+  CAB7
 16+  CAB7              cmpFileExt:
 17+  CAB7                          ; Адрес расширения
 18+  CAB7 21 95 CF                 ld      hl, v_curFileDescr + DIR_NAME_LENGTH
 19+  CABA 01 03 00                 ld      bc, 3   ; Сравниваем 3 символа
 20+  CABD              cmpFileExt_0:
 21+  CABD 1A                       ld      a, (de)
 22+  CABE BE                       cp      (hl)
 23+  CABF C2 C8 CA                 jp nz,  cmpFileExt_1
 24+  CAC2 23                       inc     hl
 25+  CAC3 13                       inc     de
 26+  CAC4 0D                       dec     c
 27+  CAC5 C2 BD CA                 jp nz,  cmpFileExt_0
 28+  CAC8
 29+  CAC8                          ; ZF=1 если равны
 30+  CAC8
 31+  CAC8              cmpFileExt_1:
 32+  CAC8                          ; Делаем так, чтобы de на выходе функции был на 3 больше,
 33+  CAC8                          ; чем на входе в функцию
 34+  CAC8 F5                       push    af
 35+  CAC9 EB                       ex      de, hl
 36+  CACA 09                       add     hl, bc
 37+  CACB EB                       ex      de, hl
 38+  CACC F1                       pop     af
 39+  CACD
 40+  CACD                          ; Выход
 41+  CACD C9                       ret
 42+  CACE
128   CACE              	INCLUDE "driverFFC0.inc"
  1+  CACE              ;+---------------------------------------------------------------------------
  2+  CACE              ; MXOS
  3+  CACE              ; Драйверы диска в ДОЗУ (часть, которая копируется на адрес 0FFC0h)
  4+  CACE              ;
  5+  CACE              ; 2013-12-12 Дизассемблировано и доработано vinxru
  6+  CACE              ; 2022-02-02 Доработано SpaceEngineer
  7+  CACE              ;----------------------------------------------------------------------------
  8+  CACE
  9+  CACE              ;----------------------------------------------------------------------------
 10+  CACE              ; Установить драйвер доступа к ДОЗУ в окно разделяемой памяти
 11+  CACE              ; Специалиста-MX (FFC0h-FFDEh)
 12+  CACE              ;
 13+  CACE              ; вход:
 14+  CACE              ;  b = 0 - установить блочный драйвер, b = 1 - установить побайтовый драйвер
 15+  CACE              ;
 16+  CACE              ; 2022-02-02 SpaceEngineer
 17+  CACE              ;----------------------------------------------------------------------------
 18+  CACE
 19+  CACE              setRAMDDriver:
 20+  CACE E5                       push  hl
 21+  CACF D5                       push  de
 22+  CAD0 C5                       push  bc
 23+  CAD1 F5                       push  af
 24+  CAD2 05                       dec   b
 25+  CAD3 CA DF CA                 jp z, setRAMDDriver_1
 26+  CAD6
 27+  CAD6                          ; Адреса блочного драйвера
 28+  CAD6 21 F0 CA                 ld    hl, driverBlockStart
 29+  CAD9 11 10 CB                 ld    de, driverBlockEnd
 30+  CADC C3 E5 CA                 jp    setRAMDDriver_2
 31+  CADF
 32+  CADF              setRAMDDriver_1:
 33+  CADF                          ; Адреса побайтового драйвера
 34+  CADF 21 10 CB                 ld    hl, driverByteStart
 35+  CAE2 11 30 CB                 ld    de, driverByteEnd
 36+  CAE5
 37+  CAE5                          ; Копируем драйвер на адрес bc = bios_RAMDRead = 0FFC0h
 38+  CAE5              setRAMDDriver_2:
 39+  CAE5 01 C0 FF                 ld    bc, bios_RAMDRead
 40+  CAE8 CD 2D C4                 call  memcpy_bc_hl
 41+  CAEB
 42+  CAEB                          ; Восстанавливаем регистры и выходим
 43+  CAEB F1                       pop   af
 44+  CAEC C1                       pop   bc
 45+  CAED D1                       pop   de
 46+  CAEE E1                       pop   hl
 47+  CAEF C9                       ret
 48+  CAF0
 49+  CAF0              ;----------------------------------------------------------------------------
 50+  CAF0              ; Блочный драйвер, обрабатывает сразу блок 256 байт
 51+  CAF0              ;
 52+  CAF0              ; FFC0h - чтение 256-байтного блока
 53+  CAF0              ;   вход:
 54+  CAF0              ;     c = номер страницы
 55+  CAF0              ;     d = номер блока
 56+  CAF0              ;     e = 0
 57+  CAF0              ;     hl = адрес буфера в памяти
 58+  CAF0              ;
 59+  CAF0              ; FFD0h - запись 256-байтного блока
 60+  CAF0              ;   вход:
 61+  CAF0              ;     c = номер страницы
 62+  CAF0              ;     d = номер блока
 63+  CAF0              ;     e = 0
 64+  CAF0              ;     hl = адрес буфера в памяти
 65+  CAF0              ;
 66+  CAF0              ;----------------------------------------------------------------------------
 67+  CAF0
 68+  CAF0              ; Чтение 256-байтного блока с диска
 69+  CAF0
 70+  CAF0              driverBlockStart: ; копируется на FFC0h
 71+  CAF0 79                       ld      a, c
 72+  CAF1 32 FD FF                 ld      (IO_PAGE_RAMD), a
 73+  CAF4 1A                       ld      a, (de)
 74+  CAF5 32 FC FF                 ld      (IO_PAGE_RAM), a
 75+  CAF8 77                       ld      (hl), a
 76+  CAF9 23                       inc     hl
 77+  CAFA 1C                       inc     e
 78+  CAFB C2 C0 FF                 jp nz,  0FFC0h
 79+  CAFE C9                       ret
 80+  CAFF
 81+  CAFF                          ; осталось места: 1 байт
 82+  CAFF 00                       nop
 83+  CB00
 84+  CB00              ; Запись 256-байтного блока на диск
 85+  CB00
 86+  CB00              driverBlockWrite: ; копируется на FFD0h
 87+  CB00 46                       ld      b, (hl)
 88+  CB01 79                       ld      a, c
 89+  CB02 32 FD FF                 ld      (IO_PAGE_RAMD), a
 90+  CB05 78                       ld      a, b
 91+  CB06 12                       ld      (de), a
 92+  CB07 32 FC FF                 ld      (IO_PAGE_RAM), a
 93+  CB0A 23                       inc     hl
 94+  CB0B 1C                       inc     e
 95+  CB0C C2 D0 FF                 jp nz,  0FFD0h
 96+  CB0F C9                       ret
 97+  CB10
 98+  CB10                          ; осталось места: 0 байт
 99+  CB10
100+  CB10              driverBlockEnd:
101+  CB10
102+  CB10              ;----------------------------------------------------------------------------
103+  CB10              ; Побайтовый драйвер, обрабатывает только 1 байт
104+  CB10              ;
105+  CB10              ; FFC0h - чтение байта
106+  CB10              ;   вход:
107+  CB10              ;     a  = номер страницы
108+  CB10              ;     hl = адрес байта в странице ДОЗУ
109+  CB10              ;   выход:
110+  CB10              ;     c  = считанный байт
111+  CB10              ;
112+  CB10              ; FFD0h - запись байта
113+  CB10              ;   вход:
114+  CB10              ;     a  = номер страницы
115+  CB10              ;     hl = байта в странице ДОЗУ
116+  CB10              ;     c  = записываемый байт
117+  CB10              ;
118+  CB10              ;----------------------------------------------------------------------------
119+  CB10
120+  CB10              driverByteStart: ; копируется на FFC0h
121+  CB10 32 FD FF                 ld      (IO_PAGE_RAMD), a
122+  CB13 4E                       ld      c, (hl)
123+  CB14 32 FC FF                 ld      (IO_PAGE_RAM), a
124+  CB17 C9                       ret
125+  CB18
126+  CB18                          ; осталось места: 8 байт
127+  CB18 00                       nop
128+  CB19 00                       nop
129+  CB1A 00                       nop
130+  CB1B 00                       nop
131+  CB1C 00                       nop
132+  CB1D 00                       nop
133+  CB1E 00                       nop
134+  CB1F 00                       nop
135+  CB20
136+  CB20              driverByteWrite: ; копируется на FFD0h
137+  CB20 32 FD FF                 ld      (IO_PAGE_RAMD), a
138+  CB23 71                       ld      (hl), c
139+  CB24 32 FC FF                 ld      (IO_PAGE_RAM), a
140+  CB27 C9                       ret
141+  CB28
142+  CB28                          ; осталось места: 8 байт
143+  CB28 00                       nop
144+  CB29 00                       nop
145+  CB2A 00                       nop
146+  CB2B 00                       nop
147+  CB2C 00                       nop
148+  CB2D 00                       nop
149+  CB2E 00                       nop
150+  CB2F 00                       nop
151+  CB30
152+  CB30              driverByteEnd:
153+  CB30
154+  CB30              ; ---------------------------------------------------------------------------
155+  CB30
156+  CB30              ; Проверка, что драйверы влезаеют в 32 байта разделяемой памяти Специалиста-MX
157+  CB30
158+  CB30                  IF driverBlockWrite-driverBlockStart+bios_RAMDRead != bios_RAMDWrite
159+  CB30 ~                    ASSERT 0
160+  CB30 ~                    DISPLAY /l, "Error! Block briver entry point FFD0 has been shifted: ", driverBlockWrite-driverBlockStart+bios_RAMDRead, " != 0xFFD0"
161+  CB30                  ENDIF
162+  CB30
163+  CB30                  IF driverByteWrite-driverByteStart+bios_RAMDRead != bios_RAMDWrite
164+  CB30 ~                    ASSERT 0
165+  CB30 ~                    DISPLAY /l, "Error! Byte briver entry point FFD0 has been shifted: ", driverByteWrite-driverByteStart+bios_RAMDRead, " != 0xFFD0"
166+  CB30                  ENDIF
167+  CB30
168+  CB30                  IF driverBlockEnd-driverBlockStart > 32
169+  CB30 ~                    ASSERT 0
170+  CB30 ~                    DISPLAY /d, "Error! Block briver did not fit: ", driverBlockEnd-driverBlockStart, " > 32 bytes"
171+  CB30                  ENDIF
172+  CB30
173+  CB30                  IF driverByteEnd-driverByteStart > 32
174+  CB30 ~                    ASSERT 0
175+  CB30 ~                    DISPLAY /d, "Error! Byte briver did not fit: ", driverByteEnd-driverByteStart, " > 32 bytes"
176+  CB30                  ENDIF
177+  CB30
129   CB30              	INCLUDE "driver.inc"
  1+  CB30              ;+---------------------------------------------------------------------------
  2+  CB30              ; MXOS
  3+  CB30              ; Драйвер диска в ДОЗУ, ПЗУ
  4+  CB30              ;
  5+  CB30              ; Запись 256-байтного блока
  6+  CB30              ;   На входе
  7+  CB30              ;     e = 1
  8+  CB30              ;     d = номер блока
  9+  CB30              ;     hl = адрес буфера в памяти
 10+  CB30              ;   На выходе
 11+  CB30              ;     все регистры сохраняются
 12+  CB30              ;
 13+  CB30              ; Чтение 256-байтного блока
 14+  CB30              ;   На входе
 15+  CB30              ;     e = 2
 16+  CB30              ;     d = номер блока
 17+  CB30              ;     hl = адрес буфера в памяти
 18+  CB30              ;   На выходе
 19+  CB30              ;     все регистры сохраняются
 20+  CB30              ;
 21+  CB30              ; Получение размера накопителя
 22+  CB30              ;   На входе
 23+  CB30              ;     e = 3
 24+  CB30              ;   На выходе
 25+  CB30              ;     a = кол-во секторов на диске (для функции e=0)
 26+  CB30              ;     bc, de, hl - сохраняются
 27+  CB30              ;
 28+  CB30              ; 2013-12-12 Дизассемблировано и доработано vinxru
 29+  CB30              ; 2022-02-02 Доработано SpaceEngineer
 30+  CB30              ;----------------------------------------------------------------------------
 31+  CB30
 32+  CB30                  IF ROM_64K
 33+  CB30              ROM_SIZE  =  0
 34+  CB30                  ELSE
 35+  CB30 ~            ROM_SIZE  =  0C0h
 36+  CB30                  ENDIF
 37+  CB30
 38+  CB30              diskDriver: ; Сохраняем регистры
 39+  CB30 E5                       push    hl
 40+  CB31 C5                       push    bc          ; +1
 41+  CB32 D5                       push    de
 42+  CB33 F5                       push    af
 43+  CB34
 44+  CB34                          ; Заранее загружаем в С активный диск
 45+  CB34 3A 49 CF                 ld      a, (v_drive); +4
 46+  CB37 4F                       ld      c, a        ; +5
 47+  CB38
 48+  CB38                          ; Функция 1 - Запись блока
 49+  CB38 1D                       dec     e
 50+  CB39 CA 8F CB                 jp z,   diskDriver_w
 51+  CB3C
 52+  CB3C                          ; Функция 2 - Чтение блока
 53+  CB3C 1D                       dec     e
 54+  CB3D CA 4C CB                 jp z,   diskDriver_r
 55+  CB40
 56+  CB40                          ; Функция 3 - Получение размера диска
 57+  CB40 F1                       pop     af
 58+  CB41 0C                       inc     c
 59+  CB42 3E 00                    ld      a, ROM_SIZE
 60+  CB44 CA 29 CC                 jp z,   popDBh_ret  ; Восстановливаем регистры и выходим
 61+  CB47 3E FF                    ld      a, 0FFh     ; Размер RAM-диска
 62+  CB49 C3 29 CC                 jp      popDBh_ret  ; Восстановливаем регистры и выходим
 63+  CB4C
 64+  CB4C              ; ---------------------------------------------------------------------------
 65+  CB4C              ; Функция 2 - Чтение блока
 66+  CB4C
 67+  CB4C              diskDriver_r:
 68+  CB4C                          ; Это ROM-диск?
 69+  CB4C B7                       or      a
 70+  CB4D C2 88 CB                 jp nz,  ramDRead ; нет, переходим к драйверу RAM-диска
 71+  CB50
 72+  CB50                  IF ROM_64K
 73+  CB50
 74+  CB50                          ; Это старшая часть ПЗУ?
 75+  CB50 3E 80                    ld      a, 80h
 76+  CB52 AA                       xor     d
 77+  CB53 FA 77 CB                 jp m,   romMXRead; нет переходим к драйверу ROM-диска MX (Специалист-MX2)
 78+  CB56
 79+  CB56                          ; Драйвер ROM-диска STD (Специалист-MX2)
 80+  CB56 57                       ld      d, a
 81+  CB57 13                       inc     de ; пропускаем первые 4 байта в ПЗУ STD (это код перехода на загрузчик)
 82+  CB58 13                       inc     de
 83+  CB59 13                       inc     de
 84+  CB5A 13                       inc     de
 85+  CB5B                          ; Включаем ПЗУ STD (да, надо регистр цвета сбросить для этого)
 86+  CB5B AF                       xor     a
 87+  CB5C 32 F8 FF                 ld      (IO_COLOR), a
 88+  CB5F                          ; Включаем режим STD
 89+  CB5F              romStdReadLoop:
 90+  CB5F 32 FF FF                 ld      (IO_PAGE_STD), a
 91+  CB62                          ; Чтение
 92+  CB62 1A                       ld      a, (de)
 93+  CB63                          ; Включение ОЗУ MX
 94+  CB63 32 FC F7                 ld      (IO_PAGE_RAM-800h),a
 95+  CB66                          ; Запись
 96+  CB66 77                       ld      (hl), a
 97+  CB67 23                       inc     hl
 98+  CB68                          ; Цикл
 99+  CB68 13                       inc     de
100+  CB69 3E 04                    ld      a, 4
101+  CB6B BB                       cp      e
102+  CB6C C2 5F CB                 jp nz,  romStdReadLoop
103+  CB6F
104+  CB6F                          ; Восстаналиваем цвет
105+  CB6F 3E F0                    ld      a, COLOR_BIOS
106+  CB71 32 F8 FF                 ld      (IO_COLOR), a
107+  CB74                          ; Выходим
108+  CB74 C3 8B CB                 jp      popa_adh_ret
109+  CB77
110+  CB77                  ENDIF
111+  CB77
112+  CB77              romMXRead:
113+  CB77              romMXReadDrv:
114+  CB77 79                       ld      a, c    ; номер страницы = 0
115+  CB78              romMXReadLoop:
116+  CB78 32 FE FF                 ld      (IO_PAGE_ROM), a
117+  CB7B 1A                       ld      a, (de)
118+  CB7C 32 FC FF                 ld      (IO_PAGE_RAM), a
119+  CB7F 77                       ld      (hl), a
120+  CB80 23                       inc     hl
121+  CB81 1C                       inc     e
122+  CB82 C2 77 CB                 jp nz,  romMXReadDrv
123+  CB85 C3 8B CB                 jp      popa_adh_ret
124+  CB88
125+  CB88              ramDRead:
126+  CB88                          ; Вызываем драйвер чтения RAM-диска
127+  CB88 CD C0 FF                 call    bios_RAMDRead
128+  CB8B
129+  CB8B              popa_adh_ret:
130+  CB8B                          ; Восстанавливаем регистры и выходим
131+  CB8B F1                       pop     af
132+  CB8C C3 29 CC                 jp      popDBh_ret
133+  CB8F
134+  CB8F              ; ---------------------------------------------------------------------------
135+  CB8F              ; Функция 1 - Запись блока
136+  CB8F
137+  CB8F              diskDriver_w:
138+  CB8F                          ; Это ROM-диск?
139+  CB8F B7                       or      a
140+  CB90 CA 8B CB                 jp z,   popa_adh_ret    ; да, восстанавливаем регистры и выходим
141+  CB93
142+  CB93                          ; Вызываем драйвер чтения RAM-диска
143+  CB93 CD D0 FF                 call    bios_RAMDWrite
144+  CB96
145+  CB96                          ; Восстановливаем регистры и выходим
146+  CB96 C3 8B CB                 jp      popa_adh_ret
147+  CB99
130   CB99              	INCLUDE "installDriver.inc"
  1+  CB99              ;+---------------------------------------------------------------------------
  2+  CB99              ; MXOS
  3+  CB99              ; Установить драйвер устройства
  4+  CB99              ;
  5+  CB99              ; На входе
  6+  CB99              ;  a - диск
  7+  CB99              ;  hl - адрес драйвера
  8+  CB99              ;
  9+  CB99              ; На выходе
 10+  CB99              ;  bc, de, hl - сохраняются
 11+  CB99              ;
 12+  CB99              ; 2013-12-12 Дизассемблировано vinxru
 13+  CB99              ;----------------------------------------------------------------------------
 14+  CB99
 15+  CB99              installDriver:    ; Сохранение регистров
 16+  CB99 D5                       push de
 17+  CB9A E5                       push hl
 18+  CB9B
 19+  CB9B                          ; Максимум дисков
 20+  CB9B E6 07                    and 7
 21+  CB9D
 22+  CB9D                          ; Вычисление адреса в таблице дисков
 23+  CB9D 87                       add   a, a
 24+  CB9E 6F                       ld    l, a
 25+  CB9F 26 00                    ld    h, 0
 26+  CBA1 11 37 CF                 ld    de, v_drives
 27+  CBA4 19                       add   hl, de
 28+  CBA5
 29+  CBA5                          ; Установка драйвера
 30+  CBA5 D1                       pop   de
 31+  CBA6 73                       ld  (hl), e
 32+  CBA7 23                       inc   hl
 33+  CBA8 72                       ld  (hl), d
 34+  CBA9
 35+  CBA9                          ; Восстановление регистров
 36+  CBA9 EB                       ex  de, hl
 37+  CBAA D1                       pop de
 38+  CBAB 0F                       RRCA
 39+  CBAC
 40+  CBAC                          ; Выход
 41+  CBAC C9                       ret
 42+  CBAD
131   CBAD              	INCLUDE "fileGetSetDrive.inc"
  1+  CBAD              ;+---------------------------------------------------------------------------
  2+  CBAD              ; MXOS
  3+  CBAD              ; Получение/установка текущего накопителя.
  4+  CBAD              ; Функция переключает драйвер накопителя при установке.
  5+  CBAD              ;
  6+  CBAD              ; На входе
  7+  CBAD              ;   e  - 0=чтение, 1=установка
  8+  CBAD              ;   a  - накопитель от 0 до 7
  9+  CBAD              ;
 10+  CBAD              ; На выходе
 11+  CBAD              ;   a  - накопитель
 12+  CBAD              ;   bc, de, hl - сохраняются
 13+  CBAD              ;
 14+  CBAD              ; 2013-12-12 Дизассемблировано vinxru
 15+  CBAD              ; 2022-02-02 Доработано SpaceEngineer
 16+  CBAD              ;----------------------------------------------------------------------------
 17+  CBAD
 18+  CBAD              fileGetSetDrive:
 19+  CBAD 1D                       dec     e
 20+  CBAE CA B5 CB                 jp z,   fileSelectDrive
 21+  CBB1 3A 49 CF                 ld      a, (v_drive)
 22+  CBB4 C9                       ret
 23+  CBB5
 24+  CBB5              ; ---------------------------------------------------------------------------
 25+  CBB5
 26+  CBB5              fileSelectDrive:
 27+  CBB5                          ; Максимум устройств - 1
 28+  CBB5 E6 07                    and     7
 29+  CBB7
 30+  CBB7                          ; Сохраняем выбранное устройство
 31+  CBB7 32 49 CF                 ld      (v_drive), a
 32+  CBBA
 33+  CBBA                          ; Пригодится ниже (a = a * 2)
 34+  CBBA 87                       add     a, a
 35+  CBBB
 36+  CBBB                          ; Сохраняем регистры
 37+  CBBB E5                       push    hl
 38+  CBBC D5                       push    de
 39+  CBBD
 40+  CBBD                          ; Получаем точку входа драйвера
 41+  CBBD 6F                       ld      l, a
 42+  CBBE 26 00                    ld      h, 0
 43+  CBC0 11 37 CF                 ld      de, v_drives
 44+  CBC3 19                       add     hl, de
 45+  CBC4 5E                       ld      e, (hl)
 46+  CBC5 23                       inc     hl
 47+  CBC6 56                       ld      d, (hl)
 48+  CBC7 EB                       ex      de, hl
 49+  CBC8
 50+  CBC8                          ; Сохраняем её
 51+  CBC8 22 64 C8                 ld      (j_diskDriver+1), hl
 52+  CBCB
 53+  CBCB                          ; Восстаналвиаем a
 54+  CBCB 0F                       rrca
 55+  CBCC
 56+  CBCC                          ; Восстанавливаем регистры и выходим
 57+  CBCC D1                       pop     de
 58+  CBCD E1                       pop     hl
 59+  CBCE C9                       ret
 60+  CBCF
132   CBCF              	INCLUDE "loadSaveFatDir.inc"
  1+  CBCF              ;+---------------------------------------------------------------------------
  2+  CBCF              ; MXOS
  3+  CBCF              ; Сохранить FAT и корневой каталог на устройство
  4+  CBCF              ;
  5+  CBCF              ; На выходе
  6+  CBCF              ;  регистры bc, de, hl сохраняются
  7+  CBCF              ;
  8+  CBCF              ; 2013-12-12 Дизассемблировано vinxru
  9+  CBCF              ;----------------------------------------------------------------------------
 10+  CBCF
 11+  CBCF              saveFatDir: ; Сохраняем регистры
 12+  CBCF D5                       push    de
 13+  CBD0
 14+  CBD0                          ; Режим - запись
 15+  CBD0 1E 01                    ld      e, 1
 16+  CBD2
 17+  CBD2                          ; Переход к общему коду
 18+  CBD2 C3 D8 CB                 jp      loadFatDir_0
 19+  CBD5
 20+  CBD5              ;----------------------------------------------------------------------------
 21+  CBD5              ; Загрузить FAT и корневой каталог с устройства
 22+  CBD5              ;
 23+  CBD5              ; На выходе
 24+  CBD5              ;  регистры bc, de, hl сохраняются
 25+  CBD5              ;----------------------------------------------------------------------------
 26+  CBD5
 27+  CBD5              loadFatDir: ; Сохраняем регистры
 28+  CBD5 D5                       push    de
 29+  CBD6
 30+  CBD6                          ; Режим - чтение
 31+  CBD6 1E 02                    ld      e, 2
 32+  CBD8
 33+  CBD8              loadFatDir_0:
 34+  CBD8                          ; Сохраняем регистры
 35+  CBD8 E5                       push    hl
 36+  CBD9
 37+  CBD9                          ; Чтение/запись 1024 байт с начала диска в FB00h задом наперед
 38+  CBD9 21 00 FE                 ld      hl, diskDirectoryEnd
 39+  CBDC 16 03                    ld      d, 3        ; Сектор
 40+  CBDE
 41+  CBDE              loadFatDir_1:
 42+  CBDE CD 63 C8                 call    j_diskDriver
 43+  CBE1 25                       dec     h
 44+  CBE2 15                       dec     d
 45+  CBE3 F2 DE CB                 jp p,   loadFatDir_1
 46+  CBE6
 47+  CBE6                          ; Восстанавливаем регистры и выходим
 48+  CBE6 E1                       pop     hl
 49+  CBE7 D1                       pop     de
 50+  CBE8 C9                       ret
 51+  CBE9
133   CBE9              	INCLUDE "fileFindCluster.inc"
  1+  CBE9              ;+---------------------------------------------------------------------------
  2+  CBE9              ; MXOS
  3+  CBE9              ; Поиск свободного кластера
  4+  CBE9              ;
  5+  CBE9              ; На выходе
  6+  CBE9              ;  cf - ошибка
  7+  CBE9              ;  a - кластер
  8+  CBE9              ;  регистры bc, de, hl сохраняются
  9+  CBE9              ;
 10+  CBE9              ; 2013-12-12 Дизассемблировано vinxru
 11+  CBE9              ;----------------------------------------------------------------------------
 12+  CBE9
 13+  CBE9              fileFindClusterFirst:
 14+  CBE9                          ; Сохраняем регистры
 15+  CBE9 E5                       push  hl
 16+  CBEA
 17+  CBEA                          ; Начинаем поиск с первого кластера (первые 4 не используются)
 18+  CBEA 21 04 FB                 ld    hl,  fat + 4
 19+  CBED C3 F4 CB                 jp    fileFindClus_2
 20+  CBF0
 21+  CBF0              ;----------------------------------------------------------------------------
 22+  CBF0              ; Продолжение поиска свободного кластера
 23+  CBF0              ;
 24+  CBF0              ; На выходе
 25+  CBF0              ;  cf - ошибка
 26+  CBF0              ;  a - кластер
 27+  CBF0              ;  регистры bc, de, hl сохраняются
 28+  CBF0              ;----------------------------------------------------------------------------
 29+  CBF0
 30+  CBF0              fileFindClusterNext:
 31+  CBF0                          ; Сохраняем регистры
 32+  CBF0 E5                       push  hl
 33+  CBF1
 34+  CBF1                          ; Начинаем поиск с этого кластера
 35+  CBF1 2A 47 CF                 ld    hl, (v_findCluster)
 36+  CBF4
 37+  CBF4                          ; Ищем свободный кластер
 38+  CBF4                          ; В соответствующей ячейке таблицы FAT должен быть 0
 39+  CBF4 AF           fileFindClus_2:   xor   a
 40+  CBF5 BE           fileFindClus_0:   cp    (hl)
 41+  CBF6 CA 02 CC                 jp z, fileFindClus_1    ; Найден
 42+  CBF9 2C                       inc   l
 43+  CBFA C2 F5 CB                 jp nz,  fileFindClus_0
 44+  CBFD
 45+  CBFD                          ; Восстаналиваем регистры и выходим a=1, CF=1, ZF=0
 46+  CBFD E1                       pop   hl
 47+  CBFE 3E 01                    ld    a, 1
 48+  CC00 37                       scf
 49+  CC01 C9                       ret
 50+  CC02
 51+  CC02              ; ---------------------------------------------------------------------------
 52+  CC02
 53+  CC02              fileFindClus_1:   ; Свобожный кластер найден
 54+  CC02 7D                       ld    a, l
 55+  CC03
 56+  CC03                          ; Устаналиваем ZF=0. Номер кластера не может быть нулевым.
 57+  CC03                          ; В случае ошибки мы то же выходим с ZF=1
 58+  CC03 B7                       or    a
 59+  CC04
 60+  CC04                          ; Для ускорения поиска сохраняем номер следующего кластера в v_findCluster
 61+  CC04 2C                       inc   l
 62+  CC05 22 47 CF                 ld    (v_findCluster), hl
 63+  CC08
 64+  CC08                          ; Восстанавливаем регистры и выходим с CF=0, ZF=0
 65+  CC08 E1                       pop   hl
 66+  CC09 C9                       ret
 67+  CC0A
134   CC0A              	INCLUDE "fileCreate.inc"
  1+  CC0A              ;----------------------------------------------------------------------------
  2+  CC0A              ; MXOS
  3+  CC0A              ; Создать файл
  4+  CC0A              ;
  5+  CC0A              ; На входе
  6+  CC0A              ;  hl - адрес дескриптора файла в формате FAT (имя, фтрибуты, размер и т.д.)
  7+  CC0A              ;
  8+  CC0A              ; На выходе
  9+  CC0A              ;  сf - ошибка
 10+  CC0A              ;
 11+  CC0A              ; 2013-12-12 Дизассемблировано vinxru
 12+  CC0A              ;----------------------------------------------------------------------------
 13+  CC0A
 14+  CC0A              fileCreate: ; Сохраняем регистры
 15+  CC0A E5                       push    hl
 16+  CC0B C5                       push    bc
 17+  CC0C D5                       push    de
 18+  CC0D
 19+  CC0D                          ; Если файл существует, то удаляем его
 20+  CC0D CD B7 CC                 call    fileFind
 21+  CC10 D4 5B CD                 call nc,deleteFileInt
 22+  CC13
 23+  CC13                          ; Сохраняем готовый дескриптор файла
 24+  CC13 E5                       push    hl
 25+  CC14
 26+  CC14                          ; Ищем свободную запись в каталоге
 27+  CC14 21 00 FC                 ld      hl, diskDirectory     ; Адрес каталога
 28+  CC17 11 20 00                 ld      de, DIR_DESCR_SIZE    ; Размер записи в каталоге
 29+  CC1A 06 18                    ld      b,  DIR_MAX_FILES     ; Максимум файлов
 30+  CC1C              fileCreate_0:
 31+  CC1C 7E                       ld      a, (hl)
 32+  CC1D 3C                       inc     a
 33+  CC1E CA 2D CC                 jp z,   fileCreate_1          ; Свободная запись найдена
 34+  CC21 19                       add     hl, de
 35+  CC22 05                       dec     b
 36+  CC23 C2 1C CC                 jp nz,  fileCreate_0
 37+  CC26
 38+  CC26                          ; Свободных записей нет
 39+  CC26
 40+  CC26                          ; Освобождаем стек
 41+  CC26 E1                       pop     hl
 42+  CC27
 43+  CC27                          ; Установка a=0, ZF=1
 44+  CC27 AF                       xor     a
 45+  CC28
 46+  CC28              stc_popDBh_ret:
 47+  CC28                          ; Установка флага CF=1
 48+  CC28 37                       scf
 49+  CC29
 50+  CC29              popDBh_ret: ; Восстановление регистров и выход
 51+  CC29 D1                       pop     de
 52+  CC2A C1                       pop     bc
 53+  CC2B E1                       pop     hl
 54+  CC2C C9                       ret
 55+  CC2D
 56+  CC2D              ; ---------------------------------------------------------------------------
 57+  CC2D              ; Свободная запись найдена
 58+  CC2D
 59+  CC2D              fileCreate_1:
 60+  CC2D                          ; Сохраняем адрес дескриптора создаваемого файла в буфере каталога
 61+  CC2D 22 4C CF                 ld      (v_createdFile), hl
 62+  CC30
 63+  CC30                          ; Копируем в de
 64+  CC30 EB                       ex      de, hl
 65+  CC31
 66+  CC31                          ; Адрес готового дескриптора файла в hl
 67+  CC31 E1                       pop     hl
 68+  CC32
 69+  CC32                          ; Копируем готовый дескриптор файла в каталог (из hl в de)
 70+  CC32 0E 20                    ld      c, DIR_DESCR_SIZE
 71+  CC34              fileCreate_2:
 72+  CC34 7E                       ld      a, (hl)
 73+  CC35 12                       ld      (de),a
 74+  CC36 23                       inc     hl
 75+  CC37 13                       inc     de
 76+  CC38 0D                       dec     c
 77+  CC39 C2 34 CC                 jp nz,  fileCreate_2
 78+  CC3C
 79+  CC3C                          ; Ищем свободный кластер (результат - в A)
 80+  CC3C CD E9 CB                 call    fileFindClusterFirst
 81+  CC3F DA 28 CC                 jp c,   stc_popDBh_ret ; если нет свободных кластеров - выходим с ошибкой
 82+  CC42
 83+  CC42 F5                       push    af
 84+  CC43
 85+  CC43                          ; Сохраняем в каталог адрес первого кластера
 86+  CC43 2A 4C CF                 ld      hl, (v_createdFile)
 87+  CC46 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
 88+  CC49 09                       add     hl, bc  ; hl = адрес поля firstCluster в дескрипторе файла
 89+  CC4A 77                       ld      (hl), a
 90+  CC4B
 91+  CC4B              		    ; Читаем адрес загрузки файла
 92+  CC4B                          ; de = адрес загрузки файла
 93+  CC4B 2A 4C CF                 ld      hl, (v_createdFile)
 94+  CC4E 01 12 00                 ld      bc, FILE_DESCRIPTOR.loadAddress
 95+  CC51 09                       add     hl, bc  ; hl = адрес поля loadAddress (мл. байт) в дескрипторе файла
 96+  CC52 5E                       ld      e, (hl)
 97+  CC53 23                       inc     hl      ; hl = адрес поля loadAddress (ст. байт) в дескрипторе файла
 98+  CC54 56                       ld      d, (hl) ; b = старший байт адреса загрузки
 99+  CC55
100+  CC55                          ; Сохраняем адрес загрузки в переменную v_input_start
101+  CC55 EB                       ex      de, hl
102+  CC56 22 4A CF                 ld      (v_input_start), hl ; v_input_start = адрес загрузки файла
103+  CC59
104+  CC59                          ; Читаем размер файла
105+  CC59                          ; de = размер файла
106+  CC59 2A 4C CF                 ld      hl, (v_createdFile)
107+  CC5C 01 1C 00                 ld      bc, FILE_DESCRIPTOR.size
108+  CC5F 09                       add     hl, bc  ; hl = адрес поля size (мл. байт) в дескрипторе файла
109+  CC60 5E                       ld      e, (hl)
110+  CC61 23                       inc     hl      ; hl = адрес поля size (ст. байт) в дескрипторе файла
111+  CC62 56                       ld      d, (hl)
112+  CC63
113+  CC63                          ; Сохраняем размер файла в переменную v_input_end
114+  CC63 EB                       ex      de, hl
115+  CC64 22 50 CF                 ld      (v_input_end), hl   ; v_input_end = размер файла
116+  CC67
117+  CC67                          ; Подготавливаем необходимые регистры
118+  CC67 44                       ld      b, h        ; b = старший байт размера = количество кластеров файла - 1, т.к. кластер размером 256 байт.
119+  CC68 04                       inc     b           ; b = количество кластеров файла. TODO: это не будет работать с другим размером кластера!
120+  CC69 F1                       pop     af          ; a = первый кластер файла
121+  CC6A 4F                       ld      c, a        ; с = первый кластер файла
122+  CC6B 26 FB                    ld      h, fat>>8   ; h = старший адрес таблицы fat в памяти
123+  CC6D 6F                       ld      l, a        ; hl = указатель на первый кластер файла в таблице fat
124+  CC6E
125+  CC6E C3 77 CC                 jp      writeFirstCluster
126+  CC71
127+  CC71              ; ---------------------------------------------------------------------------
128+  CC71              ; Записываем кластеры файла в таблицу fat в памяти
129+  CC71
130+  CC71              allocClusters:
131+  CC71 CD F0 CB                 call    fileFindClusterNext
132+  CC74 DA 28 CC                 jp c,   stc_popDBh_ret  ; если больше нет свободных кластеров - выходим с ошибкой
133+  CC77              writeFirstCluster:
134+  CC77 77                       ld      (hl), a         ; записываем номер кластера в fat
135+  CC78 6F                       ld      l, a            ; прыгем на следующий кластер (hl = указатель на следующий кластер файла в таблице fat)
136+  CC79 05                       dec     b               ; счётчик записанных кластеров
137+  CC7A C2 71 CC                 jp nz,  allocClusters
138+  CC7D 75                       ld      (hl), l         ; конец, последний кластер файла указывает сам на себя
139+  CC7E
140+  CC7E              ; ---------------------------------------------------------------------------
141+  CC7E              ; Сохраняем файл на диск
142+  CC7E
143+  CC7E 2A 4A CF                 ld      hl, (v_input_start) ;hl = адрес загрузки файла из v_input_start
144+  CC81 06 FB                    ld      b, fat>>8       ; bc = адрес первого кластера файла в таблице fat
145+  CC83 1E 01                    ld      e, 1            ; режим драйвера 1 - запись
146+  CC85              writeFileLoop:
147+  CC85 51                       ld      d, c            ; номер кластера на диске (изначально c = первый кластер файла)
148+  CC86 CD 63 C8                 call    j_diskDriver
149+  CC89 24                       inc     h               ; cледующий блок файла в памяти (!!! TODO: адрес файла обязательно выровнен по 256 байтам?)
150+  CC8A 0A                       ld      a, (bc)         ; a = номер следующего кластера файла из таблицы fat
151+  CC8B B9                       cp      c               ; сравниваем с номером только что записанного кластера
152+  CC8C 4F                       ld      c, a            ; c = номер следующего кластера
153+  CC8D C2 85 CC                 jp nz,  writeFileLoop   ; если номер следующего кластера = номер только что записанного, это был последний
154+  CC90
155+  CC90              ; ---------------------------------------------------------------------------
156+  CC90              ; Расчет однобайтовой контрольной суммы
157+  CC90
158+  CC90 2A 50 CF                 ld      hl, (v_input_end)   ; hl = размер файла - 1 из v_input_end
159+  CC93 23                       inc     hl                  ; hl = размер файла
160+  CC94 EB                       ex      de, hl              ; de = размер файла
161+  CC95 2A 4A CF                 ld      hl, (v_input_start) ; hl = адрес загрузки файла из v_input_start
162+  CC98 06 00                    ld      b, 0                ; тут будет накапливаться сумма
163+  CC9A              fileCreateCRCLoop:
164+  CC9A 7A                       ld      a, d
165+  CC9B B3                       or      e
166+  CC9C CA A7 CC                 jp z,   fileCreateExit      ; если счетчик досчитал до нуля, выходим
167+  CC9F 7E                       ld  a,  (hl)                ; читаем байт файла
168+  CCA0 80                       add     a, b                ; накапливаем сумму
169+  CCA1 47                       ld      b, a
170+  CCA2 23                       inc     hl                  ; следующий байт
171+  CCA3 1B                       dec     de                  ; уменьшаем счетчик
172+  CCA4 C3 9A CC                 jp      fileCreateCRCLoop
173+  CCA7
174+  CCA7              ; ------------------------------------------------------------------------------------------------------------------------
175+  CCA7              ; Сохранение и выход
176+  CCA7
177+  CCA7              fileCreateExit:
178+  CCA7                          ; Сохраняем контрольную сумму в дескриптор файла
179+  CCA7 78                       ld      a, b                ; a = посчитанная контрольная сумма
180+  CCA8 2A 4C CF                 ld      hl, (v_createdFile)
181+  CCAB 01 0C 00                 ld      bc, FILE_DESCRIPTOR.checkSum
182+  CCAE 09                       add     hl, bc              ; hl = адрес поля checkSum в дескрипторе файла
183+  CCAF 77                       ld      (hl), a             ; сохраняем контрльную сумму
184+  CCB0
185+  CCB0 CD CF CB                 call    saveFatDir          ; сохраняем fat и каталог на диск
186+  CCB3 B7                       or      a                   ; выходим с флагом cf = 0
187+  CCB4 C3 29 CC                 jp      popDBh_ret
188+  CCB7
135   CCB7              	INCLUDE "fileFind.inc"
  1+  CCB7              ;+---------------------------------------------------------------------------
  2+  CCB7              ; MXOS
  3+  CCB7              ; Найти файл
  4+  CCB7              ;
  5+  CCB7              ; На входе
  6+  CCB7              ;  hl - имя
  7+  CCB7              ;
  8+  CCB7              ; На выходе
  9+  CCB7              ;  bc, de, hl - сохраняются
 10+  CCB7              ;  cf - ошибка
 11+  CCB7              ;  v_foundedFile - найденный файл
 12+  CCB7              ;
 13+  CCB7              ; 2013-12-12 Дизассемблировано vinxru
 14+  CCB7              ;----------------------------------------------------------------------------
 15+  CCB7
 16+  CCB7              fileFind:   ; Загрузка FAT и корневого каталога в память
 17+  CCB7 CD D5 CB                 call    loadFatDir
 18+  CCBA
 19+  CCBA              fileFind2:  ; Сохраняем регистры
 20+  CCBA C5                       push    bc
 21+  CCBB D5                       push    de
 22+  CCBC
 23+  CCBC                          ; Начало каталога
 24+  CCBC 11 00 FC                 ld      de, diskDirectory
 25+  CCBF
 26+  CCBF                          ; Кол-во файлов в каталоге
 27+  CCBF 06 18                    ld      b, DIR_MAX_FILES
 28+  CCC1
 29+  CCC1              fileFind_loop:    ; Сохраняем адрес начала имени в каталоге и образец
 30+  CCC1 E5                       push    hl
 31+  CCC2 D5                       push    de
 32+  CCC3
 33+  CCC3                          ; Если первый символ имени 0FFh, переходим к следующем файлу
 34+  CCC3 1A                       ld      a, (de)
 35+  CCC4 3C                       inc     a
 36+  CCC5 CA DE CC                 jp z,   fileFind_next
 37+  CCC8
 38+  CCC8                          ; Длина имени + расширения
 39+  CCC8 0E 0B                    ld      c, DIR_NAME_LENGTH + 3
 40+  CCCA
 41+  CCCA              fileFind_name:    ; Если символы не равны, переходим к следующему файлу
 42+  CCCA 1A                       ld      a, (de)
 43+  CCCB BE                       cp      (hl)
 44+  CCCC C2 DE CC                 jp nz,  fileFind_next
 45+  CCCF 23                       inc     hl
 46+  CCD0 13                       inc     de
 47+  CCD1
 48+  CCD1                          ; Цикл
 49+  CCD1 0D                       dec     c
 50+  CCD2 C2 CA CC                 jp nz,  fileFind_name
 51+  CCD5
 52+  CCD5                          ; Сохраняем адрес найденного файла
 53+  CCD5 E1                       pop     hl
 54+  CCD6 22 4E CF                 ld      (v_foundedFile), hl
 55+  CCD9
 56+  CCD9                          ; Восстаналиваем регистры и выходим с CF=0
 57+  CCD9 E1                       pop     hl
 58+  CCDA B7                       or      a     ; х.з.
 59+  CCDB D1                       pop     de
 60+  CCDC C1                       pop     bc
 61+  CCDD C9                       ret
 62+  CCDE
 63+  CCDE              ; ---------------------------------------------------------------------------
 64+  CCDE
 65+  CCDE              fileFind_next:    ; Вычисляем адрес следующего файла
 66+  CCDE D1                       pop   de
 67+  CCDF 21 20 00                 ld    hl, DIR_DESCR_SIZE
 68+  CCE2 19                       add   hl, de
 69+  CCE3 EB                       ex    de, hl
 70+  CCE4
 71+  CCE4                          ; Восстанавливаем образец
 72+  CCE4 E1                       pop   hl
 73+  CCE5
 74+  CCE5                          ; Еще остались файлы?
 75+  CCE5 05                       dec   b
 76+  CCE6 C2 C1 CC                 jp nz,  fileFind_loop
 77+  CCE9
 78+  CCE9                          ; Восстаналиваем регистры и выходим с CF=1 и a=3
 79+  CCE9 D1                       pop   de
 80+  CCEA C1                       pop   bc
 81+  CCEB 3E 03                    ld    a, 3
 82+  CCED 37                       scf
 83+  CCEE C9                       ret
 84+  CCEF
136   CCEF              	INCLUDE "fileLoad.inc"
  1+  CCEF              ;+---------------------------------------------------------------------------
  2+  CCEF              ; MXOS
  3+  CCEF              ; Загрузить файл
  4+  CCEF              ;
  5+  CCEF              ; На входе
  6+  CCEF              ;  hl - имя
  7+  CCEF              ;  de - адрес загрузки
  8+  CCEF              ;
  9+  CCEF              ; На выходе
 10+  CCEF              ;  bc, de, hl - сохраняются
 11+  CCEF              ;  v_foundedFile - найденный файл
 12+  CCEF              ;  cf - ошибка
 13+  CCEF              ;
 14+  CCEF              ; 2013-12-12 Дизассемблировано vinxru
 15+  CCEF              ;----------------------------------------------------------------------------
 16+  CCEF
 17+  CCEF              fileLoad2:  ; Ищем файл с именем в hl
 18+  CCEF
 19+  CCEF                          ; SpaceEngineer: функция fileFind2 пропускает обновление буфера fat и
 20+  CCEF                          ; каталога текущего диска. Из-за этого fileLoad2 некорректно работает
 21+  CCEF                          ; с файлами на ром-диске (A:, без поддержки записи - потому что изменение
 22+  CCEF                          ; адреса загрузки программы сделано несколько костыльно, через патчинг
 23+  CCEF                          ; этого адреса в структуре каталога).
 24+  CCEF                          ; Вызывающая программа могла бы сама вызвать loadFatDir перед вызовом
 25+  CCEF                          ; fileLoad2, но, к сожалению, loadFatDir не числится в списке стандартных
 26+  CCEF                          ; точек вызова.
 27+  CCEF
 28+  CCEF                          ;call    fileFind2
 29+  CCEF CD B7 CC                 call    fileFind
 30+  CCF2 D8                       ret c
 31+  CCF3
 32+  CCF3                          ; Сохранить регистры
 33+  CCF3 E5                       push    hl
 34+  CCF4 C5                       push    bc
 35+  CCF5 D5                       push    de
 36+  CCF6
 37+  CCF6 C3 0A CD                 jp      fileLoadStep2
 38+  CCF9
 39+  CCF9              ;----------------------------------------------------------------------------
 40+  CCF9              ; Загрузить файл по адресу указанному в заголовке
 41+  CCF9              ;
 42+  CCF9              ; На входе
 43+  CCF9              ;  hl - имя
 44+  CCF9              ;
 45+  CCF9              ; На выходе
 46+  CCF9              ;  bc, de, hl - сохраняются
 47+  CCF9              ;  v_foundedFile - найденный файл
 48+  CCF9              ;  cf - ошибка
 49+  CCF9              ;----------------------------------------------------------------------------
 50+  CCF9
 51+  CCF9              fileLoad:   ; Ищем файл с именем в hl
 52+  CCF9 CD B7 CC                 call    fileFind
 53+  CCFC D8                       ret c
 54+  CCFD
 55+  CCFD                          ; Сохраняем регистры
 56+  CCFD E5                       push    hl
 57+  CCFE C5                       push    bc
 58+  CCFF D5                       push    de
 59+  CD00
 60+  CD00                          ; hl = указатель на адрес загрузки
 61+  CD00 2A 4E CF                 ld      hl, (v_foundedFile)
 62+  CD03 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 63+  CD06 19                       add     hl, de
 64+  CD07
 65+  CD07                          ; de = адрес загрузки
 66+  CD07 5E                       ld      e, (hl)
 67+  CD08 23                       inc     hl
 68+  CD09 56                       ld      d, (hl)
 69+  CD0A
 70+  CD0A              fileLoadStep2:
 71+  CD0A                          ; hl = указатель на номер первого кластера файла
 72+  CD0A 2A 4E CF                 ld      hl, (v_foundedFile)
 73+  CD0D 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
 74+  CD10 09                       add     hl, bc
 75+  CD11
 76+  CD11                          ; a = первый кластер файла
 77+  CD11 7E                       ld      a, (hl)
 78+  CD12
 79+  CD12                          ; hl = указатель на длину найденного файла
 80+  CD12 2A 4E CF                 ld      hl, (v_foundedFile)
 81+  CD15 01 1D 00                 ld      bc, FILE_DESCRIPTOR.size + 1
 82+  CD18 09                       add     hl, bc
 83+  CD19
 84+  CD19                          ; b = размер файла в кластерах. Просто читаем старший байт
 85+  CD19                          ; размера, т.к. кластер размером 256 байт.
 86+  CD19                          ; TODO: это не будет работать с другим размером кластера!
 87+  CD19 46                       ld      b, (hl)
 88+  CD1A 04                       inc     b
 89+  CD1B
 90+  CD1B                          ; hl = адрес загрузки
 91+  CD1B EB                       ex      de, hl
 92+  CD1C
 93+  CD1C              fileLoadLoop:
 94+  CD1C                          ; Читаем кластер в память
 95+  CD1C 1E 02                    ld      e, 2        ; Чтение
 96+  CD1E 57                       ld      d, a        ; Кластер
 97+  CD1F CD 63 C8                 call    j_diskDriver
 98+  CD22
 99+  CD22                          ; Следующий кластер
100+  CD22 24                       inc     h
101+  CD23 5A                       ld      e, d
102+  CD24 16 FB                    ld      d, fat>>8 ; адрес таблицы fat в памяти
103+  CD26 1A                       ld      a, (de)
104+  CD27
105+  CD27                          ; Цикл
106+  CD27 05                       dec     b
107+  CD28 C2 1C CD                 jp nz,  fileLoadLoop
108+  CD2B
109+  CD2B                          ; Восстанавливаем регистры
110+  CD2B D1                       pop     de
111+  CD2C C1                       pop     bc
112+  CD2D E1                       pop     hl
113+  CD2E
114+  CD2E C3 35 CD                 jp      fileLoadExit
115+  CD31
116+  CD31              ; ---------------------------------------------------------------------------
117+  CD31
118+  CD31              fileLoadInfo:
119+  CD31                          ; Ищем файл с именем в hl
120+  CD31 CD B7 CC                 call    fileFind
121+  CD34 D8                       ret c
122+  CD35
123+  CD35              fileLoadExit:
124+  CD35                          ; Сохраняем регистры
125+  CD35 E5                       push    hl
126+  CD36 C5                       push    bc
127+  CD37 D5                       push    de
128+  CD38
129+  CD38                          ; de = указатель на первое поле после расширения
130+  CD38 01 0B 00                 ld      bc, FILE_DESCRIPTOR.ext + 3
131+  CD3B 09                       add     hl, bc
132+  CD3C EB                       ex      de, hl
133+  CD3D
134+  CD3D                          ; Информация о файле, исключая имя
135+  CD3D 2A 4E CF                 ld      hl, (v_foundedFile)
136+  CD40 09                       add     hl, bc
137+  CD41
138+  CD41                          ; Копируем дескриптор из hl в de, исключая имя и расширение
139+  CD41 06 15                    ld      b, DIR_DESCR_SIZE - DIR_NAME_LENGTH - 3
140+  CD43              fileLoadCDLoop:
141+  CD43 7E                       ld      a, (hl)
142+  CD44 12                       ld      (de),a
143+  CD45 23                       inc     hl
144+  CD46 13                       inc     de
145+  CD47 05                       dec     b
146+  CD48 C2 43 CD                 jp nz,  fileLoadCDLoop
147+  CD4B
148+  CD4B                          ; Выход CF=0
149+  CD4B B7                       or      a
150+  CD4C C3 29 CC                 jp      popDBh_ret
151+  CD4F
137   CD4F              	INCLUDE "fileDelete.inc"
  1+  CD4F              ;+---------------------------------------------------------------------------
  2+  CD4F              ; MXOS
  3+  CD4F              ; Удаление файла
  4+  CD4F              ;
  5+  CD4F              ; На входе
  6+  CD4F              ;  hl - имя файла
  7+  CD4F              ;
  8+  CD4F              ; На выходе
  9+  CD4F              ;  cf - ошибка
 10+  CD4F              ;  bc, de, hl - сохраняются
 11+  CD4F              ;
 12+  CD4F              ; 2013-12-12 Дизассемблировано vinxru
 13+  CD4F              ;----------------------------------------------------------------------------
 14+  CD4F
 15+  CD4F              fileDelete: ; Найти файл с именем из hl
 16+  CD4F CD B7 CC                 call  fileFind
 17+  CD52 D8                       ret c
 18+  CD53
 19+  CD53                          ; Удалить файл
 20+  CD53 CD 5B CD                 call  deleteFileInt
 21+  CD56
 22+  CD56                          ; Сохранить изменения на диск
 23+  CD56 CD CF CB                 call  saveFatDir
 24+  CD59
 25+  CD59                          ; Результат
 26+  CD59 B7                       or    a
 27+  CD5A C9                       ret
 28+  CD5B
 29+  CD5B              ; ---------------------------------------------------------------------------
 30+  CD5B
 31+  CD5B              deleteFileInt:    ; Сохраняем регистры
 32+  CD5B E5                       push  hl
 33+  CD5C C5                       push  bc
 34+  CD5D D5                       push  de
 35+  CD5E
 36+  CD5E                          ; Помечаем файл, как удаленный заменяя его первую букву на FF
 37+  CD5E 2A 4E CF                 ld    hl, (v_foundedFile)
 38+  CD61 36 FF                    ld  (hl), 0FFh
 39+  CD63
 40+  CD63                          ; Получаем первый кластер файла в a
 41+  CD63 11 1A 00                 ld    de, FILE_DESCRIPTOR.firstCluster
 42+  CD66 19                       add   hl, de
 43+  CD67 7E                       ld  a, (hl)
 44+  CD68
 45+  CD68                          ; Адрес таблицы FAT
 46+  CD68 26 FB                    ld    h, fat>>8
 47+  CD6A
 48+  CD6A              deleteFileIn_0:   ; Получаем следующий кластер в А
 49+  CD6A 6F                       ld    l, a
 50+  CD6B 7E                       ld  a, (hl)
 51+  CD6C
 52+  CD6C                          ; А этот помечаем не занятым
 53+  CD6C 36 00                    ld  (hl), 0
 54+  CD6E
 55+  CD6E                          ; Если это был не последний кластер, продолжаем.
 56+  CD6E BD                       cp    l
 57+  CD6F C2 6A CD                 jp nz,  deleteFileIn_0
 58+  CD72
 59+  CD72                          ; Восстаналиваем регистры и выходим
 60+  CD72 C3 29 CC                 jp    popDBh_ret
 61+  CD75
138   CD75              	INCLUDE "fileRename.inc"
  1+  CD75              ;+---------------------------------------------------------------------------
  2+  CD75              ; MXOS
  3+  CD75              ; Переименовать файл
  4+  CD75              ;
  5+  CD75              ; На входе
  6+  CD75              ;  hl - исходное имя
  7+  CD75              ;  de - новое имя
  8+  CD75              ;
  9+  CD75              ; На выходе
 10+  CD75              ;  cf - ошибка
 11+  CD75              ;  bc, de, hl - сохраняются
 12+  CD75              ;
 13+  CD75              ; 2013-12-12 Дизассемблировано vinxru
 14+  CD75              ;----------------------------------------------------------------------------
 15+  CD75
 16+  CD75              fileRename: ; Найти файл с именем из hl
 17+  CD75 CD B7 CC                 call    fileFind
 18+  CD78 D8                       ret c
 19+  CD79
 20+  CD79                          ; Сохранить регистры
 21+  CD79 E5                       push    hl
 22+  CD7A C5                       push    bc
 23+  CD7B D5                       push    de
 24+  CD7C
 25+  CD7C                          ;
 26+  CD7C 2A 4E CF                 ld      hl, (v_foundedFile)
 27+  CD7F
 28+  CD7F                          ; Попытаться найти файл с новым именем
 29+  CD7F EB                       ex      de, hl
 30+  CD80 CD BA CC                 call    fileFind2
 31+  CD83
 32+  CD83                          ; Если такой файл есть, то удалить
 33+  CD83 D4 5B CD                 call nc,deleteFileInt
 34+  CD86
 35+  CD86                          ; Заменяем имя
 36+  CD86 0E 0B                    ld      c, DIR_NAME_LENGTH + 3
 37+  CD88 7E           loc_CD2C:   ld      a, (hl)
 38+  CD89 12                       ld      (de),a
 39+  CD8A 23                       inc     hl
 40+  CD8B 13                       inc     de
 41+  CD8C 0D                       dec     c
 42+  CD8D C2 88 CD                 jp nz,  loc_CD2C
 43+  CD90
 44+  CD90                          ; Сохраняем изменения
 45+  CD90 CD CF CB                 call    saveFatDir
 46+  CD93
 47+  CD93                          ; Выход
 48+  CD93 B7                       or      a
 49+  CD94 C3 29 CC                 jp      popDBh_ret
 50+  CD97
139   CD97              	INCLUDE "fileGetSetAttr.inc"
  1+  CD97              ;+---------------------------------------------------------------------------
  2+  CD97              ; MXOS
  3+  CD97              ; Получение/изменение атрибутов файла
  4+  CD97              ;
  5+  CD97              ; На входе
  6+  CD97              ;   hl - имя файла
  7+  CD97              ;   с  - 0=чтение, 1=изменение
  8+  CD97              ;   b  - новые атрибуты (если c==1)
  9+  CD97              ;
 10+  CD97              ; На выходе
 11+  CD97              ;   cf - ошибка
 12+  CD97              ;   a  - атрибуты
 13+  CD97              ;   bc, de, hl - сохраняются
 14+  CD97              ;
 15+  CD97              ; 2013-12-12 Дизассемблировано vinxru
 16+  CD97              ; 2022-01-31 Доработано SpaceEngineer
 17+  CD97              ;----------------------------------------------------------------------------
 18+  CD97
 19+  CD97              fileGetSetAttr:
 20+  CD97 C5                       push    bc
 21+  CD98 47                       ld      b, a
 22+  CD99
 23+  CD99                          ; Ищем файл с именем в hl. Если найден, то переходим
 24+  CD99 CD B7 CC                 call    fileFind
 25+  CD9C D2 A1 CD                 jp nc,  fileGetSetAt_0
 26+  CD9F
 27+  CD9F                          ; Ошибка, выходим
 28+  CD9F C1                       pop     bc
 29+  CDA0 C9                       ret
 30+  CDA1
 31+  CDA1              ; ---------------------------------------------------------------------------
 32+  CDA1
 33+  CDA1              fileGetSetAt_0:
 34+  CDA1 E5                       push    hl
 35+  CDA2
 36+  CDA2                          ; Получаем адрес байта атрибутов
 37+  CDA2 D5                       push    de
 38+  CDA3 2A 4E CF                 ld      hl, (v_foundedFile)
 39+  CDA6 11 0B 00                 ld      de, FILE_DESCRIPTOR.attrib
 40+  CDA9 19                       add     hl, de
 41+  CDAA D1                       pop     de
 42+  CDAB
 43+  CDAB                          ; Проверяем режим
 44+  CDAB 79                       ld      a, c
 45+  CDAC 0D                       dec     c ; ZF=1 если режим 1
 46+  CDAD C2 B1 CD                 jp nz,  fileGetSetAt_1
 47+  CDB0
 48+  CDB0                          ; Устанавливаем атрибуты
 49+  CDB0 70                       ld      (hl), b
 50+  CDB1
 51+  CDB1              fileGetSetAt_1:
 52+  CDB1                          ; Читаем атрибуты
 53+  CDB1 7E                       ld      a, (hl)
 54+  CDB2
 55+  CDB2                          ; Сохраняем изменения (хотя для чтения это не нужно делать)
 56+  CDB2 CD CF CB                 call    saveFatDir
 57+  CDB5
 58+  CDB5                          ; Восстанавливаем регистры и выходим ;! А тут точно CF==0 будет?
 59+  CDB5 B7                       or      a
 60+  CDB6 E1                       pop     hl
 61+  CDB7 C1                       pop     bc
 62+  CDB8 C9                       ret
 63+  CDB9
140   CDB9              	INCLUDE "fileGetSetAddr.inc"
  1+  CDB9              ;+---------------------------------------------------------------------------
  2+  CDB9              ; MXOS
  3+  CDB9              ; Получение/изменение адреса загрузки файла
  4+  CDB9              ;
  5+  CDB9              ; На входе
  6+  CDB9              ;   hl - имя файла
  7+  CDB9              ;   с  - 0=чтение, 1=изменение
  8+  CDB9              ;   de - адрес
  9+  CDB9              ;
 10+  CDB9              ; На выходе
 11+  CDB9              ;   de - адрес
 12+  CDB9              ;   bc, hl - сохраняются
 13+  CDB9              ;
 14+  CDB9              ; 2013-12-12 Дизассемблировано vinxru
 15+  CDB9              ; 2022-01-31 Доработано SpaceEngineer
 16+  CDB9              ;----------------------------------------------------------------------------
 17+  CDB9
 18+  CDB9              fileGetSetAddr:   ; Ищем файл с именем в hl
 19+  CDB9 CD B7 CC                 call    fileFind
 20+  CDBC D8                       ret c
 21+  CDBD
 22+  CDBD E5                       push    hl
 23+  CDBE
 24+  CDBE                          ; Получаем адрес длины файла
 25+  CDBE D5                       push    de
 26+  CDBF 2A 4E CF                 ld      hl, (v_foundedFile)
 27+  CDC2 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 28+  CDC5 19                       add     hl, de
 29+  CDC6 D1                       pop     de
 30+  CDC7
 31+  CDC7                          ; Проверяем режим
 32+  CDC7 79                       ld      a, c
 33+  CDC8 0D                       dec     c ; ZF=1 если режим 1
 34+  CDC9 C2 D5 CD                 jp nz,  fileGetSetAd_0
 35+  CDCC
 36+  CDCC                          ; Заменяем адрес загрузки
 37+  CDCC 73                       ld      (hl), e
 38+  CDCD 23                       inc     hl
 39+  CDCE 72                       ld      (hl), d
 40+  CDCF
 41+  CDCF                          ; Сохраняем изменения
 42+  CDCF CD CF CB                 call    saveFatDir
 43+  CDD2
 44+  CDD2                          ; Выходим
 45+  CDD2 E1                       pop     hl
 46+  CDD3 B7                       or      a
 47+  CDD4 C9                       ret
 48+  CDD5
 49+  CDD5              fileGetSetAd_0:
 50+  CDD5                          ; Читаем адрес загрузки
 51+  CDD5 5E                       ld      e, (hl)
 52+  CDD6 23                       inc     hl
 53+  CDD7 56                       ld      d, (hl)
 54+  CDD8
 55+  CDD8                          ; Выходим
 56+  CDD8 E1                       pop     hl
 57+  CDD9 B7                       or      a
 58+  CDDA C9                       ret
 59+  CDDB
141   CDDB              	INCLUDE "fileGetInfoAddr.inc"
  1+  CDDB              ;+---------------------------------------------------------------------------
  2+  CDDB              ; MXOS
  3+  CDDB              ; Получить указатель на информацию о a==1
  4+  CDDB              ;
  5+  CDDB              ; На входе
  6+  CDDB              ;   c - любое число
  7+  CDDB              ;
  8+  CDDB              ; На выходе
  9+  CDDB              ;   b, de - сохраняются
 10+  CDDB              ;   hl - указатель на дескриптор после расширения
 11+  CDDB              ;   zf - если a==1
 12+  CDDB              ;   a = c
 13+  CDDB              ;   c = c-1
 14+  CDDB              ;
 15+  CDDB              ; 2013-12-12 Дизассемблировано vinxru
 16+  CDDB              ;----------------------------------------------------------------------------
 17+  CDDB
 18+  CDDB              ;fileGetInfoAddr:
 19+  CDDB              ;            push de
 20+  CDDB              ;
 21+  CDDB              ;            ; Помещаем в hl адрес информации о файле
 22+  CDDB              ;            ld    hl, (v_foundedFile)
 23+  CDDB              ;            ld    de, FILE_DESCRIPTOR.attrib
 24+  CDDB              ;            add   scf
 25+  CDDB              ;
 26+  CDDB              ;            ; Помещаем в a режим
 27+  CDDB              ;            ld    a, c
 28+  CDDB              ;
 29+  CDDB              ;            ; ZF=1 если режим 1
 30+  CDDB              ;            dec c
 31+  CDDB              ;
 32+  CDDB              ;            pop de
 33+  CDDB              ;            ret
 34+  CDDB              ;
 35+  CDDB
142   CDDB              	INCLUDE "fileList.inc"
  1+  CDDB              ;+---------------------------------------------------------------------------
  2+  CDDB              ; MXOS
  3+  CDDB              ; Получить список файлов
  4+  CDDB              ;
  5+  CDDB              ; На входе
  6+  CDDB              ;  hl - адрес буфера (769 байт)
  7+  CDDB              ;
  8+  CDDB              ; На выходе
  9+  CDDB              ;  bc, de, hl - сохраняются
 10+  CDDB              ;
 11+  CDDB              ; 2013-12-12 Дизассемблировано vinxru
 12+  CDDB              ;----------------------------------------------------------------------------
 13+  CDDB
 14+  CDDB              fileList:   ; Загрузка FAT и каталога
 15+  CDDB CD D5 CB                 call    loadFatDir
 16+  CDDE
 17+  CDDE                          ; Сохранение регистров
 18+  CDDE E5                       push    hl
 19+  CDDF C5                       push    bc
 20+  CDE0 D5                       push    de
 21+  CDE1
 22+  CDE1                          ; Максимум файлов
 23+  CDE1 06 18                    ld      b, DIR_MAX_FILES
 24+  CDE3
 25+  CDE3                          ; Адрес первого файла
 26+  CDE3 11 00 FC                 ld      de, diskDirectory
 27+  CDE6
 28+  CDE6              fileList_loop:    ; Если первый символ не FFh, копируем описатель
 29+  CDE6 1A                       ld      a, (de)
 30+  CDE7 3C                       inc     a
 31+  CDE8 C2 FB CD                 jp nz,  fileList_copy
 32+  CDEB
 33+  CDEB                          ; Вычисляем адрес следующего файла
 34+  CDEB E5                       push    hl
 35+  CDEC 21 20 00                 ld      hl, DIR_DESCR_SIZE
 36+  CDEF 19                       add     hl, de
 37+  CDF0 EB                       ex      de, hl
 38+  CDF1 E1                       pop     hl
 39+  CDF2
 40+  CDF2              fileList_next:    ; Цикл
 41+  CDF2 05                       dec     b
 42+  CDF3 C2 E6 CD                 jp nz,  fileList_loop
 43+  CDF6
 44+  CDF6                          ; В конце символ 0FFh
 45+  CDF6 36 FF                    ld      (hl), 0FFh
 46+  CDF8 C3 29 CC                 jp      popDBh_ret
 47+  CDFB
 48+  CDFB              ; ---------------------------------------------------------------------------
 49+  CDFB
 50+  CDFB              fileList_copy:    ; Копируем DIR_DESCR_SIZE байт из de в hl
 51+  CDFB 0E 20                    ld      c, DIR_DESCR_SIZE
 52+  CDFD 1A           fileList_copyl:     ld    a, (de)
 53+  CDFE 77                       ld      (hl), a
 54+  CDFF 23                       inc     hl
 55+  CE00 13                       inc     de
 56+  CE01 0D                       dec     c
 57+  CE02 C2 FD CD                 jp nz,  fileList_copyl
 58+  CE05 C3 F2 CD                 jp      fileList_next
 59+  CE08
143   CE08              	INCLUDE "fileNamePrepare.inc"
  1+  CE08              ;+---------------------------------------------------------------------------
  2+  CE08              ; MXOS
  3+  CE08              ; Подготовить имя файла для функций ОС
  4+  CE08              ;
  5+  CE08              ; На входе
  6+  CE08              ;  hl - исходное имя
  7+  CE08              ;  de - буфер для результата (P_INPUT_WIDTH + 3 байт)
  8+  CE08              ;
  9+  CE08              ; 2013-12-12 Дизассемблировано vinxru
 10+  CE08              ;----------------------------------------------------------------------------
 11+  CE08
 12+  CE08              fileNamePrepare:
 13+  CE08                          ; Сохраняем регистры
 14+  CE08 C5                       push    bc
 15+  CE09 D5                       push    de
 16+  CE0A
 17+  CE0A                          ; Если второй символ исходной строки ':', то меняем диск
 18+  CE0A 23                       inc     hl
 19+  CE0B 7E                       ld      a, (hl)
 20+  CE0C FE 3A                    cp      ':'
 21+  CE0E 2B                       dec     hl
 22+  CE0F C2 1A CE                 jp nz,  fileNamePr_1
 23+  CE12
 24+  CE12                          ; Меняем диск
 25+  CE12 7E                       ld      a, (hl)
 26+  CE13 D6 41                    sub     'A'
 27+  CE15 CD B5 CB                 call    fileSelectDrive
 28+  CE18
 29+  CE18                          ; Диск не входит в имя файла
 30+  CE18 23                       inc     hl
 31+  CE19 23                       inc     hl
 32+  CE1A
 33+  CE1A              fileNamePr_1:
 34+  CE1A                          ; b = длина имени, c = 3 - длина расширения
 35+  CE1A 01 03 08                 ld      bc, (DIR_NAME_LENGTH << 8) + 3
 36+  CE1D
 37+  CE1D                          ; Копируем текст до точки, пробела или конца строки, не более DIR_NAME_LENGTH символов.
 38+  CE1D              fileNamePr_2:
 39+  CE1D 7E                       ld      a, (hl)
 40+  CE1E A7                       and     a
 41+  CE1F F2 24 CE                 jp p,   fileNamePr_3
 42+  CE22 D6 40                    sub     40h         ; проеобразование KOI?
 43+  CE24              fileNamePr_3:
 44+  CE24 FE 21                    cp      ' '+1
 45+  CE26 DA 44 CE                 jp c,   fileNamePr_5
 46+  CE29 23                       inc     hl
 47+  CE2A FE 2E                    cp      '.'
 48+  CE2C CA 44 CE                 jp z,   fileNamePr_5
 49+  CE2F 12                       ld      (de), a
 50+  CE30 13                       inc     de
 51+  CE31 05                       dec     b
 52+  CE32 C2 1D CE                 jp nz,  fileNamePr_2
 53+  CE35
 54+  CE35                          ; Пропускаем текст до точки, пробела или конца строки
 55+  CE35              fileNamePr_4:
 56+  CE35 7E                       ld      a, (hl)
 57+  CE36 FE 21                    cp      ' '+1
 58+  CE38 DA 47 CE                 jp c,   fileNamePr_6
 59+  CE3B 23                       inc     hl
 60+  CE3C FE 2E                    cp      '.'
 61+  CE3E C2 35 CE                 jp nz,  fileNamePr_4
 62+  CE41 C3 47 CE                 jp      fileNamePr_6
 63+  CE44
 64+  CE44              ; ---------------------------------------------------------------------------
 65+  CE44
 66+  CE44              fileNamePr_5:
 67+  CE44                          ; Имя короче DIR_NAME_LENGTH символов
 68+  CE44                          ; Заполняем недостающие символы имени пробелами
 69+  CE44 CD 6E CE                 call    memset_de_20_b
 70+  CE47
 71+  CE47                          ; Копируем текст до пробела или конца строки, не более 3 символов.
 72+  CE47              fileNamePr_6:
 73+  CE47 7E                       ld      a, (hl)
 74+  CE48 A7                       and     a
 75+  CE49 F2 4E CE                 jp p,   fileNamePr_7
 76+  CE4C D6 40                    sub     40h         ; проеобразование KOI?
 77+  CE4E              fileNamePr_7:
 78+  CE4E FE 21                    cp      ' '+1
 79+  CE50 DA 67 CE                 jp c,   fileNamePr_11
 80+  CE53 12                       ld      (de),a
 81+  CE54 23                       inc     hl
 82+  CE55 13                       inc     de
 83+  CE56 0D                       dec     c
 84+  CE57 C2 47 CE                 jp nz,  fileNamePr_6
 85+  CE5A
 86+  CE5A              fileNamePr_8:
 87+  CE5A                          ; Пропускаем текст до пробела или конца строки
 88+  CE5A 7E                       ld      a, (hl)
 89+  CE5B FE 20                    cp      ' '
 90+  CE5D DA 64 CE                 jp c,   fileNamePr_10
 91+  CE60 23                       inc     hl
 92+  CE61 C2 5A CE                 jp nz,  fileNamePr_8
 93+  CE64
 94+  CE64              ;fileNamePr_9:
 95+  CE64              ;            ; Пропускаем текст до пробела или конца строки
 96+  CE64              ;            ; Почему то дублируется код
 97+  CE64              ;            ld      a, (hl)
 98+  CE64              ;            cp      ' '
 99+  CE64              ;            jp c,   fileNamePr_10
100+  CE64              ;            inc     hl
101+  CE64              ;            jp z,   fileNamePr_9
102+  CE64              ;            dec     hl
103+  CE64
104+  CE64              fileNamePr_10:    ; Восстанавливаем регистры и выходим
105+  CE64 D1                       pop     de
106+  CE65 C1                       pop     bc
107+  CE66 C9                       ret
108+  CE67
109+  CE67              ; ---------------------------------------------------------------------------
110+  CE67
111+  CE67              fileNamePr_11:
112+  CE67                          ; Заполняем недостающие символы расширения пробелами
113+  CE67 41                       ld      b, c
114+  CE68 CD 6E CE                 call    memset_de_20_b
115+  CE6B
116+  CE6B                          ; Восстанавливаем регистры и выходим
117+  CE6B D1                       pop     de
118+  CE6C C1                       pop     bc
119+  CE6D C9                       ret
120+  CE6E
144   CE6E              	INCLUDE "memset_de_20_b.inc"
  1+  CE6E              ;+---------------------------------------------------------------------------
  2+  CE6E              ; MXOS
  3+  CE6E              ; Заполнить память пробелами
  4+  CE6E              ;
  5+  CE6E              ; На входе
  6+  CE6E              ;  de - адрес
  7+  CE6E              ;  b  - длина (0 считается за 256)
  8+  CE6E              ;
  9+  CE6E              ; 2013-12-12 Дизассемблировано vinxru
 10+  CE6E              ;----------------------------------------------------------------------------
 11+  CE6E
 12+  CE6E              memset_de_20_b:
 13+  CE6E 3E 20                    ld      a, ' '
 14+  CE70              memset_de_a_b:
 15+  CE70 12                       ld      (de), a
 16+  CE71 13                       inc     de
 17+  CE72 05                       dec     b
 18+  CE73 C2 70 CE                 jp nz,  memset_de_a_b
 19+  CE76 C9                       ret
 20+  CE77
145   CE77
146   CE77                  IF RAMFOS_COMPATIBILITY
147   CE77              	INCLUDE "strToHex.inc"
  1+  CE77              ;+---------------------------------------------------------------------------
  2+  CE77              ; MXOS
  3+  CE77              ; Преобразвоние строки в 16-ричное число
  4+  CE77              ; Заимствовано из RAMFOS
  5+  CE77              ;
  6+  CE77              ; На входе
  7+  CE77              ;  de - Строка
  8+  CE77              ;
  9+  CE77              ; На выходе
 10+  CE77              ;  bc       - Сохраняется
 11+  CE77              ;  de       - Следующий символ за запятой или концом строки
 12+  CE77              ;  jz       - Ошибка
 13+  CE77              ;  jnz, jc  - Конец строки
 14+  CE77              ;  jnz, jnc - Пробел или запятая
 15+  CE77              ;  hl       - Число
 16+  CE77              ;
 17+  CE77              ; 2013-11-01 Дизассемблировано vinxru
 18+  CE77              ;----------------------------------------------------------------------------
 19+  CE77
 20+  CE77              strToHex:
 21+  CE77 21 00 00                 ld  hl, 0
 22+  CE7A
 23+  CE7A              strToHex_loop:    ; Чтение символа
 24+  CE7A 1A                       ld    a, (de)
 25+  CE7B 13                       inc   de
 26+  CE7C
 27+  CE7C                          ; Если конец строки, выходим с флагами NZ, c
 28+  CE7C FE 0D                    cp    0Dh
 29+  CE7E CA B7 CE                 jp z, ora_a_stc_ret
 30+  CE81
 31+  CE81                          ; Если пробел или запятая, выходим с флагами NZ, NC
 32+  CE81 FE 2C                    cp    ','
 33+  CE83 CA BA CE                 jp z, ora_a_ret
 34+  CE86 FE 20                    cp    ' '
 35+  CE88 CA BA CE                 jp z, ora_a_ret
 36+  CE8B
 37+  CE8B                          ; Если некорректный символ, выходим с флагами С,Z
 38+  CE8B D6 30                    sub   '0'
 39+  CE8D FA B1 CE                 jp M, xra_a_stc_ret
 40+  CE90
 41+  CE90                          ; Если это цифра
 42+  CE90 FE 0A                    cp    10
 43+  CE92 FA A1 CE                 jp M, strToHex_0
 44+  CE95
 45+  CE95                          ; Если некорректный символ, выходим с флагами С,Z
 46+  CE95 FE 11                    cp    11h
 47+  CE97 FA B1 CE                 jp M, xra_a_stc_ret
 48+  CE9A FE 17                    cp    17h
 49+  CE9C F2 B1 CE                 jp p, xra_a_stc_ret
 50+  CE9F
 51+  CE9F                          ; Это буквы A..F
 52+  CE9F D6 07                    sub   'A'-'0'-10
 53+  CEA1
 54+  CEA1              strToHex_0:
 55+  CEA1                          ; hl *= 16
 56+  CEA1 29                       add   hl, hl
 57+  CEA2 29                       add   hl, hl
 58+  CEA3 29                       add   hl, hl
 59+  CEA4 29                       add   hl, hl
 60+  CEA5
 61+  CEA5                          ; Если переполнение, выходим c флагами С,Z
 62+  CEA5 DA B1 CE                 jp c, xra_a_stc_ret
 63+  CEA8
 64+  CEA8                          ; hl += bc
 65+  CEA8 C5                       push bc
 66+  CEA9 06 00                    ld   b, 0
 67+  CEAB 4F                       ld   c, a
 68+  CEAC 09                       add  hl, bc
 69+  CEAD C1                       pop  bc
 70+  CEAE
 71+  CEAE C3 7A CE                 jp    strToHex_loop
 72+  CEB1
 73+  CEB1              xra_a_stc_ret:    ; Вывод знака вопроса
 74+  CEB1 0E 3F                    ld  c, '?'
 75+  CEB3 CD 37 C0                 call      printChar
 76+  CEB6 AF                       xor a
 77+  CEB7
 78+  CEB7              ora_a_stc_ret:
 79+  CEB7 B7                       or  a
 80+  CEB8 37                       scf
 81+  CEB9 C9                       ret
 82+  CEBA
 83+  CEBA              ora_a_ret:
 84+  CEBA B7                       or  a
 85+  CEBB C9                       ret
 86+  CEBC
148   CEBC                  ENDIF
149   CEBC
150   CEBC              	INCLUDE "printDecWord.inc"
  1+  CEBC              ;----------------------------------------------------------------------------
  2+  CEBC              ; MXOS DOS.SYS
  3+  CEBC              ; Вывод десятичного числа из de
  4+  CEBC              ; Перенесено из NC.COM
  5+  CEBC              ;
  6+  CEBC              ; вход:
  7+  CEBC              ;   de = число
  8+  CEBC              ;
  9+  CEBC              ; выход:
 10+  CEBC              ;   hl, de, bc - сохраняются
 11+  CEBC              ;
 12+  CEBC              ; 2013-12-18 Дизассемблировано vinxru
 13+  CEBC              ;----------------------------------------------------------------------------
 14+  CEBC
 15+  CEBC              printDecWord:
 16+  CEBC D5                       push  de
 17+  CEBD C5                       push  bc
 18+  CEBE E5                       push  hl
 19+  CEBF EB                       ex    de, hl
 20+  CEC0 06 20                    ld    b, 20h
 21+  CEC2 11 F0 D8                 ld    de, -10000
 22+  CEC5 CD E5 CE                 call  printDec1
 23+  CEC8 11 18 FC                 ld    de, -1000
 24+  CECB CD E5 CE                 call  printDec1
 25+  CECE 11 9C FF                 ld    de, -100
 26+  CED1 CD E5 CE                 call  printDec1
 27+  CED4 11 F6 FF                 ld    de, -10
 28+  CED7 CD E5 CE                 call  printDec1
 29+  CEDA 7D                       ld    a, l
 30+  CEDB C6 30                    add   a, '0'
 31+  CEDD 4F                       ld    c, a
 32+  CEDE CD 37 C0                 call  printChar
 33+  CEE1 E1                       pop   hl
 34+  CEE2 C1                       pop   bc
 35+  CEE3 D1                       pop   de
 36+  CEE4 C9                       ret
 37+  CEE5
 38+  CEE5              ; ---------------------------------------------------------------------------
 39+  CEE5
 40+  CEE5
 41+  CEE5              printDec1:  ; c = '0' + (hl / de), hl /= de;
 42+  CEE5 0E 2F                    ld    c, '0'-1
 43+  CEE7
 44+  CEE7 0C           loc_DB11:   inc   c
 45+  CEE8 19                       add   hl, de
 46+  CEE9 DA E7 CE                 jp c, loc_DB11
 47+  CEEC
 48+  CEEC 7A                       ld    a, d        ; hl -= de;
 49+  CEED 2F                       cpl
 50+  CEEE 57                       ld    d, a
 51+  CEEF 7B                       ld    a, e
 52+  CEF0 2F                       cpl
 53+  CEF1 5F                       ld    e, a
 54+  CEF2 13                       inc   de
 55+  CEF3 19                       add   hl, de
 56+  CEF4 79                       ld    a, c
 57+  CEF5
 58+  CEF5                          ; if (c!='0') b=0xFF; c&=b;
 59+  CEF5 FE 30                    cp    '0'
 60+  CEF7 CA FC CE                 jp z, loc_DB26
 61+  CEFA 06 FF                    ld    b, 0FFh
 62+  CEFC A0           loc_DB26:   and   b
 63+  CEFD 4F                       ld    c, a
 64+  CEFE
 65+  CEFE C3 37 C0                 jp    printChar
 66+  CF01
151   CF01
152   CF01              ;---------------------------------------------------------------------------
153   CF01              ; Константы и переменые
154   CF01              ;---------------------------------------------------------------------------
155   CF01
156   CF01 0A 42 41 44  txtBadCommand:	    DB 0Ah,"BAD COMMAND OR FILE NAME",0
156   CF05 20 43 4F 4D
156   CF09 4D 41 4E 44
156   CF0D 20 4F 52 20
156   CF11 46 49 4C 45
156   CF15 20 4E 41 4D
156   CF19 45 00
157   CF1B 0C 4D 58 4F  txtBiosVer:         DB 0Ch,"MXOS BIOS 4.60",0Ah, 0
157   CF1F 53 20 42 49
157   CF23 4F 53 20 34
157   CF27 2E 36 30 0A
157   CF2B 00
158   CF2C 0A 52 41 4D  txtRAM:             DB 0Ah,"RAM:",0
158   CF30 3A 00
159   CF32 20 4B 42 0A  txtKB:              DB " KB",0Ah, 0
159   CF36 00
160   CF37 30 CB 30 CB  v_drives:			DW diskDriver, diskDriver, diskDriver, diskDriver  ; Addresses of drivers for 8 disks
160   CF3B 30 CB 30 CB
161   CF3F 30 CB 30 CB  					DW diskDriver, diskDriver, diskDriver, diskDriver  ; (initial value = diskDriver = C863h)
161   CF43 30 CB 30 CB
162   CF47 00 00        v_findCluster:		DW 0
163   CF49 01           v_drive:			DB 1
164   CF4A 00 00        v_input_start:		DW 0
165   CF4C 00 00        v_createdFile:		DW 0        ; Переменная хранит адрес дескриптора созданного файла
166   CF4E 00 00        v_foundedFile:		DW 0
167   CF50 00 00        v_input_end:		DW 0
168   CF52 00 00        v_batPtr:			DW 0        ; Переменная хранит адрес буфра, где находится содержимое BAT файла
169   CF54 FF FA        v_memTop:			DW 0FAFFh   ; Переменная хранит максимальный доступный программам адрес в памяти
170   CF56
171   CF56 41 3A 46 4F  pathFontFnt:        DB "A:FONT.FNT",0
171   CF5A 4E 54 2E 46
171   CF5E 4E 54 00
172   CF61 41 3A 4E 43  pathNcCom:			DB "A:NC.COM",0
172   CF65 2E 43 4F 4D
172   CF69 00
173   CF6A 41 3A 41 55  pathAutoexecBat:	DB "A:AUTOEX.BAT",0
173   CF6E 54 4F 45 58
173   CF72 2E 42 41 54
173   CF76 00
174   CF77 41 3A 46 4F  pathFormatBat:      DB "A:FORMAT.BAT",0
174   CF7B 52 4D 41 54
174   CF7F 2E 42 41 54
174   CF83 00
175   CF84 42 41 54     aBat:               DB "BAT"
176   CF87 43 4F 4D     aCom:               DB "COM"
177   CF8A 45 58 45     aExe:               DB "EXE"
178   CF8D
179   CF8D                  IF BOOT_FROM_TAPE
180   CF8D ~            aATape_com:         DB "A:TAPE.COM",0
181   CF8D ~            txtLoadingFromTape: DB 0Ah,"LOADING FROM TAPE...",0
182   CF8D                  ENDIF
183   CF8D
184   CF8D 00 00 00 00  v_curFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего файла
184   CF91 00 00 00 00
184   CF95 00 00 00 00
184   CF99 00 00 00 00
184   CF9D 00 00 00 00
184   CFA1 00 00 00 00
184   CFA5 00 00 00 00
184   CFA9 00 00 00 00
185   CFAD 00 00 00 00  v_batFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего BAT файла
185   CFB1 00 00 00 00
185   CFB5 00 00 00 00
185   CFB9 00 00 00 00
185   CFBD 00 00 00 00
185   CFC1 00 00 00 00
185   CFC5 00 00 00 00
185   CFC9 00 00 00 00
186   CFCD
187   CFCD                  ; Проверка - DOS.SYS не должен вылезать за эти пределы
188   CFCD                  ASSERT_DONT_FIT 0D000h
188   CFCD             >         IF $ > 0D000h
188   CFCD ~           >           ASSERT 0
188   CFCD ~           >           DISPLAY /l, "Error! Image did not fit (", $, " > ", adr, ")"
188   CFCD             >         ENDIF
189   CFCD
190   CFCD                  IF LOAD_FONT
191   CFCD              	    INCLUDE "font.inc"
  1+  CFCD              ;+---------------------------------------------------------------------------
  2+  CFCD              ; MXOS
  3+  CFCD              ; Загрузка шрифта в память
  4+  CFCD              ;
  5+  CFCD              ; Разработано vinxru
  6+  CFCD              ; Доработано SpaceEngineer
  7+  CFCD              ;----------------------------------------------------------------------------
  8+  CFCD
  9+  CFCD              initFont:   ; Изменяем команду перехода сюда на reboot2
 10+  CFCD 21 38 C5                 ld      hl, reboot2
 11+  CFD0 22 75 C4                 ld      (onceInitFont+1), hl
 12+  CFD3 E5                       push    hl
 13+  CFD4
 14+  CFD4                          ; Устанавливаем блочный драйвер ДОЗУ
 15+  CFD4 06 00                    ld      b, 0
 16+  CFD6 CD CE CA                 call    setRAMDDriver
 17+  CFD9
 18+  CFD9                          ; Ищем и загружаем файл A:FONT.FNT на адрес FONT_ADDR
 19+  CFD9 21 56 CF                 ld      hl, pathFontFnt
 20+  CFDC 11 8D CF                 ld      de, v_curFileDescr
 21+  CFDF CD 08 CE                 call    fileNamePrepare   ; подготовка имени файла и переключение накопителя
 22+  CFE2 EB                       ex      de, hl
 23+  CFE3 11 00 E9                 ld      de, FONT_ADDR
 24+  CFE6 C3 EF CC                 jp      fileLoad2
 25+  CFE9 ~            /*
 26+  CFE9 ~                        ld      hl, font
 27+  CFE9 ~                        ld      de, fontEnd
 28+  CFE9 ~                        ld      bc, FONT_ADDR
 29+  CFE9 ~                        jp      memcpy_bc_hl
 30+  CFE9 ~
 31+  CFE9 ~
 32+  CFE9 ~
 33+  CFE9 ~            font:
 34+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 0
 35+  CFE9 ~                  DB 004h,00Eh,015h,004h,015h,00Eh,004h,000h ; 1
 36+  CFE9 ~                  DB 000h,000h,004h,00Ah,01Fh,000h,01Fh,000h ; 2
 37+  CFE9 ~                  DB 000h,000h,01Fh,00Ah,004h,000h,01Fh,000h ; 3
 38+  CFE9 ~                  DB 009h,01Bh,02Dh,01Bh,009h,000h,000h,000h ; 4
 39+  CFE9 ~                  DB 024h,036h,02Dh,036h,024h,000h,000h,000h ; 5
 40+  CFE9 ~                  DB 01Eh,021h,02Dh,029h,02Dh,021h,01Eh,000h ; 6
 41+  CFE9 ~                  DB 010h,018h,017h,015h,017h,018h,010h,000h ; 7
 42+  CFE9 ~                  DB 000h,000h,004h,008h,01Fh,008h,004h,000h ; 8
 43+  CFE9 ~                  DB 000h,000h,014h,012h,01Fh,012h,014h,000h ; 9
 44+  CFE9 ~                  DB 013h,012h,013h,01Ah,000h,01Fh,000h,000h ; 10
 45+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 11
 46+  CFE9 ~                  DB 01Ch,018h,014h,002h,001h,001h,001h,000h ; 12
 47+  CFE9 ~                  DB 01Fh,001h,001h,005h,009h,01Fh,008h,004h ; 13
 48+  CFE9 ~                  DB 003h,004h,004h,01Ch,03Ch,018h,000h,000h ; 14
 49+  CFE9 ~                  DB 003h,009h,005h,03Fh,005h,009h,003h,000h ; 15
 50+  CFE9 ~                  DB 003h,009h,011h,03Fh,011h,009h,003h,000h ; 16
 51+  CFE9 ~                  DB 004h,00Ah,011h,00Ah,004h,000h,000h,000h ; 17
 52+  CFE9 ~                  DB 011h,011h,011h,011h,011h,000h,011h,000h ; 18
 53+  CFE9 ~                  DB 000h,000h,000h,000h,000h,011h,011h,000h ; 19
 54+  CFE9 ~                  DB 000h,008h,000h,008h,000h,008h,000h,000h ; 20
 55+  CFE9 ~                  DB 004h,004h,000h,01Fh,000h,004h,004h,000h ; 21
 56+  CFE9 ~                  DB 00Fh,008h,008h,008h,008h,028h,010h,000h ; 22
 57+  CFE9 ~                  DB 03Fh,000h,000h,000h,000h,000h,000h,000h ; 23
 58+  CFE9 ~                  DB 000h,000h,004h,002h,01Fh,002h,004h,000h ; 24
 59+  CFE9 ~                  DB 004h,00Eh,015h,004h,004h,004h,004h,000h ; 25
 60+  CFE9 ~                  DB 004h,004h,004h,004h,015h,00Eh,004h,000h ; 26
 61+  CFE9 ~                  DB 01Bh,012h,01Ah,012h,01Bh,000h,01Fh,000h ; 27
 62+  CFE9 ~                  DB 03Fh,001h,000h,000h,000h,000h,000h,000h ; 28
 63+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 29
 64+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 30
 65+  CFE9 ~                  DB 01Fh,011h,019h,015h,013h,011h,01Fh,000h ; 31
 66+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 32
 67+  CFE9 ~                  DB 004h,004h,004h,004h,004h,000h,004h,000h ; 33
 68+  CFE9 ~                  DB 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
 69+  CFE9 ~                  DB 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
 70+  CFE9 ~                  DB 004h,00Fh,014h,00Eh,005h,01Eh,004h,000h ; 36
 71+  CFE9 ~                  DB 010h,011h,002h,004h,008h,011h,001h,000h ; 37
 72+  CFE9 ~                  DB 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
 73+  CFE9 ~                  DB 000h,002h,002h,004h,000h,000h,000h,000h ; 39
 74+  CFE9 ~                  DB 002h,004h,008h,008h,008h,004h,002h,000h ; 40
 75+  CFE9 ~                  DB 008h,004h,002h,002h,002h,004h,008h,000h ; 41
 76+  CFE9 ~                  DB 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
 77+  CFE9 ~                  DB 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
 78+  CFE9 ~                  DB 000h,000h,000h,000h,000h,004h,004h,008h ; 44
 79+  CFE9 ~                  DB 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
 80+  CFE9 ~                  DB 000h,000h,000h,000h,000h,004h,004h,000h ; 46
 81+  CFE9 ~                  DB 000h,001h,002h,004h,008h,010h,000h,000h ; 47
 82+  CFE9 ~                  DB 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
 83+  CFE9 ~                  DB 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
 84+  CFE9 ~                  DB 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
 85+  CFE9 ~                  DB 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
 86+  CFE9 ~                  DB 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
 87+  CFE9 ~                  DB 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
 88+  CFE9 ~                  DB 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
 89+  CFE9 ~                  DB 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
 90+  CFE9 ~                  DB 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
 91+  CFE9 ~                  DB 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
 92+  CFE9 ~                  DB 000h,004h,004h,000h,000h,004h,004h,000h ; 58
 93+  CFE9 ~                  DB 000h,004h,004h,000h,000h,004h,004h,008h ; 59
 94+  CFE9 ~                  DB 002h,004h,008h,010h,008h,004h,002h,000h ; 60
 95+  CFE9 ~                  DB 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
 96+  CFE9 ~                  DB 008h,004h,002h,001h,002h,004h,008h,000h ; 62
 97+  CFE9 ~                  DB 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
 98+  CFE9 ~                  DB 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
 99+  CFE9 ~                  DB 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
100+  CFE9 ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
101+  CFE9 ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
102+  CFE9 ~                  DB 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
103+  CFE9 ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
104+  CFE9 ~                  DB 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
105+  CFE9 ~                  DB 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
106+  CFE9 ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
107+  CFE9 ~                  DB 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
108+  CFE9 ~                  DB 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
109+  CFE9 ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 75
110+  CFE9 ~                  DB 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
111+  CFE9 ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
112+  CFE9 ~                  DB 011h,011h,019h,015h,013h,011h,011h,000h ; 78
113+  CFE9 ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
114+  CFE9 ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
115+  CFE9 ~                  DB 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
116+  CFE9 ~                  DB 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
117+  CFE9 ~                  DB 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
118+  CFE9 ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
119+  CFE9 ~                  DB 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
120+  CFE9 ~                  DB 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
121+  CFE9 ~                  DB 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
122+  CFE9 ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
123+  CFE9 ~                  DB 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
124+  CFE9 ~                  DB 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
125+  CFE9 ~                  DB 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
126+  CFE9 ~                  DB 000h,010h,008h,004h,002h,001h,000h,000h ; 92
127+  CFE9 ~                  DB 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
128+  CFE9 ~                  DB 004h,00Ah,011h,000h,000h,000h,000h,000h ; 94
129+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 95
130+  CFE9 ~                  DB 000h,00Fh,000h,006h,009h,009h,006h,000h ; 96
131+  CFE9 ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 97
132+  CFE9 ~                  DB 008h,008h,008h,00Eh,009h,009h,016h,000h ; 98
133+  CFE9 ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 99
134+  CFE9 ~                  DB 002h,002h,002h,00Eh,012h,012h,00Dh,000h ; 100
135+  CFE9 ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 101
136+  CFE9 ~                  DB 006h,009h,008h,01Ch,008h,008h,008h,000h ; 102
137+  CFE9 ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,01Ch ; 103
138+  CFE9 ~                  DB 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
139+  CFE9 ~                  DB 000h,010h,000h,010h,010h,011h,00Eh,000h ; 105
140+  CFE9 ~                  DB 000h,001h,000h,001h,001h,001h,011h,00Eh ; 106
141+  CFE9 ~                  DB 010h,010h,011h,012h,01Ch,012h,011h,000h ; 107
142+  CFE9 ~                  DB 010h,010h,010h,010h,010h,011h,00Eh,000h ; 108
143+  CFE9 ~                  DB 000h,000h,01Ah,015h,015h,015h,015h,000h ; 109
144+  CFE9 ~                  DB 000h,000h,016h,019h,011h,011h,011h,000h ; 110
145+  CFE9 ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
146+  CFE9 ~                  DB 000h,000h,016h,009h,009h,00Eh,008h,008h ; 112
147+  CFE9 ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,002h ; 113
148+  CFE9 ~                  DB 000h,000h,016h,009h,008h,008h,008h,000h ; 114
149+  CFE9 ~                  DB 000h,000h,00Eh,010h,00Eh,001h,00Eh,000h ; 115
150+  CFE9 ~                  DB 008h,008h,01Ch,008h,008h,009h,006h,000h ; 116
151+  CFE9 ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 117
152+  CFE9 ~                  DB 000h,000h,011h,011h,011h,00Ah,004h,000h ; 118
153+  CFE9 ~                  DB 000h,000h,015h,015h,015h,015h,00Ah,000h ; 119
154+  CFE9 ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
155+  CFE9 ~                  DB 000h,000h,011h,011h,011h,00Fh,001h,00Eh ; 121
156+  CFE9 ~                  DB 000h,000h,01Fh,001h,00Eh,010h,01Fh,000h ; 122
157+  CFE9 ~                  DB 003h,004h,004h,018h,004h,004h,003h,000h ; 123
158+  CFE9 ~                  DB 01Fh,011h,011h,011h,011h,011h,01Fh,000h ; 124
159+  CFE9 ~                  DB 018h,004h,004h,003h,004h,004h,018h,000h ; 125
160+  CFE9 ~                  DB 000h,000h,008h,015h,002h,000h,000h,000h ; 126
161+  CFE9 ~                  DB 001h,003h,007h,00Fh,007h,003h,001h,000h ; 127
162+  CFE9 ~                  DB 000h,000h,00Ah,01Fh,01Fh,00Eh,004h,000h ; 128
163+  CFE9 ~                  DB 000h,004h,004h,01Fh,004h,004h,01Bh,000h ; 129
164+  CFE9 ~                  DB 004h,00Eh,01Fh,01Fh,00Ah,004h,01Bh,000h ; 130
165+  CFE9 ~                  DB 000h,000h,004h,00Eh,01Fh,00Eh,004h,000h ; 131
166+  CFE9 ~                  DB 002h,004h,00Ah,015h,011h,011h,00Eh,000h ; 132
167+  CFE9 ~                  DB 00Eh,004h,01Fh,015h,004h,00Ah,011h,000h ; 133
168+  CFE9 ~                  DB 003h,004h,006h,009h,006h,002h,00Ch,000h ; 134
169+  CFE9 ~                  DB 007h,003h,005h,00Ch,012h,012h,00Ch,000h ; 135
170+  CFE9 ~                  DB 00Eh,011h,011h,00Eh,004h,00Eh,004h,000h ; 136
171+  CFE9 ~                  DB 000h,017h,014h,01Fh,005h,01Dh,000h,000h ; 137
172+  CFE9 ~                  DB 004h,004h,01Fh,004h,014h,00Ch,006h,005h ; 138
173+  CFE9 ~                  DB 004h,01Fh,004h,00Ah,011h,01Fh,004h,000h ; 139
174+  CFE9 ~                  DB 004h,01Fh,005h,00Ah,011h,01Fh,004h,000h ; 140
175+  CFE9 ~                  DB 004h,004h,01Fh,000h,01Fh,004h,004h,000h ; 141
176+  CFE9 ~                  DB 004h,00Eh,00Ah,00Ah,00Ah,00Eh,004h,000h ; 142
177+  CFE9 ~                  DB 004h,006h,001h,006h,001h,006h,004h,000h ; 143
178+  CFE9 ~                  DB 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 144
179+  CFE9 ~                  DB 030h,030h,030h,030h,030h,030h,030h,030h ; 145
180+  CFE9 ~                  DB 003h,003h,003h,003h,003h,003h,003h,003h ; 146
181+  CFE9 ~                  DB 030h,030h,030h,03Fh,03Fh,030h,030h,030h ; 147
182+  CFE9 ~                  DB 003h,003h,003h,03Fh,03Fh,003h,003h,003h ; 148
183+  CFE9 ~                  DB 000h,000h,000h,03Fh,03Fh,030h,030h,030h ; 149
184+  CFE9 ~                  DB 000h,000h,000h,03Fh,03Fh,003h,003h,003h ; 150
185+  CFE9 ~                  DB 003h,003h,003h,03Fh,03Fh,000h,000h,000h ; 151
186+  CFE9 ~                  DB 030h,030h,030h,03Fh,03Fh,000h,000h,000h ; 152
187+  CFE9 ~                  DB 000h,000h,000h,03Fh,03Fh,018h,018h,018h ; 153
188+  CFE9 ~                  DB 018h,018h,018h,018h,018h,018h,018h,018h ; 154
189+  CFE9 ~                  DB 018h,018h,018h,03Fh,03Fh,000h,000h,000h ; 155
190+  CFE9 ~                  DB 018h,018h,018h,03Fh,03Fh,018h,018h,018h ; 156
191+  CFE9 ~                  DB 000h,000h,001h,002h,014h,008h,000h,000h ; 157
192+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 158
193+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 159
194+  CFE9 ~                  DB 002h,002h,00Ah,016h,012h,012h,00Dh,000h ; 160
195+  CFE9 ~                  DB 006h,009h,00Eh,009h,00Eh,008h,010h,000h ; 161
196+  CFE9 ~                  DB 01Fh,011h,011h,010h,010h,010h,010h,000h ; 162
197+  CFE9 ~                  DB 00Fh,010h,012h,00Ah,00Ah,00Ah,011h,000h ; 163
198+  CFE9 ~                  DB 01Fh,008h,004h,002h,004h,008h,01Fh,000h ; 164
199+  CFE9 ~                  DB 005h,00Ah,010h,01Eh,011h,011h,00Eh,000h ; 165
200+  CFE9 ~                  DB 009h,009h,009h,009h,00Fh,009h,010h,000h ; 166
201+  CFE9 ~                  DB 008h,014h,004h,002h,006h,009h,011h,000h ; 167
202+  CFE9 ~                  DB 015h,015h,015h,00Eh,004h,004h,004h,000h ; 168
203+  CFE9 ~                  DB 00Eh,011h,01Bh,01Fh,01Bh,011h,00Eh,000h ; 169
204+  CFE9 ~                  DB 00Eh,011h,011h,00Eh,004h,015h,01Bh,000h ; 170
205+  CFE9 ~                  DB 006h,009h,009h,006h,000h,000h,000h,000h ; 171
206+  CFE9 ~                  DB 00Eh,013h,015h,019h,00Eh,000h,000h,000h ; 172
207+  CFE9 ~                  DB 002h,006h,002h,002h,007h,000h,000h,000h ; 173
208+  CFE9 ~                  DB 006h,009h,002h,004h,00Fh,000h,000h,000h ; 174
209+  CFE9 ~                  DB 00Fh,001h,002h,009h,006h,000h,000h,000h ; 175
210+  CFE9 ~                  DB 00Ah,00Ah,00Fh,002h,002h,000h,000h,000h ; 176
211+  CFE9 ~                  DB 00Eh,008h,00Eh,001h,00Eh,000h,000h,000h ; 177
212+  CFE9 ~                  DB 006h,008h,00Eh,009h,006h,000h,000h,000h ; 178
213+  CFE9 ~                  DB 00Fh,001h,002h,004h,004h,000h,000h,000h ; 179
214+  CFE9 ~                  DB 006h,009h,006h,009h,006h,000h,000h,000h ; 180
215+  CFE9 ~                  DB 006h,009h,007h,001h,006h,000h,000h,000h ; 181
216+  CFE9 ~                  DB 000h,000h,00Eh,013h,015h,019h,00Eh,000h ; 182
217+  CFE9 ~                  DB 000h,000h,002h,006h,002h,002h,007h,000h ; 183
218+  CFE9 ~                  DB 000h,000h,006h,009h,002h,004h,00Fh,000h ; 184
219+  CFE9 ~                  DB 000h,000h,00Fh,001h,002h,009h,006h,000h ; 185
220+  CFE9 ~                  DB 000h,000h,00Ah,00Ah,00Fh,002h,002h,000h ; 186
221+  CFE9 ~                  DB 000h,000h,00Eh,008h,00Eh,001h,00Eh,000h ; 187
222+  CFE9 ~                  DB 000h,000h,006h,008h,00Eh,009h,006h,000h ; 188
223+  CFE9 ~                  DB 000h,000h,00Fh,001h,002h,004h,004h,000h ; 189
224+  CFE9 ~                  DB 000h,000h,006h,009h,006h,009h,006h,000h ; 190
225+  CFE9 ~                  DB 000h,000h,006h,009h,007h,001h,006h,000h ; 191
226+  CFE9 ~                  DB 000h,000h,012h,015h,01Dh,015h,012h,000h ; 192
227+  CFE9 ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 193
228+  CFE9 ~                  DB 001h,00Eh,010h,01Eh,011h,011h,00Eh,000h ; 194
229+  CFE9 ~                  DB 000h,000h,012h,012h,012h,012h,00Fh,001h ; 195
230+  CFE9 ~                  DB 00Eh,001h,001h,00Fh,011h,011h,00Eh,000h ; 196
231+  CFE9 ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 197
232+  CFE9 ~                  DB 000h,000h,00Eh,015h,015h,00Eh,004h,004h ; 198
233+  CFE9 ~                  DB 000h,000h,00Ch,012h,004h,009h,006h,000h ; 199
234+  CFE9 ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 200
235+  CFE9 ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 201
236+  CFE9 ~                  DB 00Ch,000h,012h,012h,012h,012h,00Dh,000h ; 202
237+  CFE9 ~                  DB 000h,000h,011h,012h,01Ch,012h,011h,000h ; 203
238+  CFE9 ~                  DB 000h,000h,007h,009h,009h,009h,011h,000h ; 204
239+  CFE9 ~                  DB 000h,000h,011h,01Bh,015h,011h,011h,000h ; 205
240+  CFE9 ~                  DB 000h,000h,011h,011h,01Fh,011h,011h,000h ; 206
241+  CFE9 ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 207
242+  CFE9 ~                  DB 000h,000h,01Fh,011h,011h,011h,011h,000h ; 208
243+  CFE9 ~                  DB 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 209
244+  CFE9 ~                  DB 000h,000h,01Eh,011h,011h,01Eh,010h,000h ; 210
245+  CFE9 ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 211
246+  CFE9 ~                  DB 000h,000h,01Fh,004h,004h,004h,004h,000h ; 212
247+  CFE9 ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,00Eh ; 213
248+  CFE9 ~                  DB 000h,000h,015h,015h,00Eh,015h,015h,000h ; 214
249+  CFE9 ~                  DB 00Ch,014h,018h,01Eh,011h,011h,00Eh,000h ; 215
250+  CFE9 ~                  DB 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 216
251+  CFE9 ~                  DB 000h,000h,011h,011h,01Dh,013h,01Dh,000h ; 217
252+  CFE9 ~                  DB 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 218
253+  CFE9 ~                  DB 000h,000h,011h,015h,015h,015h,01Fh,000h ; 219
254+  CFE9 ~                  DB 000h,000h,01Eh,001h,007h,001h,01Eh,000h ; 220
255+  CFE9 ~                  DB 000h,000h,015h,015h,015h,015h,01Fh,001h ; 221
256+  CFE9 ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,000h ; 222
257+  CFE9 ~                  DB 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 223
258+  CFE9 ~                  DB 012h,015h,015h,01Dh,015h,015h,012h,000h ; 224
259+  CFE9 ~                  DB 00Eh,011h,011h,011h,01Fh,011h,011h,000h ; 225
260+  CFE9 ~                  DB 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 226
261+  CFE9 ~                  DB 012h,012h,012h,012h,012h,012h,01Fh,001h ; 227
262+  CFE9 ~                  DB 006h,00Ah,00Ah,00Ah,00Ah,01Fh,011h,000h ; 228
263+  CFE9 ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 229
264+  CFE9 ~                  DB 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 230
265+  CFE9 ~                  DB 01Fh,011h,010h,010h,010h,010h,010h,000h ; 231
266+  CFE9 ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 232
267+  CFE9 ~                  DB 011h,011h,013h,015h,019h,011h,011h,000h ; 233
268+  CFE9 ~                  DB 015h,011h,013h,015h,019h,011h,011h,000h ; 234
269+  CFE9 ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 235
270+  CFE9 ~                  DB 007h,009h,009h,009h,009h,009h,019h,000h ; 236
271+  CFE9 ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 237
272+  CFE9 ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 238
273+  CFE9 ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 239
274+  CFE9 ~                  DB 01Fh,011h,011h,011h,011h,011h,011h,000h ; 240
275+  CFE9 ~                  DB 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 241
276+  CFE9 ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 242
277+  CFE9 ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 243
278+  CFE9 ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 244
279+  CFE9 ~                  DB 011h,011h,011h,00Ah,004h,008h,010h,000h ; 245
280+  CFE9 ~                  DB 011h,015h,015h,00Eh,015h,015h,011h,000h ; 246
281+  CFE9 ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 247
282+  CFE9 ~                  DB 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 248
283+  CFE9 ~                  DB 011h,011h,011h,019h,015h,015h,019h,000h ; 249
284+  CFE9 ~                  DB 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 250
285+  CFE9 ~                  DB 011h,015h,015h,015h,015h,015h,01Fh,000h ; 251
286+  CFE9 ~                  DB 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 252
287+  CFE9 ~                  DB 015h,015h,015h,015h,015h,015h,01Fh,001h ; 253
288+  CFE9 ~                  DB 011h,011h,011h,00Fh,001h,001h,001h,000h ; 254
289+  CFE9 ~                  DB 000h,000h,000h,000h,000h,000h,000h,01Fh ; 255
290+  CFE9 ~            fontEnd:
291+  CFE9 ~
292+  CFE9 ~            */
192   CFE9                  ENDIF
193   CFE9
194   CFE9                  END
