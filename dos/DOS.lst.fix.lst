  1   0000              ;----------------------------------------------------------------------------
  2   0000              ; MXOS - BIOS и DOS
  3   0000              ;
  4   0000              ; 2013-12-12 Дизассемблировано и доработано vinxru
  5   0000              ; 2022-01-31 Доработано SpaceEngineer
  6   0000              ;----------------------------------------------------------------------------
  7   0000
  8   0000                  INCLUDE "../include/mxos.inc"
  1+  0000              ;-----------------------------------------------------------------------
  2+  0000              ; MXOS
  3+  0000              ; Точки входа и настройки сборки MXOS
  4+  0000              ;
  5+  0000              ; Карта памяти:
  6+  0000              ;   8FDF-8FFF - [  32 B] Переменные
  7+  0000              ;   9000-BFFF - [12  KB] Экран
  8+  0000              ;   C000-CFFF - [4096 B] DOS.SYS (в конце чуть чуть свободного места под доработки)
  9+  0000              ;   D000-E1FF - [4607 B] NC.COM (в конце место под список файлов и чуть чуть свободного места под доработки)
 10+  0000              ;   E200-E5FF - [1024 B] (свободно 1024 байт)
 11+  0000              ;   E600-E7FF - [ 512 B] Драйвер магнитофона
 12+  0000              ;   E900-F0FF - [2048 B] Шрифт (можно отключить запуском ROMFNT.COM или опцией LOAD_FONT=0)
 13+  0000              ;   F100-F8FF - [2048 B] FORMAT.COM, FPAGE.COM, MON2.COM и прочие утилиты
 14+  0000              ;   F900-F9FF - [ 256 B] (Свободно 256 байт)
 15+  0000              ;   FA00-FAFF - [ 256 B] Драйвер флеш-диска
 16+  0000              ;   FB00-FEFF - [1024 B] Дисковый буфер
 17+  0000              ;   FF00-FF81 - [ 129 B] Командная строка. Заполняется функцией bios_fileExec
 18+  0000              ;   FF82-FFBF - [ 130 B] Стек
 19+  0000              ;   FFC0-FFEF - [  32 B] Непереключаемое ОЗУ, драйвера обмена с RAM диском
 20+  0000              ;   FFE0-FFFF - [  32 B] Оборудование
 21+  0000              ;-----------------------------------------------------------------------
 22+  0000
 23+  0000
 24+  0000              ;-----------------------------------------------------------------------
 25+  0000              ; Конфигурация сборки
 26+  0000              ;-----------------------------------------------------------------------
 27+  0000
 28+  0000              RAMD_MAX_PAGE        =  16      ; Максимальное количество страниц RAM диска
 29+  0000              RAMD_PAGE_END        =  0FFBBh  ; Включить поддержку ДОЗУ большего чем 64 Кб
 30+  0000              ROM_64K              =  1       ; Включить поддержку ПЗУ 64 Кб Специалиста МХ2
 31+  0000              ENABLE_COLOR         =  1       ; Включить поддержку цвета
 32+  0000              EMBED_FONT           =  0       ; Встроить шрифт в программу (при запуске шрифт копируется на FONT_ADDR)
 33+  0000              LOAD_FONT            =  1       ; Загружать шрифт в ОЗУ
 34+  0000              FONT_ADDR            =  0E900h  ; Адрес шрфита
 35+  0000              COLOR_BIOS           =  0F0h    ; Цвет командной строки
 36+  0000              RAMFOS_COMPATIBILITY =  1       ; Совместимость с RAMFOS (WIP)
 37+  0000              BOOT_FROM_TAPE       =  0       ; Включить загрузку с ленты при нажатой клавише после сброса
 38+  0000              FAT16                =  1       ; Включить поддержку FAT16
 39+  0000
 40+  0000                  IF  LOAD_FONT
 41+  0000              FONT_ADDR_DIV_8 = FONT_ADDR/8
 42+  0000                  ELSE
 43+  0000 ~            FONT_ADDR_DIV_8 = -1
 44+  0000                  ENDIF
 45+  0000
 46+  0000              ;-----------------------------------------------------------------------
 47+  0000              ; Переменные ОС в подэкранном пространстве и их начальные значения
 48+  0000              ; Доступ к переменным и программ польователя:
 49+  0000              ; ld a, bios_vars.lastKey
 50+  0000              ;-----------------------------------------------------------------------
 51+  0000
 52+  0000                  STRUCT BIOS_VARIABLES
 53+  0000 ~            _reserv_1     DW      -1              ; 8FDFh -
 54+  0000 ~            tapeError     DW      0C800h          ; 8FE1h - Адрес, куда происходит переход при ошибке чтения с ленты
 55+  0000 ~            tapeAddr      DW      -1              ; 8FE3h - Адрес программы загруженной с ленты
 56+  0000 ~            _reserv_2     DW      -1              ; 8FE5h -
 57+  0000 ~            charGen       DW      FONT_ADDR_DIV_8 ; 8FE7h - Адрес альтернативного знакогенератора / 8
 58+  0000 ~            cursorCfg     DB      11h ; 0A9h      ; 8FE9h - Внешний вид курсора (биты: 7 - мигание (если 0), 654 - положение (Y) от низа строки, 3210 - размер по высоте)
 59+  0000 ~            koi8          DB      -1              ; 8FEAh - 0FFh = включен KOI-8, 0 = включен KOI-7
 60+  0000 ~            escMode       DB      -1              ; 8FEBh - Обработка ESC-последовательности
 61+  0000 ~            keyLocks      DB      3Ah             ; 8FECh -
 62+  0000 ~            _reserv_3     DW      -1              ; 8FEDh -
 63+  0000 ~            lastLastKey   DB      -1              ; 8FEFh - Предпоследняя нажатая клавиша
 64+  0000 ~            lastKey       DB      -1              ; 8FF0h - Последняя нажатая клавиша
 65+  0000 ~            beepFreq      DB      5Fh             ; 8FF1h - Частота звукового сигнала (также влияет на длительность)
 66+  0000 ~            beepDuration  DB      20h             ; 8FF2h - Длительность звукового сигнала (сколько раз повторять посылку)
 67+  0000 ~            tapeInverse   DB      0FFh            ; 8FF3h - Признак инверсии данных с ленты
 68+  0000 ~            cursorDelay   DB      020h            ; 8FF4h -
 69+  0000 ~            byte_8FF5     DB      0E0h            ; 8FF5h -
 70+  0000 ~            oldSP         DW      -1              ; 8FF6h - Используется для сохранения SP некоторыми функциями
 71+  0000 ~            ramPageCount  DB      RAMD_MAX_PAGE   ; 8FF8h - Количество детектированных 64кб страниц RAM-диска
 72+  0000 ~            flashPage     DB      0               ; 8FF9h - Текущий номер страницы флеш-диска
 73+  0000 ~            inverse       DW      0               ; 8FFAh - Инвертирование текста (0=нормальный текст, 0FFFFh=инверсный)
 74+  0000 ~            cursorY       DB      -1              ; 8FFCh - Положение курсора по вертикали в пикселях
 75+  0000 ~            cursorX       DB      -1              ; 8FFDh - Положение курсора по горизонтали в пикселях / 2
 76+  0000 ~            writeDelay    DB      28h             ; 8FFEh - Скорость при записи на ленту
 77+  0000 ~            readDelay     DB      3Ch             ; 8FFFh - Скорость при чтении с ленты
 78+  0000                  ENDS
 79+  0000
 80+  0000              ; Блок переменных BIOS начинается с адреса 8FDFh
 81+  0000              bios_vars   BIOS_VARIABLES = 8FDFh
 82+  0000
 83+  0000              ;-----------------------------------------------------------------------
 84+  0000              ; Стандартные точки входа ОС
 85+  0000              ; Отмеченные * применять не рекомендуется
 86+  0000              ;-----------------------------------------------------------------------
 87+  0000
 88+  0000              bios_init            = 0C000h ; Теплая перезагрузка
 89+  0000
 90+  0000              ; Устаревшие точки, лечше не применять
 91+  0000              bios_keyScanOld      = 0C003h ; * Получить код нажатой клавиши, = bios_keyScan
 92+  0000              bios_drawCursorOld   = 0C006h ; * Нарисовать/стереть курсор
 93+  0000              bios_clearScreenOld  = 0C010h ; * Оистка экрана
 94+  0000              bios_printCharOld    = 0C037h ; * Вывод символа на экран
 95+  0000              bios_beep_Old        = 0C170h ; * Звуковой сигнал
 96+  0000              bios_delay_l         = 0C18Fh ; * Задержка l циклов
 97+  0000              bios_delay_b         = 0C190h ; * Задержка b циклов
 98+  0000              bios_getchOld        = 0C337h ; * Ожидание ввода с клавиатуры
 99+  0000              bios_tapeReadOld     = 0C377h ; * Чтение байта с магнитофона
100+  0000              bios_tapeWriteOld    = 0C3D0h ; * Запись байта на магнитофон
101+  0000              bios_cmp_hl_de       = 0C427h ; * Сравнить hl и de
102+  0000              bios_memcpy_bc_hl    = 0C42Dh ; * Скопировать блок памяти
103+  0000              bios_printStringOld  = 0C438h ; * Вывод строки на экран
104+  0000
105+  0000              bios_reboot          = 0C800h ; Запустить NC.COM
106+  0000              bios_getch           = 0C803h ; Ожидание ввода с клавиатуры
107+  0000              bios_tapeRead        = 0C806h ; Чтение байта с магнитофона
108+  0000              bios_printChar       = 0C809h ; Вывод символа на экран
109+  0000              bios_tapeWrite       = 0C80Ch ; Запись байта на магнитофон
110+  0000              bios_input           = 0C80Fh ; Ввод строки с клавиатуры
111+  0000              bios_keyCheck        = 0C812h ; Получить код нажатой клавиши, = bios_keyScan
112+  0000              bios_printHexByte    = 0C815h ; Вывод HEX числа на экран (байт)
113+  0000              bios_printString     = 0C818h ; Вывод строки на экран
114+  0000              bios_keyScan         = 0C81Bh ; Получить код нажатой клавиши
115+  0000              bios_getCursorPos    = 0C81Eh ; Получить координаты курсора в hl (координаты в пикселях)
116+  0000              bios_setCursorPos    = 0C821h ; Установить координаты курсора из hl (координаты в пикселях)
117+  0000              bios_tapeLoad        = 0C824h ; Загрузить программу с магнитофона
118+  0000              bios_tapeSave        = 0C827h ; Сохранить программу на магнитофон
119+  0000              bios_calcCS          = 0C82Ah ; Расчет контрольной суммы
120+  0000              bios_printHexWord    = 0C82Dh ; Вывод HEX числа на экран (слово)
121+  0000              bios_getMemTop       = 0C830h ; Получить объем доступной памяти
122+  0000              bios_setMemTop       = 0C833h ; Установить объем доступной памяти
123+  0000              bios_printer         = 0C836h ; Напечатать байт на принтере
124+  0000                  IF RAMFOS_COMPATIBILITY
125+  0000              bios_strToHex        = 0C839h ; Преобразвоние строки в HEX формате в число
126+  0000                  ELSE
127+  0000 ~            bios_rebootAlt       = 0C839h ; Запустить NC.COM
128+  0000                  ENDIF
129+  0000              bios_rebootAlt2      = 0C83Ch ; Запустить NC.COM
130+  0000              bios_fileList        = 0C83Fh ; Получить список файлов
131+  0000              bios_fileGetSetDrive = 0C842h ; Получить/установить активное устройство
132+  0000              bios_fileCreate      = 0C845h ; Создать файл
133+  0000              bios_fileLoad        = 0C848h ; Загрузить файл по адресу из заголовка этого файла
134+  0000              bios_fileDelete      = 0C84Bh ; Удалить файл
135+  0000              bios_fileRename      = 0C84Eh ; Переименовать файл
136+  0000              bios_fileLoadInfo    = 0C851h ; Загрузить информацию о файле
137+  0000              bios_fileGetSetAddr  = 0C854h ; Получить/установить адрес загрузки файла
138+  0000              bios_fileGetSetAttr  = 0C857h ; Получить/установить атрибуты файла
139+  0000              bios_fileNamePrepare = 0C85Ah ; Преобразовать имя файла во внутренний формат
140+  0000              bios_fileExec        = 0C85Dh ; Запустить файл
141+  0000              bios_installDriver   = 0C860h ; Установить драйвер накопителя
142+  0000              bios_diskDriver      = 0C863h ; Драйвер выбранного диска
143+  0000              bios_fileLoad2       = 0C866h ; Загрузить файл по адресу de
144+  0000              bios_printCharReal   = 0C869h ; Вывод символа на экран (только реальные символы)
145+  0000              bios_printDecWord    = 0C86Ch ; Вывод числа экран в десятичной форме
146+  0000              bios_setRAMDDriver   = 0C86Fh ; Установить драйвр рам-диска
147+  0000
148+  0000              ;-----------------------------------------------------------------------
149+  0000              ; Точки входа драйвера доступа к ДОЗУ
150+  0000              ;-----------------------------------------------------------------------
151+  0000
152+  0000              bios_RAMDRead  = 0FFC0h ; чтение из ДОЗУ
153+  0000              bios_RAMDWrite = 0FFD0h ; запись в  ДОЗУ
154+  0000
155+  0000              ;-----------------------------------------------------------------------
156+  0000              ; Адрес таблицы переходов драйвера магнитофона
157+  0000              ;-----------------------------------------------------------------------
158+  0000
159+  0000              TAPE_DRIVER_JUMPS = bios_tapeReadOld    ; размещается на месте бывшей п/п чтения байта
160+  0000
161+  0000              ;-----------------------------------------------------------------------
162+  0000              ; Порты устройств ПК "Специалист-MX2"
163+  0000              ;-----------------------------------------------------------------------
164+  0000
165+  0000              IO_KEYB_A       =  0FFE0h   ; ВВ55 клавиатуры
166+  0000              IO_KEYB_B       =  0FFE1h
167+  0000              IO_KEYB_C       =  0FFE2h
168+  0000              IO_KEYB_MODE    =  0FFE3h
169+  0000              IO_PROG_A       =  0FFE4h   ; ВВ55 программатора/флеш диска
170+  0000              IO_PROG_B       =  0FFE5h
171+  0000              IO_PROG_C       =  0FFE6h
172+  0000              IO_PROG_MODE    =  0FFE7h
173+  0000              IO_FDD_CMD      =  0FFE8h   ; контроллер дисковода ВГ93
174+  0000              IO_FDD_TRACK    =  0FFE9h
175+  0000              IO_FDD_SECTOR   =  0FFEAh
176+  0000              IO_FDD_DATA     =  0FFEBh
177+  0000              IO_TIMER_CH0    =  0FFECh   ; таймер ВИ53
178+  0000              IO_TIMER_CH1    =  0FFEDh
179+  0000              IO_TIMER_CH2    =  0FFEEh
180+  0000              IO_TIMER_MODE   =  0FFEFh
181+  0000              IO_FDD_REQ      =  0FFF0h   ; контроллер дисковода
182+  0000              IO_FDD_MOTOR    =  0FFF1h
183+  0000              IO_FDD_SIDE     =  0FFF2h
184+  0000              IO_FDD_DRIVE    =  0FFF3h
185+  0000              IO_COLOR        =  0FFF8h   ; регистр цвета
186+  0000              IO_PAGE_RAM     =  0FFFCh   ; порт включения основного ОЗУ
187+  0000              IO_PAGE_RAMD    =  0FFFDh   ; порт включения ОЗУ RAM-дисков
188+  0000              IO_PAGE_ROM     =  0FFFEh   ; порт включения ПЗУ
189+  0000              IO_PAGE_STD     =  0FFFFh   ; порт включения STD режима
190+  0000
191+  0000              ;-----------------------------------------------------------------------
192+  0000              ; Структура файловой системы
193+  0000              ;-----------------------------------------------------------------------
194+  0000
195+  0000              ; Структура каталога
196+  0000
197+  0000                  IF FAT16
198+  0000
199+  0000              DIR_DESCR_SIZE  = 32    ; Размер дескриптора файла в каталоге (байт)
200+  0000              DIR_NAME_LENGTH = 8     ; Длина имени файла  (байт)
201+  0000              FAT_ITEM_SIZE   = 2     ; Размер записи в таблице FAT (байт)
202+  0000
203+  0000              ;-----------------------------------------------------------------------
204+  0000              ; Десткриптор файла (одна запись в каталоге) FAT12/16/32
205+  0000              ;-----------------------------------------------------------------------
206+  0000
207+  0000                  STRUCT FILE_DESCRIPTOR  ; 32 байта
208+  0000 ~            name            BLOCK   DIR_NAME_LENGTH     ; смещение 00h, 8 байт  - имя файла
209+  0000 ~            ext             BLOCK   3                   ; смещение 08h, 3 байта - расширение имени файла
210+  0000 ~            attrib          BLOCK   1                   ; смещение 0Bh, 1 байт  - атрибуты файла
211+  0000 ~            checkSum        BLOCK   1  ; ntRes          ; смещение 0Ch, 1 байт  - контрольная сумма (!!! временный костыль, в FAT32 это ntRes - используются в Windows NT !!!)
212+  0000 ~            ctrTimeTenth    BLOCK   1                   ; смещение 0Dh, 1 байт  - (только FAT32) время создания файла, десятки миллисекунд (0-199)
213+  0000 ~            ctrTime         BLOCK   2                   ; смещение 0Eh, 2 байта - (только FAT32) время создания файла, секунды*2 (0-43200)
214+  0000 ~            ctrDate         BLOCK   2                   ; смещение 10h, 2 байта - (только FAT32) дата  создания файла
215+  0000 ~            loadAddress     BLOCK   2  ; accDate        ; смещение 12h, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый (!!! временный костыль, в FAT32 это accDate - дата доступа к файлу !!!)
216+  0000 ~            firstClusterHi  BLOCK   2                   ; смещение 14h, 2 байта - номер первого кластера в FAT, старшее слово
217+  0000 ~            wrtTime         BLOCK   2                   ; смещение 16h, 2 байта - время модификации файла, секунды*2 (0-43200)
218+  0000 ~            wrtDate         BLOCK   2                   ; смещение 18h, 2 байта - дата  модификации файла
219+  0000 ~            firstCluster    BLOCK   2                   ; смещение 1Ah, 2 байта - номер первого кластера в FAT, младшее слово
220+  0000 ~            size            BLOCK   4                   ; смещение 1Ch, 4 байта - размер файла в байтах
221+  0000                  ENDS
222+  0000
223+  0000              ;-----------------------------------------------------------------------
224+  0000              ; Десткриптор файла (одна запись в каталоге) FAT12/16/32
225+  0000              ;-----------------------------------------------------------------------
226+  0000
227+  0000                  ELSE
228+  0000 ~
229+  0000 ~            DIR_DESCR_SIZE  = 16    ; Размер дескриптора файла в каталоге
230+  0000 ~            DIR_NAME_LENGTH = 6     ; Длина имени файла (байт)
231+  0000 ~            FAT_ITEM_SIZE   = 1     ; Размер записи в таблице FAT (байт)
232+  0000 ~
233+  0000 ~            ;-----------------------------------------------------------------------
234+  0000 ~            ; Десткриптор файла (одна запись в каталоге) MXOS FAT8
235+  0000 ~            ;-----------------------------------------------------------------------
236+  0000 ~
237+  0000 ~                STRUCT FILE_DESCRIPTOR  ; 16 байт
238+  0000 ~            name            BLOCK   DIR_NAME_LENGTH     ; смещение 00h, 6 байт  - имя файла
239+  0000 ~            ext             BLOCK   3                   ; смещение 06h, 3 байта - расширение имени файла
240+  0000 ~            attrib          BLOCK   1                   ; смещение 09h, 1 байт  - атрибуты файла: 00h - обычный файл, 01h - системный файл
241+  0000 ~            loadAddress     BLOCK   2                   ; смещение 0Ah, 2 байта - начальный адрес загрузки в ОЗУ, он же и стартовый
242+  0000 ~            size            BLOCK   2                   ; смещение 0Ch, 2 байта - размер файла в байтах - 1
243+  0000 ~            checkSum        BLOCK   1                   ; смещение 0Eh, 1 байт  - контрольная сумма
244+  0000 ~            firstCluster    BLOCK   1                   ; смещение 0Fh, 1 байт  - номер первого кластера в FAT
245+  0000 ~                ENDS
246+  0000 ~
247+  0000 ~            ;-----------------------------------------------------------------------
248+  0000 ~            ; Десткриптор файла (одна запись в каталоге) MXOS FAT8
249+  0000 ~            ;-----------------------------------------------------------------------
250+  0000 ~
251+  0000                  ENDIF
252+  0000
253+  0000              ;-----------------------------------------------------------------------
254+  0000              ; Буферы в памяти
255+  0000              ;-----------------------------------------------------------------------
256+  0000
257+  0000              CLUSTER_SIZE     = 00100h                   ; размер кластера 256 байт
258+  0000              CLUSTERS_IN_BANK = 10000h / CLUSTER_SIZE    ; сколько кластеров в 64 кб банке
259+  0000
260+  0000                  IF FAT16
261+  0000
262+  0000              FAT_CLUSTERS  = 16      ; сколько кластеров занимает таблица fat
263+  0000              DIR_CLUSTERS  = 4       ; сколько кластеров занимает корневой каталог
264+  0000              FAT_BUFFER    = 8000h - (FAT_CLUSTERS + DIR_CLUSTERS) * CLUSTER_SIZE; адрес буфера таблицы fat в памяти
265+  0000
266+  0000                  ELSE
267+  0000 ~
268+  0000 ~            FAT_CLUSTERS  = 1       ; сколько кластеров занимает таблица fat
269+  0000 ~            DIR_CLUSTERS  = 3       ; сколько кластеров занимает корневой каталог
270+  0000 ~            FAT_BUFFER    = 0FB00h  ; адрес буфера таблицы fat в памяти
271+  0000 ~
272+  0000                  ENDIF
273+  0000
274+  0000              FAT_SIZE      = FAT_CLUSTERS * CLUSTER_SIZE  ; размер таблицы fat в байтах
275+  0000              DIR_SIZE      = DIR_CLUSTERS * CLUSTER_SIZE  ; размер корневого каталога в байтах
276+  0000
277+  0000              DIR_BUFFER    = FAT_BUFFER + FAT_SIZE         ; адрес буфера корневого каталога в памяти
278+  0000
279+  0000              DIR_MAX_FILES = DIR_CLUSTERS * 256 / DIR_DESCR_SIZE    ; Максимум файлов в каталоге
280+  0000
281+  0000              BAT_BUFFER    = 0FC00h  ; буфер для загрузки BAT файла
282+  0000              CMD_LINE      = 0FF00h  ; 192 байта, но в конце стек
283+  0000              STACK_ADDR    = 0FFC0h  ; стек
284+  0000
285+  0000              ;-----------------------------------------------------------------------
286+  0000              ; Всякие полезности
287+  0000              ;-----------------------------------------------------------------------
288+  0000
289+  0000              ; Макрос для заполнения памяти от текущего адреса до указанного
290+  0000                  MACRO ORG_PAD adr
291+  0000 ~                     IF $ > adr
292+  0000 ~                       ; вывод сообщения об ошибке
293+  0000 ~                       ASSERT 0
294+  0000 ~                       DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
295+  0000 ~                     ELSE
296+  0000 ~                       ; заполнение памяти
297+  0000 ~                       BLOCK adr-$, 0FFh
298+  0000 ~                     ENDIF
299+  0000 ~                     ORG adr
300+  0000                  ENDM
301+  0000
302+  0000                  MACRO ORG_PAD0 adr
303+  0000 ~                     IF $ > adr
304+  0000 ~                       ; вывод сообщения об ошибке
305+  0000 ~                       ASSERT 0
306+  0000 ~                       DISPLAY /l, "Error! ORG_PAD0 failed! ", $, " is more than ", adr
307+  0000 ~                     ELSE
308+  0000 ~                       ; заполнение памяти
309+  0000 ~                       BLOCK adr-$, 0
310+  0000 ~                     ENDIF
311+  0000 ~                     ORG adr
312+  0000                  ENDM
313+  0000
314+  0000              ; Макросы для проверки текущего адреса
315+  0000                  MACRO ASSERT_EQUAL adr
316+  0000 ~                     IF $ != adr
317+  0000 ~                       ASSERT 0
318+  0000 ~                       DISPLAY /l, "Error! Entry point has been shifted (", $, " != ", adr, ")"
319+  0000 ~                     ENDIF
320+  0000                  ENDM
321+  0000
322+  0000                  MACRO ASSERT_DONT_FIT adr
323+  0000 ~                     IF $ > adr
324+  0000 ~                       ASSERT 0
325+  0000 ~                       DISPLAY /l, "Error! Image did not fit (", $, " > ", adr, ")"
326+  0000 ~                     ENDIF
327+  0000                  ENDM
328+  0000
329+  0000              ;-----------------------------------------------------------------------
330+  0000              ; Конец
331+  0000              ;-----------------------------------------------------------------------
332+  0000
  9   0000
 10   0000              ; -----------------------------------------------------------------------
 11   0000              ; Код
 12   0000              ; Стандартные подпрограммы должны иметь фиксированный адрес для
 13   0000              ; совместимости. Они начинаются с ORG_PAD xxxx. В случае, если
 14   0000              ; предыдущая продпрограмма залезает на эту, транслятор выдаст ошибку.
 15   0000              ; -----------------------------------------------------------------------
 16   0000
 17   0000              	ORG     0C000h
 18   C000              	INCLUDE "jmps_c000.inc"
  1+  C000              ;+---------------------------------------------------------------------------
  2+  C000              ; MXOS
  3+  C000              ; Стандартные точки входа C000
  4+  C000              ;
  5+  C000              ; 2013-12-12 Дизассемблировано vinxru
  6+  C000              ;----------------------------------------------------------------------------
  7+  C000
  8+  C000 C3 09 C0                 jp    reboot        ; C000: Теплая перезагрузка
  9+  C003 C3 C7 C1     j_keyScan:  jp    keyScan2      ; C003: Получить код нажатой клавиши
 10+  C006 C3 4E C3                 jp    drawCursor3   ; C006: Нарисовать/стереть курсор
 11+  C009 31 C0 FF     reboot:     ld    sp, STACK_ADDR; C009: Теплая перезагрузка
 12+  C00C C3 5B C4                 jp    reboot1
 13+  C00F
 19   C00F
 20   C00F                  ORG_PAD 0C010h
 20   C00F             >         IF $ > 0C010h
 20   C00F ~           >           ; вывод сообщения об ошибке
 20   C00F ~           >           ASSERT 0
 20   C00F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 20   C00F             >         ELSE
 20   C00F             >           ; заполнение памяти
 20   C00F FF          >           BLOCK 0C010h-$, 0FFh
 20   C010             >         ENDIF
 20   C010             >         ORG 0C010h
 21   C010              	INCLUDE "clearScreen.inc"
  1+  C010              ;+---------------------------------------------------------------------------
  2+  C010              ; MXOS
  3+  C010              ; Очистить экран
  4+  C010              ;
  5+  C010              ; На выходе
  6+  C010              ;  bc, de, hl - сохраняются
  7+  C010              ;
  8+  C010              ; 2013-12-12 Дизассемблировано vinxru
  9+  C010              ;----------------------------------------------------------------------------
 10+  C010
 11+  C010              clearScreen:
 12+  C010                          ; bc, hl - сохраняем. de - не используется
 13+  C010 E5                       push  hl
 14+  C011 C5                       push  bc
 15+  C012
 16+  C012                          ; Сохранение sp
 17+  C012 21 00 00                 ld    hl, 0
 18+  C015 39                       add   hl,sp
 19+  C016 22 F6 8F                 ld    (bios_vars.oldSP), hl
 20+  C019
 21+  C019                          ; Устанавливаем sp в конец видеопамяти
 22+  C019 31 00 C0                 ld    sp, 0C000h
 23+  C01C
 24+  C01C                          ; Байт (слово) для заполнения памяти
 25+  C01C 2A FA 8F                 ld    hl, (bios_vars.inverse)
 26+  C01F
 27+  C01F                          ; Помещаем в стек 3000h байт
 28+  C01F 01 00 03                 ld    bc, 3000h / 16
 29+  C022              clearScreen_0:
 30+  C022 E5                       push      hl
 31+  C023 E5                       push      hl
 32+  C024 E5                       push      hl
 33+  C025 E5                       push      hl
 34+  C026 E5                       push      hl
 35+  C027 E5                       push      hl
 36+  C028 E5                       push      hl
 37+  C029 E5                       push      hl
 38+  C02A 0B                       dec bc
 39+  C02B 78                       ld  a, b
 40+  C02C B1                       or  c
 41+  C02D C2 22 C0                 jp nz,  clearScreen_0
 42+  C030
 43+  C030                          ; Восстанавливаем sp
 44+  C030 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 45+  C033 F9                       ld    sp, hl
 46+  C034
 47+  C034                          ; bc, hl были сохранены. de - не используется
 48+  C034 C1                       pop   bc
 49+  C035 E1                       pop   hl
 50+  C036 C9                       ret
 51+  C037
 22   C037
 23   C037                  ORG_PAD 0C037h
 23   C037             >         IF $ > 0C037h
 23   C037 ~           >           ; вывод сообщения об ошибке
 23   C037 ~           >           ASSERT 0
 23   C037 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 23   C037             >         ELSE
 23   C037             >           ; заполнение памяти
 23   C037             >           BLOCK 0C037h-$, 0FFh
 23   C037             >         ENDIF
 23   C037             >         ORG 0C037h
 24   C037              	INCLUDE "printChar.inc"
  1+  C037              ;+---------------------------------------------------------------------------
  2+  C037              ; MXOS
  3+  C037              ; Вывод символа на экран (или принтер)
  4+  C037              ;
  5+  C037              ; На входе
  6+  C037              ;  с - символ
  7+  C037              ;
  8+  C037              ; На выходе
  9+  C037              ;  Все регистры сохраняются
 10+  C037              ;
 11+  C037              ; 2013-12-12 Дизассемблировано vinxru
 12+  C037              ;----------------------------------------------------------------------------
 13+  C037
 14+  C037 F5           printChar:  push  af
 15+  C038 D5                       push  de
 16+  C039 C5                       push  bc
 17+  C03A E5                       push  hl
 18+  C03B CD C6 C5                 call  printChar2
 19+  C03E E1                       pop   hl
 20+  C03F C1                       pop   bc
 21+  C040 D1                       pop   de
 22+  C041 F1                       pop   af
 23+  C042 C9                       ret
 24+  C043
 25   C043
 26   C043                  ORG_PAD 0C045h
 26   C043             >         IF $ > 0C045h
 26   C043 ~           >           ; вывод сообщения об ошибке
 26   C043 ~           >           ASSERT 0
 26   C043 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 26   C043             >         ELSE
 26   C043             >           ; заполнение памяти
 26   C043 FF FF       >           BLOCK 0C045h-$, 0FFh
 26   C045             >         ENDIF
 26   C045             >         ORG 0C045h
 27   C045              	INCLUDE "printChar5.inc" ; Продолжается в drawChar
  1+  C045              ;+---------------------------------------------------------------------------
  2+  C045              ; MXOS
  3+  C045              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C045              ; Расчет адреса символа в знакогенераторе и адреса вывода на экран
  5+  C045              ;
  6+  C045              ; 2013-12-12 Дизассемблировано vinxru
  7+  C045              ;----------------------------------------------------------------------------
  8+  C045
  9+  C045              ; ---------------------------------------------------------------------------
 10+  C045              ; Обработка ESC+(. Выключение KOI-7
 11+  C045
 12+  C045 3E FF        printChar_e28:    ld    a, 0FFh
 13+  C047 32 EA 8F                 ld    (bios_vars.koi8), a
 14+  C04A C9                       ret
 15+  C04B
 16+  C04B              ; ---------------------------------------------------------------------------
 17+  C04B              ; Обработка ESC+). Включение KOI-7
 18+  C04B
 19+  C04B AF           printChar_e29:    xor   a
 20+  C04C 32 EA 8F                 ld    (bios_vars.koi8), a
 21+  C04F C9                       ret
 22+  C050
 23+  C050              ; ---------------------------------------------------------------------------
 24+  C050              ; Обработка кода 9. Табуляция
 25+  C050
 26+  C050 3A FD 8F     printChar_c9:     ld    a, (bios_vars.cursorX)
 27+  C053 C6 18                    add   a,24
 28+  C055 32 FD 8F                 ld    (bios_vars.cursorX),a
 29+  C058 C9                       ret
 30+  C059
 31+  C059              ; ---------------------------------------------------------------------------
 32+  C059              ; Вывод символа С из знакогенартора по адресу hl*8 на экран в положение
 33+  C059              ; курсора. Курсор при этом перемещается
 34+  C059
 35+  C059              printChar_alt:    ; de = (hl+c)*8
 36+  C059 06 00                    ld    b, 0
 37+  C05B 09                       add   hl, bc
 38+  C05C 29                       add   hl, hl
 39+  C05D 29                       add   hl, hl
 40+  C05E 29                       add   hl, hl
 41+  C05F EB                       ex    de, hl
 42+  C060
 43+  C060                          ; Продолжение в printChar_de
 44+  C060
 45+  C060              ; ---------------------------------------------------------------------------
 46+  C060              ; Вывод символа de на экран в положение курсора. Курсор при этом перемещается
 47+  C060              ; вправо.
 48+  C060
 49+  C060              printChar_de:     ; Рассчитываем адрес вывода (hl=v_cursorPos, a*256+l=адрес)
 50+  C060 CD 29 C3                 call  calcCursorAddr
 51+  C063
 52+  C063                          ; Перемещаем курсор вправо
 53+  C063 24                       inc   h
 54+  C064 24                       inc   h
 55+  C065 24                       inc   h
 56+  C066 22 FC 8F                 ld    (bios_vars.cursorY), hl
 57+  C069
 58+  C069                          ; Корректируем адрес вывода (bc = al - 7)
 59+  C069 47                       ld    b, a
 60+  C06A 7D                       ld    a, l
 61+  C06B D6 07                    sub   7
 62+  C06D 4F                       ld    c, a
 63+  C06E
 64+  C06E                          ; Продолжение в drawChar
 65+  C06E
 28   C06E              	INCLUDE "drawChar.inc"
  1+  C06E              ;+---------------------------------------------------------------------------
  2+  C06E              ; MXOS
  3+  C06E              ; Рисование символа на экране
  4+  C06E              ;
  5+  C06E              ; На входе
  6+  C06E              ;  bc - адрес символа
  7+  C06E              ;  de - адрес в видеопамяти
  8+  C06E              ;  h  - координата X в пикселях / 2
  9+  C06E              ;
 10+  C06E              ; 2013-12-12 Дизассемблировано vinxru
 11+  C06E              ;----------------------------------------------------------------------------
 12+  C06E
 13+  C06E                          ; Высота символа
 14+  C06E 2E 08                    ld    l, 8
 15+  C070
 16+  C070                          ; Переходим к одной из функций вывода
 17+  C070 7C                       ld    a, h
 18+  C071 E6 03                    and   3
 19+  C073 CA B5 C0                 jp z, drawChar0   ; a==0
 20+  C076 3D                       dec   a
 21+  C077 CA C5 C0                 jp z, drawChar1   ; a==1
 22+  C07A 3D                       dec   a
 23+  C07B CA 82 C0                 jp z, drawChar2   ; a==2
 24+  C07E 3D                       dec   a
 25+  C07F CA A3 C0                 jp z, drawChar3   ; a==3
 26+  C082                          ; Продолжение на drawChar2
 27+  C082
 28+  C082              ; ---------------------------------------------------------------------------
 29+  C082
 30+  C082 0A           drawChar2:  ld    a, (bc)
 31+  C083 E6 FC                    and   0FCh
 32+  C085 67                       ld    h, a
 33+  C086 1A                       ld    a, (de)
 34+  C087 0F                       rrca
 35+  C088 0F                       rrca
 36+  C089 0F                       rrca
 37+  C08A 0F                       rrca
 38+  C08B              drawChar2_cma:
 39+  C08B 2F                       cpl
 40+  C08C F5                       push  af
 41+  C08D E6 03                    and   3
 42+  C08F AC                       xor   h
 43+  C090 02                       ld    (bc), a
 44+  C091 04                       inc   b
 45+  C092 0A                       ld    a, (bc)
 46+  C093 E6 0F                    and   0Fh
 47+  C095 67                       ld    h, a
 48+  C096 F1                       pop   af
 49+  C097 E6 F0                    and   0F0h
 50+  C099 AC                       xor   h
 51+  C09A 02                       ld    (bc),a
 52+  C09B 05                       dec   b
 53+  C09C
 54+  C09C                          ; Цикл
 55+  C09C 03                       inc   bc
 56+  C09D 13                       inc   de
 57+  C09E 2D                       dec   l
 58+  C09F C2 82 C0                 jp nz,  drawChar2
 59+  C0A2 C9                       ret
 60+  C0A3
 61+  C0A3              ; ---------------------------------------------------------------------------
 62+  C0A3
 63+  C0A3 0A           drawChar3:  ld    a, (bc)
 64+  C0A4 E6 03                    and   3
 65+  C0A6 67                       ld    h, a
 66+  C0A7 1A                       ld    a, (de)
 67+  C0A8 07                       rlca
 68+  C0A9 07                       rlca
 69+  C0AA              drawChar3_xri:
 70+  C0AA EE FC                    xor   0FCh
 71+  C0AC AC                       xor   h
 72+  C0AD 02                       ld    (bc),a
 73+  C0AE
 74+  C0AE                          ; Цикл
 75+  C0AE 13                       inc   de
 76+  C0AF 03                       inc   bc
 77+  C0B0 2D                       dec   l
 78+  C0B1 C2 A3 C0                 jp nz,  drawChar3
 79+  C0B4 C9                       ret
 80+  C0B5
 81+  C0B5              ; ---------------------------------------------------------------------------
 82+  C0B5
 83+  C0B5 0A           drawChar0:  ld    a, (bc)
 84+  C0B6 E6 C0                    and   0C0h
 85+  C0B8 67                       ld    h, a
 86+  C0B9 1A                       ld    a, (de)
 87+  C0BA              drawChar0_xri:
 88+  C0BA EE 3F                    xor   3Fh
 89+  C0BC AC                       xor   h
 90+  C0BD 02                       ld    (bc),a
 91+  C0BE
 92+  C0BE                          ; Цикл
 93+  C0BE 13                       inc   de
 94+  C0BF 03                       inc   bc
 95+  C0C0 2D                       dec   l
 96+  C0C1 C2 B5 C0                 jp nz,  drawChar0
 97+  C0C4 C9                       ret
 98+  C0C5
 99+  C0C5              ; ---------------------------------------------------------------------------
100+  C0C5
101+  C0C5 0A           drawChar1:  ld    a, (bc)
102+  C0C6 E6 F0                    and   0F0h
103+  C0C8 67                       ld    h, a
104+  C0C9 1A                       ld    a, (de)
105+  C0CA 0F                       rrca
106+  C0CB 0F                       rrca
107+  C0CC              drawChar1_cma:
108+  C0CC 2F                       cpl
109+  C0CD E6 0F                    and   0Fh
110+  C0CF AC                       xor   h
111+  C0D0 02                       ld    (bc),a
112+  C0D1 04                       inc   b
113+  C0D2 0A                       ld    a, (bc)
114+  C0D3 E6 3F                    and   3Fh
115+  C0D5 67                       ld    h, a
116+  C0D6 1A                       ld    a, (de)
117+  C0D7 0F                       rrca
118+  C0D8 0F                       rrca
119+  C0D9              drawChar1_cma2:
120+  C0D9 2F                       cpl
121+  C0DA E6 C0                    and   0C0h
122+  C0DC AC                       xor   h
123+  C0DD 02                       ld    (bc),a
124+  C0DE 05                       dec   b
125+  C0DF
126+  C0DF                          ; Цикл
127+  C0DF 03                       inc   bc
128+  C0E0 13                       inc   de
129+  C0E1 2D                       dec   l
130+  C0E2 C2 C5 C0                 jp nz,  drawChar1
131+  C0E5 C9                       ret
132+  C0E6
133+  C0E6              ; ---------------------------------------------------------------------------
134+  C0E6              ; Вызывается из printChar_real2
135+  C0E6
136+  C0E6              normalVideo:
137+  C0E6                          ; Меняем CZ normalVideo на CNZ inverseVideo
138+  C0E6 21 02 C1                 ld    hl, inverseVideo
139+  C0E9 22 03 C6                 ld    (printChar_poly+1), hl
140+  C0EC 3E C4                    ld    a, 0C4h
141+  C0EE 32 02 C6                 ld    (printChar_poly),a
142+  C0F1
143+  C0F1                          ; Аргумент XRI
144+  C0F1 AF                       xor   a
145+  C0F2 32 BB C0                 ld    (drawChar0_xri+1),a
146+  C0F5 32 AB C0                 ld    (drawChar3_xri+1),a
147+  C0F8              normalVideo_1:
148+  C0F8                          ; Меняем CMA на NOP
149+  C0F8 32 8B C0                 ld    (drawChar2_cma),a
150+  C0FB 32 CC C0                 ld    (drawChar1_cma),a
151+  C0FE 32 D9 C0                 ld    (drawChar1_cma2),a
152+  C101 C9                       ret
153+  C102
154+  C102              ; ---------------------------------------------------------------------------
155+  C102              ; Вызывается из printChar_real2
156+  C102
157+  C102              inverseVideo:
158+  C102                          ; Меняем CNZ inverseVideo на CZ normalVideo
159+  C102 21 E6 C0                 ld    hl, normalVideo
160+  C105 22 03 C6                 ld    (printChar_poly+1), hl
161+  C108 3E CC                    ld    a, 0CCh
162+  C10A 32 02 C6                 ld    (printChar_poly),a
163+  C10D
164+  C10D                          ; Меняем аргумент XRI
165+  C10D 3E FC                    ld    a, 0FCh
166+  C10F 32 AB C0                 ld    (drawChar3_xri+1),a
167+  C112 3E 3F                    ld    a, 3Fh
168+  C114 32 BB C0                 ld    (drawChar0_xri+1),a
169+  C117
170+  C117                          ; Меняем NOP на CMA
171+  C117 3E 2F                    ld    a, 2Fh
172+  C119 C3 F8 C0                 jp    normalVideo_1
173+  C11C
 29   C11C              	INCLUDE "printChar3.inc"
  1+  C11C              ;+---------------------------------------------------------------------------
  2+  C11C              ; MXOS
  3+  C11C              ; Обработка служебных кодов при выводе символа
  4+  C11C              ;
  5+  C11C              ; На входе
  6+  C11C              ;  a - символ
  7+  C11C              ;
  8+  C11C              ; 2013-12-12 Дизассемблировано vinxru
  9+  C11C              ;----------------------------------------------------------------------------
 10+  C11C
 11+  C11C              printChar3: ; Код 7
 12+  C11C D6 07                    sub   7
 13+  C11E CA 70 C1                 jp z, beep
 14+  C121                          ; Код 8
 15+  C121 3D                       dec   a
 16+  C122 CA 4E C1                 jp z, printChar_c08
 17+  C125                          ; Код 10
 18+  C125 D6 02                    sub   2
 19+  C127 CA 96 C1                 jp z, printChar_c0A
 20+  C12A                          ; Код 12
 21+  C12A D6 02                    sub   2
 22+  C12C CA 46 C1                 jp z, printChar_c0C
 23+  C12F                          ; Код 13
 24+  C12F 3D                       dec   a
 25+  C130 CA 48 C1                 jp z, printChar_c0D
 26+  C133                          ; Код 24
 27+  C133 D6 0B                    sub   11
 28+  C135 CA 64 C1                 jp z, printChar_c18
 29+  C138                          ; Код 25
 30+  C138 3D                       dec   a
 31+  C139 CA 59 C1                 jp z, printChar_c19
 32+  C13C                          ; Код 26
 33+  C13C 3D                       dec   a
 34+  C13D CA 98 C1                 jp z, printChar_c1A
 35+  C140                          ; Продолжение, если код 31
 36+  C140 D6 05                    sub   5
 37+  C142 C0                       ret NZ
 38+  C143                          ; Код 31 очищает экран
 39+  C143 CD 10 C0                 call  clearScreen
 40+  C146
 41+  C146                          ; Продолжение в printChar_c0C
 42+  C146
 43+  C146              ; ---------------------------------------------------------------------------
 44+  C146              ; Обработка кода 0Ch. Курсор в левый верхний угол экрана
 45+  C146
 46+  C146              printChar_c0C:    ; bios_vars.cursorY = 8
 47+  C146 2E 08                    ld    l, 8
 48+  C148
 49+  C148                          ; Продолжение в printChar_c0D
 50+  C148
 51+  C148              ; ---------------------------------------------------------------------------
 52+  C148              ; Обработка кода 0Dh. Курсор в начало строки
 53+  C148
 54+  C148              printChar_c0D:    ; bios_vars.cursorX = 0
 55+  C148 AF                       xor   a
 56+  C149 67           saveVCursorHA:    ld    h, a
 57+  C14A 22 FC 8F     saveVCursor:      ld    (bios_vars.cursorY), hl
 58+  C14D C9                       ret
 59+  C14E
 60+  C14E              ; ---------------------------------------------------------------------------
 61+  C14E              ; Обработка кода 8h. Влево
 62+  C14E
 63+  C14E              printChar_c08:    ; cursorX -= 3
 64+  C14E 7C                       ld    a, h
 65+  C14F D6 03                    sub   3
 66+  C151
 67+  C151                          ; Если нет переноса, сохранить положение курсора и выйти
 68+  C151 D2 49 C1                 jp nc,  saveVCursorHA
 69+  C154
 70+  C154                          ; cursorX = 189
 71+  C154 26 BD                    ld    h, 189
 72+  C156 22 FC 8F                 ld    (bios_vars.cursorY), hl
 73+  C159
 74+  C159                          ; Продолжение в printChar_c19
 75+  C159
 76+  C159              ; ---------------------------------------------------------------------------
 77+  C159              ; Обработка кода 19h. Вверх
 78+  C159
 79+  C159              printChar_c19:    ; Если cursorY < 18, то выйти. Иначе cursorY -= 10
 80+  C159 7D                       ld    a, l
 81+  C15A D6 0A                    sub   0Ah
 82+  C15C D8                       ret c
 83+  C15D FE 08                    cp    8
 84+  C15F D8                       ret c
 85+  C160
 86+  C160              saveVCursorLA:    ; Сохранить положение курсора и выйти
 87+  C160 6F                       ld    l, a
 88+  C161 C3 4A C1                 jp    saveVCursor
 89+  C164
 90+  C164              ; ---------------------------------------------------------------------------
 91+  C164              ; Обработка кода 18h. Вправо
 92+  C164
 93+  C164              printChar_c18:    ; Если cursorX+3 >= 192, то перейти на printChar_c0A
 94+  C164                          ; Иначе cursorX += 3
 95+  C164 7C                       ld    a, h
 96+  C165 C6 03                    add   a,3
 97+  C167 FE C0                    cp    0C0h
 98+  C169 DA 49 C1                 jp c, saveVCursorHA
 99+  C16C C3 96 C1                 jp    printChar_c0A
100+  C16F
 30   C16F
 31   C16F                  ORG_PAD 0C170h
 31   C16F             >         IF $ > 0C170h
 31   C16F ~           >           ; вывод сообщения об ошибке
 31   C16F ~           >           ASSERT 0
 31   C16F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 31   C16F             >         ELSE
 31   C16F             >           ; заполнение памяти
 31   C16F FF          >           BLOCK 0C170h-$, 0FFh
 31   C170             >         ENDIF
 31   C170             >         ORG 0C170h
 32   C170              	INCLUDE "beep.inc"
  1+  C170              ;+---------------------------------------------------------------------------
  2+  C170              ; MXOS
  3+  C170              ; Звуковой сигнал (вызывается при выводе кода 7)
  4+  C170              ;
  5+  C170              ; Все регистры сохраняются
  6+  C170              ;
  7+  C170              ; 2013-12-12 Дизассемблировано vinxru
  8+  C170              ;----------------------------------------------------------------------------
  9+  C170
 10+  C170              beep:       ; Сохраняем все регистры. de не используется ниже
 11+  C170 F5                       push  af
 12+  C171 C5                       push  bc
 13+  C172 E5                       push  hl
 14+  C173
 15+  C173                          ; Частота и длительность сигнала
 16+  C173 2A F1 8F                 ld    hl, (bios_vars.beepFreq)
 17+  C176
 18+  C176              beep_0:     ; Единицу на динамик
 19+  C176 3E 0B                    ld    a, 0Bh
 20+  C178 32 E3 FF                 ld    (IO_KEYB_MODE),a
 21+  C17B
 22+  C17B                          ; Задержка l тактов
 23+  C17B CD 8F C1                 call  delay_l
 24+  C17E
 25+  C17E                          ; Ноль на динамик
 26+  C17E 3E 0A                    ld    a, 0Ah
 27+  C180 32 E3 FF                 ld    (IO_KEYB_MODE),a
 28+  C183
 29+  C183                          ; Задержка l тактов
 30+  C183 CD 8F C1                 call  delay_l
 31+  C186
 32+  C186                          ; Повторяем h раз
 33+  C186 25                       dec   h
 34+  C187 C2 76 C1                 jp nz,  beep_0
 35+  C18A
 36+  C18A                          ; Ничего не делаем
 37+  C18A 00                       nop
 38+  C18B
 39+  C18B                          ; Восстаналиваем все регистры и выходим. de не используется
 40+  C18B E1                       pop   hl
 41+  C18C C1                       pop   bc
 42+  C18D F1                       pop   af
 43+  C18E C9                       ret
 44+  C18F
 33   C18F
 34   C18F                  ORG_PAD 0C18Fh
 34   C18F             >         IF $ > 0C18Fh
 34   C18F ~           >           ; вывод сообщения об ошибке
 34   C18F ~           >           ASSERT 0
 34   C18F ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 34   C18F             >         ELSE
 34   C18F             >           ; заполнение памяти
 34   C18F             >           BLOCK 0C18Fh-$, 0FFh
 34   C18F             >         ENDIF
 34   C18F             >         ORG 0C18Fh
 35   C18F              	INCLUDE "delay_l.inc"
  1+  C18F              ;+---------------------------------------------------------------------------
  2+  C18F              ; MXOS
  3+  C18F              ; Задержка
  4+  C18F              ;
  5+  C18F              ; На входе
  6+  C18F              ;  l - задержка
  7+  C18F              ;
  8+  C18F              ; На выходе
  9+  C18F              ;  b - 0
 10+  C18F              ;
 11+  C18F              ; 2013-12-12 Дизассемблировано vinxru
 12+  C18F              ;----------------------------------------------------------------------------
 13+  C18F
 14+  C18F 45           delay_l:    ld      b, l
 15+  C190 05           delay_b:    dec     b       ; адрес этой инструкци должен быть 0C190h
 16+  C191 C2 90 C1                 jp nz,  delay_b
 17+  C194 C9                       ret
 18+  C195
 36   C195
 37   C195                  ORG_PAD 0C196h
 37   C195             >         IF $ > 0C196h
 37   C195 ~           >           ; вывод сообщения об ошибке
 37   C195 ~           >           ASSERT 0
 37   C195 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 37   C195             >         ELSE
 37   C195             >           ; заполнение памяти
 37   C195 FF          >           BLOCK 0C196h-$, 0FFh
 37   C196             >         ENDIF
 37   C196             >         ORG 0C196h
 38   C196              	INCLUDE "printChar4.inc" ; Продолжается в scrollUp
  1+  C196              ;+---------------------------------------------------------------------------
  2+  C196              ; MXOS
  3+  C196              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C196              ;
  5+  C196              ; 2013-12-12 Дизассемблировано vinxru
  6+  C196              ;----------------------------------------------------------------------------
  7+  C196
  8+  C196              ; ---------------------------------------------------------------------------
  9+  C196              ; Обработка кода 0Ah. Перевод строки
 10+  C196
 11+  C196              printChar_c0A:    ; cursorX = 0
 12+  C196 26 00                    ld    h, 0
 13+  C198
 14+  C198                          ; Продолжение в printChar_c1A
 15+  C198
 16+  C198              ; ---------------------------------------------------------------------------
 17+  C198              ; Обработка кода 1Ah. Вниз
 18+  C198
 19+  C198              printChar_c1A:    ; Если cursorY < 246, то cursorY += 10 и выход
 20+  C198 7D                       ld    a, l
 21+  C199 C6 0A                    add   a,10
 22+  C19B D2 60 C1                 jp nc,  saveVCursorLA
 23+  C19E
 24+  C19E                          ; Сохраняем положение курсора (изменен только cursorX)
 25+  C19E 22 FC 8F                 ld    (bios_vars.cursorY), hl
 26+  C1A1
 27+  C1A1                          ; Далее прокрутка экрана вверх
 28+  C1A1
 39   C1A1              	INCLUDE "scrollUp.inc"
  1+  C1A1              ;+---------------------------------------------------------------------------
  2+  C1A1              ; MXOS
  3+  C1A1              ; Прокрутка экрана вверх
  4+  C1A1              ;
  5+  C1A1              ; На выходе
  6+  C1A1              ;   af, bc - сохраняются
  7+  C1A1              ;
  8+  C1A1              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1A1              ;----------------------------------------------------------------------------
 10+  C1A1
 11+  C1A1                          ; Сохраняем регистры
 12+  C1A1 C5                       push  bc
 13+  C1A2 F5                       push  af
 14+  C1A3
 15+  C1A3                          ; Сохраняем sp
 16+  C1A3 21 00 00                 ld    hl, 0
 17+  C1A6 39                       add   hl,sp
 18+  C1A7 22 F6 8F                 ld    (bios_vars.oldSP), hl
 19+  C1AA
 20+  C1AA                          ; Прокрутка экрана вверх
 21+  C1AA 31 0A 90                 ld    sp, 900Ah   ; Откуда
 22+  C1AD 26 90                    ld    h, 90h      ; Куда
 23+  C1AF 06 30                    ld    b, 48       ; Столбцов
 24+  C1B1 C3 7B C7                 jp    scrollUp2
 25+  C1B4
 40   C1B4
 41   C1B4                  ; Буфер для копирования изображения символов при использовании шрифта из ПЗУ
 42   C1B4              v_char:
 43   C1B4 FF FF FF...      BLOCK   13, 0FFh
 44   C1C1
 45   C1C1              	INCLUDE "keyScan.inc"
  1+  C1C1              ;+---------------------------------------------------------------------------
  2+  C1C1              ; MXOS
  3+  C1C1              ; Получить код нажатой клавиши
  4+  C1C1              ;
  5+  C1C1              ; На выходе
  6+  C1C1              ;  a - код
  7+  C1C1              ;
  8+  C1C1              ; 2013-12-12 Дизассемблировано vinxru
  9+  C1C1              ;----------------------------------------------------------------------------
 10+  C1C1
 11+  C1C1 3E 83        setKeybMode83:    ld    a, 83h
 12+  C1C3 32 E3 FF                 ld    (IO_KEYB_MODE),a
 13+  C1C6 C9                       ret
 14+  C1C7
 15+  C1C7              ; ---------------------------------------------------------------------------
 16+  C1C7
 17+  C1C7              keyScan2:   ; Режим чтения ряда
 18+  C1C7 CD 54 C2                 call  setKeybMode82
 19+  C1CA
 20+  C1CA                          ; Одним чтением првоеряем все клавиши
 21+  C1CA 3A E1 FF                 ld    a, (IO_KEYB_B)
 22+  C1CD
 23+  C1CD                          ; Эти биты не используются в сканировании
 24+  C1CD F6 03                    or    3
 25+  C1CF
 26+  C1CF                          ; Ни одна клавиша не нажата
 27+  C1CF FE FF                    cp    0FFh
 28+  C1D1 C8                       ret Z
 29+  C1D2
 30+  C1D2                          ; Сохраняем регистры
 31+  C1D2 E5                       push  hl
 32+  C1D3 C5                       push  bc
 33+  C1D4 D5                       push  de
 34+  C1D5
 35+  C1D5                          ; Перебираем 12 столбцов кнопок
 36+  C1D5 21 FE 0F                 ld    hl, 0FFEh
 37+  C1D8 11 A8 C4                 ld    de, v_keybTbl + 11
 38+  C1DB 06 FF                    ld    b, 0FFh
 39+  C1DD 7C           loc_C1DD:   ld    a, h
 40+  C1DE 32 E2 FF                 ld    (IO_KEYB_C),a
 41+  C1E1 7D                       ld    a, l
 42+  C1E2 32 E0 FF                 ld    (IO_KEYB_A),a
 43+  C1E5 0F                       rrca
 44+  C1E6 2F                       cpl
 45+  C1E7 E6 04                    and   4
 46+  C1E9 4F                       ld    c, a
 47+  C1EA 3A E1 FF                 ld    a, (IO_KEYB_B)
 48+  C1ED B1                       or    c
 49+  C1EE
 50+  C1EE                          ; Перебираем 6 кнопок в столбце
 51+  C1EE 0E 06                    ld    c, 6
 52+  C1F0 0F                       rrca
 53+  C1F1 0F                       rrca
 54+  C1F2 0F           loc_C1F2:   rrca
 55+  C1F3 D4 0C C2                 call NC,    keybScan3
 56+  C1F6 0D                       dec   c
 57+  C1F7 C2 F2 C1                 jp nz,  loc_C1F2
 58+  C1FA
 59+  C1FA                          ; Цикл
 60+  C1FA 1B                       dec   de
 61+  C1FB 29                       add   hl, hl
 62+  C1FC 23                       inc   hl
 63+  C1FD 7C                       ld    a, h
 64+  C1FE C6 F0                    add   a,0F0h
 65+  C200 67                       ld    h, a
 66+  C201 DA DD C1                 jp c, loc_C1DD
 67+  C204
 68+  C204                          ; Режим ВВ55 по уполчанию
 69+  C204 CD 54 C2                 call  setKeybMode82
 70+  C207
 71+  C207                          ; Результат
 72+  C207 78                       ld    a, b
 73+  C208
 74+  C208                          ; Восстаналвиаем регистры
 75+  C208 D1                       pop   de
 76+  C209 C1                       pop   bc
 77+  C20A E1                       pop   hl
 78+  C20B C9                       ret
 79+  C20C
 80+  C20C              ;----------------------------------------------------------------------------
 81+  C20C
 82+  C20C D5           keybScan3:  push  de
 83+  C20D F5                       push  af
 84+  C20E 3E 06                    ld    a, 6        ; e += (6 - c) * 16
 85+  C210 91                       sub   c
 86+  C211 87                       add   a, a
 87+  C212 87                       add   a, a
 88+  C213 87                       add   a, a
 89+  C214 87                       add   a, a
 90+  C215 83                       add   a, e
 91+  C216 5F                       ld    e, a
 92+  C217 1A                       ld    a, (de)            ; b = *de;
 93+  C218 47                       ld    b, a
 94+  C219 F1                       pop   af
 95+  C21A D1                       pop   de
 96+  C21B C9                       ret
 97+  C21C
 46   C21C              	INCLUDE "getch2.inc"
  1+  C21C              ;----------------------------------------------------------------------------
  2+  C21C              ; MXOS
  3+  C21C              ; Ожидание ввода с клавиатуры
  4+  C21C              ;
  5+  C21C              ; На выходе
  6+  C21C              ;  ? - код
  7+  C21C              ;
  8+  C21C              ; 2013-12-12 Дизассемблировано vinxru
  9+  C21C              ;----------------------------------------------------------------------------
 10+  C21C
 11+  C21C              getch2:           ; Сохраняем регистры
 12+  C21C E5                       push  hl
 13+  C21D C5                       push  bc
 14+  C21E D5                       push  de
 15+  C21F
 16+  C21F                          ; Получаем код нажатой клавиши и сохраняем его в bios_vars.lastKey
 17+  C21F CD C7 C1                 call  keyScan2
 18+  C222 32 F0 8F                 ld    (bios_vars.lastKey),a
 19+  C225
 20+  C225              getch_retry:      ; Тут будет признак, нарисован курсор или нет
 21+  C225 0E 01                    ld    c, 1
 22+  C227
 23+  C227              loc_C227:   ; Рисуем курсор
 24+  C227 CD 4D C3                 call  drawCursor2
 25+  C22A
 26+  C22A                          ; Задержка
 27+  C22A 3A F4 8F                 ld    a, (bios_vars.cursorDelay)
 28+  C22D 06 40        loc_C22D:   ld    b, 40h
 29+  C22F CD 90 C1                 call  delay_b
 30+  C232 3D                       dec   a
 31+  C233 C2 2D C2                 jp nz,  loc_C22D
 32+  C236
 33+  C236              loc_C236:   ; Рисуем/стираем курсор
 34+  C236 CD 48 C3                 call  drawCursor
 35+  C239
 36+  C239                          ; Задержка мерцания курсора
 37+  C239 11 00 05                 ld    de, 500h
 38+  C23C
 39+  C23C              loc_C23C:   ; Получаем код нажатой клавиши
 40+  C23C CD C7 C1                 call  keyScan2
 41+  C23F FE 80                    cp    80h         ; х.з.
 42+  C241 FE FF                    cp    0FFh
 43+  C243 C2 60 C2                 jp nz,  getch2_pressed
 44+  C246
 45+  C246                          ; Записываем bios_vars.lastKey=0FFh
 46+  C246 32 F0 8F                 ld    (bios_vars.lastKey),a
 47+  C249
 48+  C249                          ; Повторяем 500h раз
 49+  C249 1B                       dec   de
 50+  C24A 7A                       ld    a, d
 51+  C24B B3                       or    e
 52+  C24C C2 3C C2                 jp nz,  loc_C23C
 53+  C24F
 54+  C24F                          ; Повтор всего
 55+  C24F C3 36 C2                 jp    loc_C236
 56+  C252
 57+  C252              ; ---------------------------------------------------------------------------
 58+  C252
 59+  C252 FF FF            DB 0FFh, 0FFh
 60+  C254
 61+  C254              ; ---------------------------------------------------------------------------
 62+  C254
 63+  C254 3E 82        setKeybMode82:    ld    a, 82h
 64+  C256 32 E3 FF                 ld    (IO_KEYB_MODE),a
 65+  C259 C9                       ret
 66+  C25A
 67+  C25A              ; ---------------------------------------------------------------------------
 68+  C25A
 69+  C25A 3E 91        setKeybMode91:    ld    a, 91h
 70+  C25C 32 E3 FF                 ld    (IO_KEYB_MODE),a
 71+  C25F C9                       ret
 72+  C260
 73+  C260              ; ---------------------------------------------------------------------------
 74+  C260              ; Была нажата клавиша
 75+  C260
 76+  C260              getch2_pressed:   ; Сохраняем код
 77+  C260 47                       ld    b, a
 78+  C261
 79+  C261                          ; Если нарисован курсор, стираем его
 80+  C261 79                       ld    a, c
 81+  C262 0F                       rrca
 82+  C263 DA 69 C2                 jp c, loc_C269
 83+  C266 CD 4D C3                 call  drawCursor2
 84+  C269              loc_C269:
 85+  C269 2A EF 8F                 ld    hl, (bios_vars.lastLastKey)   ; h = bios_vars.lastKey, l = bios_vars.lastLastKey
 86+  C26C 78                       ld    a, b        ; a = b = код нажатой клавиши
 87+  C26D BC                       cp    h
 88+  C26E C2 8D C2                 jp nz,  loc_C28D    ; Код нажатой клавиши изменился
 89+  C271 BD                       cp    l
 90+  C272 CA 95 C2                 jp z, loc_C295
 91+  C275
 92+  C275                          ; Рисуем курсор
 93+  C275 CD 48 C3                 call  drawCursor
 94+  C278
 95+  C278                          ; Ждем, пока отпустят клавишу
 96+  C278 3A F5 8F                 ld    a, (bios_vars.byte_8FF5)
 97+  C27B 57                       ld    d, a
 98+  C27C CD C7 C1     loc_C27C:   call  keyScan2
 99+  C27F BC                       cp    h
100+  C280 C2 27 C2                 jp nz,  loc_C227    ; Быстро нажали другую клавишу
101+  C283 15                       dec   d
102+  C284 C2 7C C2                 jp nz,  loc_C27C
103+  C287
104+  C287                          ; Долго держали
105+  C287
106+  C287                          ; Стираем курсор
107+  C287 CD 48 C3                 call  drawCursor
108+  C28A
109+  C28A C3 90 C2                 jp    loc_C290
110+  C28D              ; ---------------------------------------------------------------------------
111+  C28D
112+  C28D              loc_C28D:   ; Звуковой сигнал
113+  C28D CD 70 C1                 call  beep
114+  C290
115+  C290              loc_C290:   ;
116+  C290 6C                       ld    l, h
117+  C291 60                       ld    h, b  ; код нажатой и предыдущей клавиши сохраняем в bios_vars.lastKey
118+  C292 22 EF 8F                 ld    (bios_vars.lastLastKey), hl
119+  C295
120+  C295              loc_C295:   ; Не служеюбные клавиши CAPS LOCK, SHIFT и РУС/LAT не влияют
121+  C295 78                       ld    a, b
122+  C296 FE 21                    cp    21h
123+  C298 DA 10 C3                 jp c, getch_noShift
124+  C29B                              ; На клавиши c кодами 21h-3Fh влияет SHIFT
125+  C29B FE 40                    cp    40h
126+  C29D DA FE C2                 jp c, getch_shift
127+  C2A0                              ; На символьные клавиши (40h-7Eh) влияют CAPS LOCK, SHIFT и РУС/LAT
128+  C2A0 FE 7F                    cp    7Fh
129+  C2A2 DA DE C2                 jp c, getch_chars
130+  C2A5                              ; Не служеюбные клавиши (7Fh+) CAPS LOCK, SHIFT и РУС/LAT не влияют
131+  C2A5 CA 10 C3                 jp z, getch_noShift
132+  C2A8
133+  C2A8                          ; ...
134+  C2A8 00                       nop
135+  C2A9 00                       nop
136+  C2AA
137+  C2AA                              ; Переходим, если код клавиши не 81h
138+  C2AA FE 81                    cp    81h
139+  C2AC C2 10 C3                 jp nz,  getch_noShift
140+  C2AF
141+  C2AF                              ; Код клавиши 81h
142+  C2AF
143+  C2AF                          ; Если шифт не нажат
144+  C2AF 3A E1 FF                 ld    a, (IO_KEYB_B)
145+  C2B2 E6 02                    and   2
146+  C2B4 C2 6A C5                 jp nz,  loc_C55C
147+  C2B7
148+  C2B7                              ; Код клавиши 81h с шифтом
149+  C2B7
150+  C2B7                          ; Звуковой сигнал
151+  C2B7 CD 70 C1                 call  beep
152+  C2BA
153+  C2BA                          ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
154+  C2BA C3 A9 C5                 jp    getch_rc
155+  C2BD
156+  C2BD              ; ---------------------------------------------------------------------------
157+  C2BD              ; Нажата комбинация РУС/LAT
158+  C2BD
159+  C2BD              getch_rusLat:     ; на входе a = bios_vars.keyLocks
160+  C2BD EE 81                    xor   81h
161+  C2BF 32 EC 8F                 ld    (bios_vars.keyLocks),a
162+  C2C2
163+  C2C2                          ; Особый звуковой сигнал
164+  C2C2 3A F1 8F                 ld    a, (bios_vars.beepFreq)
165+  C2C5 F5                       push  af
166+  C2C6 3E 4F                    ld    a, 4Fh
167+  C2C8 32 F1 8F                 ld    (bios_vars.beepFreq),a
168+  C2CB CD 70 C1                 call  beep
169+  C2CE 3E 5F                    ld    a, 5Fh
170+  C2D0 32 F1 8F                 ld    (bios_vars.beepFreq),a
171+  C2D3 CD 70 C1                 call  beep
172+  C2D6 F1                       pop   af
173+  C2D7 32 F1 8F                 ld    (bios_vars.beepFreq),a
174+  C2DA
175+  C2DA                          ; ...
176+  C2DA 00                       nop
177+  C2DB
178+  C2DB C3 25 C2                 jp    getch_retry
179+  C2DE
180+  C2DE              ; ---------------------------------------------------------------------------
181+  C2DE              ; Включаем кирилицу или строчные буквы
182+  C2DE
183+  C2DE              getch_chars:      ; Если не нажат CAPS LOCK, пропускаем код ниже
184+  C2DE 3A EC 8F                 ld    a, (bios_vars.keyLocks)
185+  C2E1 4F                       ld    c, a
186+  C2E2 A7                       and   a
187+  C2E3 FA EA C2                 jp M, loc_C2EA    ; CAPS LOCK
188+  C2E6
189+  C2E6                          ; Превращаем заглавные в строчные
190+  C2E6 78                       ld    a, b
191+  C2E7 EE 20                    xor   20h
192+  C2E9 47                       ld    b, a
193+  C2EA
194+  C2EA              loc_C2EA:   ; Если зафиксирвоан ли РУС/ЛАТ, помещаем в c=1
195+  C2EA 79                       ld    a, c
196+  C2EB E6 01                    and   1
197+  C2ED 4F                       ld    c, a
198+  C2EE
199+  C2EE                          ; Если шифт нажат, помещаем в a=0
200+  C2EE 3A E1 FF                 ld    a, (IO_KEYB_B)
201+  C2F1 E6 02                    and   2
202+  C2F3 0F                       rrca                    ;! Как на счет флага c ?
203+  C2F4
204+  C2F4                          ; Превращаем английские символы в русские если a^c==0
205+  C2F4 A9                       xor   c
206+  C2F5 78                       ld    a, b
207+  C2F6 C2 B6 C5                 jp nz,  loc_C5A8
208+  C2F9 C6 80                    add   a,80h
209+  C2FB C3 B6 C5                 jp    loc_C5A8
210+  C2FE
211+  C2FE              ; ---------------------------------------------------------------------------
212+  C2FE              ; Меняем цифры на символы
213+  C2FE
214+  C2FE              getch_shift:      ; Если не нажат шифт, пропускаем код ниже
215+  C2FE 3A E1 FF                 ld    a, (IO_KEYB_B)
216+  C301 E6 02                    and   2
217+  C303 78                       ld    a, b
218+  C304 C2 B6 C5                 jp nz,  loc_C5A8
219+  C307
220+  C307                          ; Меняем цифры на символы
221+  C307 EE 10                    xor   10h
222+  C309
223+  C309                          ; Одно исключение 30h должен меняться на 5Fh
224+  C309 FE 20                    cp    20h
225+  C30B C2 10 C3                 jp nz,  getch_noShift
226+  C30E 3E 5F                    ld    a, 5Fh
227+  C310
228+  C310                          ; Прододжение getch_noShift
229+  C310
230+  C310              ; ---------------------------------------------------------------------------
231+  C310              ; Символы без изменений
232+  C310
233+  C310              getch_noShift:  ; Сохраняем код нажатой клавиши в b
234+  C310 47                       ld    b, a
235+  C311
236+  C311 CD C1 C1     loc_C311:   call  setKeybMode83
237+  C314 3E F7                    ld    a, 0F7h
238+  C316 32 E0 FF                 ld    (IO_KEYB_A),a
239+  C319 3A E1 FF                 ld    a, (IO_KEYB_B)
240+  C31C 2F                       cpl
241+  C31D 0F                       rrca
242+  C31E 0F                       rrca
243+  C31F 0F                       rrca
244+  C320 CD 54 C2                 call  setKeybMode82
245+  C323 00                       nop
246+  C324
247+  C324                          ; Восстаналиваем код нажатой клавиши
248+  C324 78                       ld    a, b
249+  C325
250+  C325              popa_ret_2: ; Восстаналиваем регистры и выходим
251+  C325 D1                       pop   de
252+  C326 C1                       pop   bc
253+  C327 E1                       pop   hl
254+  C328 C9                       ret
255+  C329
 47   C329              	INCLUDE "calcCursorAddr.inc"
  1+  C329              ;+---------------------------------------------------------------------------
  2+  C329              ; MXOS
  3+  C329              ; Расчет адреса курсора в видеопамяти. И перевод строки, если курсор был
  4+  C329              ; за правым краем экрана.
  5+  C329              ;
  6+  C329              ; На выходе
  7+  C329              ;  hl - координаты курсора
  8+  C329              ;  a * 256 + l - адрес в видеопамяти
  9+  C329              ;
 10+  C329              ; 2013-12-12 Дизассемблировано vinxru
 11+  C329              ;----------------------------------------------------------------------------
 12+  C329
 13+  C329              calcCursorAddr:   ; В hl положение курсора
 14+  C329 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 15+  C32C
 16+  C32C                          ; Если cursorX >= 190, то перевод строки (вывод кода 10)
 17+  C32C                          ; Иначе рассчитываем адрес старшего байта a = cursorX / 4 + 90h
 18+  C32C 7C                       ld    a, h
 19+  C32D FE BE                    cp    190
 20+  C32F DA 41 C3                 jp c, calcCursorAd_1
 21+  C332 0E 0A                    ld    c, 10
 22+  C334 C3 3A C3                 jp    calcCursorAd_0
 23+  C337
 48   C337
 49   C337                  ORG_PAD 0C337h
 49   C337             >         IF $ > 0C337h
 49   C337 ~           >           ; вывод сообщения об ошибке
 49   C337 ~           >           ASSERT 0
 49   C337 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 49   C337             >         ELSE
 49   C337             >           ; заполнение памяти
 49   C337             >           BLOCK 0C337h-$, 0FFh
 49   C337             >         ENDIF
 49   C337             >         ORG 0C337h
 50   C337              	INCLUDE "getch.inc"
  1+  C337              ;----------------------------------------------------------------------------
  2+  C337              ; MXOS
  3+  C337              ; Ожидание ввода с клавиатуры
  4+  C337              ;
  5+  C337              ; На выходе
  6+  C337              ;  ? - код
  7+  C337              ;
  8+  C337              ; 2013-12-12 Дизассемблировано vinxru
  9+  C337              ;----------------------------------------------------------------------------
 10+  C337
 11+  C337 C3 1C C2     getch:            jp    getch2
 12+  C33A
 51   C33A              	INCLUDE "calcCursorAddr2.inc"
  1+  C33A              ;+---------------------------------------------------------------------------
  2+  C33A              ; MXOS
  3+  C33A              ; Расчет адреса курсора в видеопамяти (продолжение);
  4+  C33A              ;
  5+  C33A              ; 2013-12-12 Дизассемблировано vinxru
  6+  C33A              ;----------------------------------------------------------------------------
  7+  C33A
  8+  C33A              calcCursorAd_0:   ; Перевод строки (на входе c=10)
  9+  C33A CD 37 C0                 call  printChar
 10+  C33D
 11+  C33D                          ; Восстановление регистров после printChar (хотя он не портит регистры)
 12+  C33D 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 13+  C340 7C                       ld    a, h
 14+  C341
 15+  C341              calcCursorAd_1:   ; Расчет старшего байта адреса
 16+  C341                          ; a = cursorX / 4 + 90h
 17+  C341 0F                       rrca
 18+  C342 0F                       rrca
 19+  C343 E6 3F                    and   3Fh
 20+  C345 C6 90                    add   a,90h
 21+  C347 C9                       ret
 22+  C348
 52   C348              	INCLUDE "drawCursor.inc"
  1+  C348              ;+---------------------------------------------------------------------------
  2+  C348              ; MXOS
  3+  C348              ; Рисование курсора на экране
  4+  C348              ;
  5+  C348              ; На выходе
  6+  C348              ;  bc, de, hl - сохраняются
  7+  C348              ;
  8+  C348              ; 2013-12-12 Дизассемблировано vinxru
  9+  C348              ;----------------------------------------------------------------------------
 10+  C348
 11+  C348              drawCursor: ; Если установлен 7-ой бит bios_vars.cursorCfg & 0x80, выходим
 12+  C348 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 13+  C34B A7                       and   a
 14+  C34C F8                       ret m
 15+  C34D
 16+  C34D              drawCursor2:      ; Курсор нарисован/стерт
 17+  C34D 0C                       inc   c
 18+  C34E
 19+  C34E              drawCursor3:      ; Сохраняем регистры
 20+  C34E E5                       push  hl
 21+  C34F C5                       push  bc
 22+  C350 D5                       push  de
 23+  C351
 24+  C351                          ; Рассчитываем адрес на экране
 25+  C351 CD 29 C3                 call  calcCursorAddr
 26+  C354 57                       ld    d, a
 27+  C355
 28+  C355                          ; Положение курсора от +2 до -5 (при битах 654 от 0 до 7)
 29+  C355                          ; b = bios_vars.cursorCfg
 30+  C355                          ; e = ~((bios_vars.cursorCfg / 16) % 8 - 3) + l
 31+  C355 3A E9 8F                 ld    a, (bios_vars.cursorCfg)
 32+  C358 47                       ld    b, a
 33+  C359 0F                       rrca
 34+  C35A 0F                       rrca
 35+  C35B 0F                       rrca
 36+  C35C 0F                       rrca
 37+  C35D E6 07                    and   7
 38+  C35F D6 03                    sub   3
 39+  C361 2F                       cpl
 40+  C362 85                       add   a, l
 41+  C363 5F                       ld    e, a
 42+  C364
 43+  C364                          ; Рассчитыаем маску курсора
 44+  C364                          ;  hl = 011111100b << (((~h) % 4 +1)*2)
 45+  C364 7C                       ld    a, h
 46+  C365 2F                       cpl
 47+  C366 E6 03                    and   3
 48+  C368 21 FC 00                 ld    hl, 011111100b ; FCh
 49+  C36B 3C                       inc   a
 50+  C36C 29           drawCursor_0:     add   hl, hl
 51+  C36D 29                       add   hl, hl
 52+  C36E C3 43 C4                 jp    drawCursor_1
 53+  C371
 53   C371
 54   C371                  ORG_PAD 0C377h
 54   C371             >         IF $ > 0C377h
 54   C371 ~           >           ; вывод сообщения об ошибке
 54   C371 ~           >           ASSERT 0
 54   C371 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 54   C371             >         ELSE
 54   C371             >           ; заполнение памяти
 54   C371 FF FF FF... >           BLOCK 0C377h-$, 0FFh
 54   C375             >         ENDIF
 54   C377             >         ORG 0C377h
 55   C377                  INCLUDE "tape.inc"
  1+  C377              ;----------------------------------------------------------------------------
  2+  C377              ; MXOS
  3+  C377              ; Таблица перехвата вызовов драйвера магнитофона
  4+  C377              ;
  5+  C377              ; Изначально все функции просто перезапускают систему.
  6+  C377              ; Адреса заменяются на реальные при установке драйвера.
  7+  C377              ;
  8+  C377              ; 2022-02-03 SpaceEngineer
  9+  C377              ;----------------------------------------------------------------------------
 10+  C377
 11+  C377 C3 00 C8     t_tapeRead:      jp bios_reboot
 12+  C37A C3 00 C8     t_tapeWrite:     jp bios_reboot
 13+  C37D C3 00 C8     t_tapeLoad:      jp bios_reboot
 14+  C380 C3 00 C8     t_tapeSave:      jp bios_reboot
 15+  C383 C3 00 C8     t_tapeLoadInt:   jp bios_reboot
 16+  C386 C3 00 C8     t_tapeReadError: jp bios_reboot
 17+  C389
 56   C389              	INCLUDE "cmp_hl_de_2.inc"
  1+  C389              ;+---------------------------------------------------------------------------
  2+  C389              ; MXOS
  3+  C389              ; Сравнить hl и de
  4+  C389              ;
  5+  C389              ; 2013-12-12 Дизассемблировано vinxru
  6+  C389              ;----------------------------------------------------------------------------
  7+  C389
  8+  C389              cmp_hl_de_2:
  9+  C389 7C                   ld    a, h
 10+  C38A BA                   cp    d
 11+  C38B D8                   ret   c
 12+  C38C C0                   ret   nz
 13+  C38D 7D                   ld    a, l
 14+  C38E BB                   cp    e
 15+  C38F C9                   ret
 16+  C390
 57   C390              	INCLUDE "sbb_de_hl_to_hl.inc"
  1+  C390              ;+---------------------------------------------------------------------------
  2+  C390              ; MXOS
  3+  C390              ; hl = de - hl
  4+  C390              ;
  5+  C390              ; 2013-12-12 Дизассемблировано vinxru
  6+  C390              ;----------------------------------------------------------------------------
  7+  C390
  8+  C390              sbb_de_hl_to_hl:
  9+  C390 7B                       ld    a, e
 10+  C391 95                       sub   l
 11+  C392 6F                       ld    l, a
 12+  C393 7A                       ld    a, d
 13+  C394 9C                       sbc   h
 14+  C395 67                       ld    h, a
 15+  C396 C9                       ret
 16+  C397
 58   C397              	INCLUDE "memmove_bc_hl.inc"
  1+  C397              ;+---------------------------------------------------------------------------
  2+  C397              ; MXOS
  3+  C397              ; Копирование накладывающихся блоков памяти (с ошибкой)
  4+  C397              ;
  5+  C397              ; На входе
  6+  C397              ;  hl - откуда
  7+  C397              ;  de - откуда, конечный адрес не включая
  8+  C397              ;  bc - куда, с увеличением адресов
  9+  C397              ;
 10+  C397              ; 2013-12-12 Дизассемблировано vinxru
 11+  C397              ;----------------------------------------------------------------------------
 12+  C397
 13+  C397              memmove_bc_hl:    ; Сохраняем регистры
 14+  C397 E5                       push  hl
 15+  C398 C5                       push  bc
 16+  C399 D5                       push  de
 17+  C39A
 18+  C39A                          ; Если b<h или c<l, то
 19+  C39A 78                       ld    a, b
 20+  C39B BC                       cp    h
 21+  C39C DA B9 C3                 jp c, memcpy_bc_hl2
 22+  C39F                          ; Тут не хватает jnz
 23+  C39F 79                       ld    a, c
 24+  C3A0 BD                       cp    l
 25+  C3A1 DA B9 C3                 jp c, memcpy_bc_hl2
 26+  C3A4
 27+  C3A4                          ; bc = bc + de - hl
 28+  C3A4 E5                       push  hl
 29+  C3A5 CD 90 C3                 call  sbb_de_hl_to_hl
 30+  C3A8 09                       add   hl, bc
 31+  C3A9 44                       ld    b, h
 32+  C3AA 4D                       ld    c, l
 33+  C3AB E1                       pop   hl
 34+  C3AC
 35+  C3AC              memcpyb_bc_de:    ; Копируем из de в bc с уменьшением адресов, пока hl не равно de
 36+  C3AC 1A                       ld    a, (de)
 37+  C3AD 02                       ld    (bc),a
 38+  C3AE CD 89 C3                 call  cmp_hl_de_2
 39+  C3B1 1B                       dec   de
 40+  C3B2 0B                       dec   bc
 41+  C3B3 C2 AC C3                 jp nz,  memcpyb_bc_de
 42+  C3B6
 43+  C3B6                          ; Восстановление регистров и выход
 44+  C3B6 C3 C3 C3                 jp    popDBH_ret2
 45+  C3B9
 46+  C3B9              ; ---------------------------------------------------------------------------
 47+  C3B9
 48+  C3B9              memcpy_bc_hl2:    ; Копируем из hl в bc с увеличением адресов, пока hl не равно de
 49+  C3B9 7E                       ld  a, (hl)
 50+  C3BA 02                       ld    (bc),a
 51+  C3BB CD 89 C3                 call  cmp_hl_de_2
 52+  C3BE 23                       inc   hl
 53+  C3BF 03                       inc   bc
 54+  C3C0 C2 B9 C3                 jp nz,  memcpy_bc_hl2
 55+  C3C3
 56+  C3C3              popDBH_ret2:      ; Восстановление регистров и выход
 57+  C3C3 D1                       pop   de
 58+  C3C4 C1                       pop   bc
 59+  C3C5 E1                       pop   hl
 60+  C3C6 C9                       ret
 61+  C3C7
 59   C3C7              	INCLUDE "memset_de_20_b.inc"
  1+  C3C7              ;+---------------------------------------------------------------------------
  2+  C3C7              ; MXOS
  3+  C3C7              ; Заполнить память пробелами
  4+  C3C7              ;
  5+  C3C7              ; На входе
  6+  C3C7              ;  de - адрес
  7+  C3C7              ;  b  - длина (0 считается за 256)
  8+  C3C7              ;
  9+  C3C7              ; 2013-12-12 Дизассемблировано vinxru
 10+  C3C7              ;----------------------------------------------------------------------------
 11+  C3C7
 12+  C3C7              memset_de_20_b:
 13+  C3C7 3E 20                    ld      a, ' '
 14+  C3C9              memset_de_a_b:
 15+  C3C9 12                       ld      (de), a
 16+  C3CA 13                       inc     de
 17+  C3CB 05                       dec     b
 18+  C3CC C2 C9 C3                 jp nz,  memset_de_a_b
 19+  C3CF C9                       ret
 20+  C3D0
 60   C3D0
 61   C3D0                  ORG_PAD 0C3D0h
 61   C3D0             >         IF $ > 0C3D0h
 61   C3D0 ~           >           ; вывод сообщения об ошибке
 61   C3D0 ~           >           ASSERT 0
 61   C3D0 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 61   C3D0             >         ELSE
 61   C3D0             >           ; заполнение памяти
 61   C3D0             >           BLOCK 0C3D0h-$, 0FFh
 61   C3D0             >         ENDIF
 61   C3D0             >         ORG 0C3D0h
 62   C3D0 C3 7A C3         jp  t_tapeWrite
 63   C3D3
 64   C3D3                  IF RAMFOS_COMPATIBILITY
 65   C3D3              	INCLUDE "strToHex.inc"
  1+  C3D3              ;+---------------------------------------------------------------------------
  2+  C3D3              ; MXOS
  3+  C3D3              ; Преобразвоние строки в 16-ричное число
  4+  C3D3              ; Заимствовано из RAMFOS
  5+  C3D3              ;
  6+  C3D3              ; На входе
  7+  C3D3              ;  de - Строка
  8+  C3D3              ;
  9+  C3D3              ; На выходе
 10+  C3D3              ;  bc       - Сохраняется
 11+  C3D3              ;  de       - Следующий символ за запятой или концом строки
 12+  C3D3              ;  jz       - Ошибка
 13+  C3D3              ;  jnz, jc  - Конец строки
 14+  C3D3              ;  jnz, jnc - Пробел или запятая
 15+  C3D3              ;  hl       - Число
 16+  C3D3              ;
 17+  C3D3              ; 2013-11-01 Дизассемблировано vinxru
 18+  C3D3              ;----------------------------------------------------------------------------
 19+  C3D3
 20+  C3D3              strToHex:
 21+  C3D3 21 00 00                 ld  hl, 0
 22+  C3D6
 23+  C3D6              strToHex_loop:    ; Чтение символа
 24+  C3D6 1A                       ld    a, (de)
 25+  C3D7 13                       inc   de
 26+  C3D8
 27+  C3D8                          ; Если конец строки, выходим с флагами NZ, c
 28+  C3D8 FE 0D                    cp    0Dh
 29+  C3DA CA 13 C4                 jp z, ora_a_stc_ret
 30+  C3DD
 31+  C3DD                          ; Если пробел или запятая, выходим с флагами NZ, NC
 32+  C3DD FE 2C                    cp    ','
 33+  C3DF CA 16 C4                 jp z, ora_a_ret
 34+  C3E2 FE 20                    cp    ' '
 35+  C3E4 CA 16 C4                 jp z, ora_a_ret
 36+  C3E7
 37+  C3E7                          ; Если некорректный символ, выходим с флагами С,Z
 38+  C3E7 D6 30                    sub   '0'
 39+  C3E9 FA 0D C4                 jp M, xra_a_stc_ret
 40+  C3EC
 41+  C3EC                          ; Если это цифра
 42+  C3EC FE 0A                    cp    10
 43+  C3EE FA FD C3                 jp M, strToHex_0
 44+  C3F1
 45+  C3F1                          ; Если некорректный символ, выходим с флагами С,Z
 46+  C3F1 FE 11                    cp    11h
 47+  C3F3 FA 0D C4                 jp M, xra_a_stc_ret
 48+  C3F6 FE 17                    cp    17h
 49+  C3F8 F2 0D C4                 jp p, xra_a_stc_ret
 50+  C3FB
 51+  C3FB                          ; Это буквы A..F
 52+  C3FB D6 07                    sub   'A'-'0'-10
 53+  C3FD
 54+  C3FD              strToHex_0:
 55+  C3FD                          ; hl *= 16
 56+  C3FD 29                       add   hl, hl
 57+  C3FE 29                       add   hl, hl
 58+  C3FF 29                       add   hl, hl
 59+  C400 29                       add   hl, hl
 60+  C401
 61+  C401                          ; Если переполнение, выходим c флагами С,Z
 62+  C401 DA 0D C4                 jp c, xra_a_stc_ret
 63+  C404
 64+  C404                          ; hl += bc
 65+  C404 C5                       push bc
 66+  C405 06 00                    ld   b, 0
 67+  C407 4F                       ld   c, a
 68+  C408 09                       add  hl, bc
 69+  C409 C1                       pop  bc
 70+  C40A
 71+  C40A C3 D6 C3                 jp    strToHex_loop
 72+  C40D
 73+  C40D              xra_a_stc_ret:    ; Вывод знака вопроса
 74+  C40D 0E 3F                    ld  c, '?'
 75+  C40F CD 37 C0                 call      printChar
 76+  C412 AF                       xor a
 77+  C413
 78+  C413              ora_a_stc_ret:
 79+  C413 B7                       or  a
 80+  C414 37                       scf
 81+  C415 C9                       ret
 82+  C416
 83+  C416              ora_a_ret:
 84+  C416 B7                       or  a
 85+  C417 C9                       ret
 86+  C418
 66   C418                  ENDIF
 67   C418                  ; Здесь есть свободное место (15 байт)
 68   C418
 69   C418                  ORG_PAD 0C427h
 69   C418             >         IF $ > 0C427h
 69   C418 ~           >           ; вывод сообщения об ошибке
 69   C418 ~           >           ASSERT 0
 69   C418 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 69   C418             >         ELSE
 69   C418             >           ; заполнение памяти
 69   C418 FF FF FF... >           BLOCK 0C427h-$, 0FFh
 69   C41C             >         ENDIF
 69   C427             >         ORG 0C427h
 70   C427              	INCLUDE "cmp_hl_de.inc"
  1+  C427              ;+---------------------------------------------------------------------------
  2+  C427              ; MXOS
  3+  C427              ; Сравнить hl и de
  4+  C427              ;
  5+  C427              ; 2013-12-12 Дизассемблировано vinxru
  6+  C427              ;----------------------------------------------------------------------------
  7+  C427
  8+  C427              cmp_hl_de:
  9+  C427 7C                   ld    a, h
 10+  C428 BA                   cp    d
 11+  C429 C0                   ret   nz
 12+  C42A 7D                   ld    a, l
 13+  C42B BB                   cp    e
 14+  C42C C9                   ret
 15+  C42D
 71   C42D
 72   C42D                  ORG_PAD 0C42Dh
 72   C42D             >         IF $ > 0C42Dh
 72   C42D ~           >           ; вывод сообщения об ошибке
 72   C42D ~           >           ASSERT 0
 72   C42D ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 72   C42D             >         ELSE
 72   C42D             >           ; заполнение памяти
 72   C42D             >           BLOCK 0C42Dh-$, 0FFh
 72   C42D             >         ENDIF
 72   C42D             >         ORG 0C42Dh
 73   C42D              	INCLUDE "memcpy_bc_hl.inc"
  1+  C42D              ;+---------------------------------------------------------------------------
  2+  C42D              ; MXOS
  3+  C42D              ; Скопировать блок памяти
  4+  C42D              ;
  5+  C42D              ; На входе
  6+  C42D              ;  hl - откуда начало
  7+  C42D              ;  de - откуда конец + 1
  8+  C42D              ;  (de-hl) - длина
  9+  C42D              ;  bc - куда
 10+  C42D              ;
 11+  C42D              ; На выходе
 12+  C42D              ;  de - сохраняется
 13+  C42D              ;
 14+  C42D              ; 2013-12-12 Дизассемблировано vinxru
 15+  C42D              ;----------------------------------------------------------------------------
 16+  C42D
 17+  C42D              memcpy_bc_hl:
 18+  C42D 7E                       ld      a, (hl)
 19+  C42E 02                       ld      (bc),a
 20+  C42F 23                       inc     hl
 21+  C430 03                       inc     bc
 22+  C431 CD 27 C4                 call    cmp_hl_de
 23+  C434 C2 2D C4                 jp nz,  memcpy_bc_hl
 24+  C437 C9                       ret
 25+  C438
 74   C438
 75   C438                  ORG_PAD 0C438h
 75   C438             >         IF $ > 0C438h
 75   C438 ~           >           ; вывод сообщения об ошибке
 75   C438 ~           >           ASSERT 0
 75   C438 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 75   C438             >         ELSE
 75   C438             >           ; заполнение памяти
 75   C438             >           BLOCK 0C438h-$, 0FFh
 75   C438             >         ENDIF
 75   C438             >         ORG 0C438h
 76   C438              	INCLUDE "printString1.inc"
  1+  C438              ;+---------------------------------------------------------------------------
  2+  C438              ; MXOS
  3+  C438              ; Вывод строки на экран
  4+  C438              ;
  5+  C438              ; На входе
  6+  C438              ;  hl - строка
  7+  C438              ;
  8+  C438              ; На выходе
  9+  C438              ;  af, bc, de - сохраняются
 10+  C438              ;
 11+  C438              ; 2013-12-12 Дизассемблировано vinxru
 12+  C438              ;----------------------------------------------------------------------------
 13+  C438
 14+  C438 C3 26 C5     printString1:     jp    printString
 15+  C43B
 77   C43B              	INCLUDE "printChar6.inc"
  1+  C43B              ;+---------------------------------------------------------------------------
  2+  C43B              ; MXOS
  3+  C43B              ; Обработка служебных кодов при выводе символа (продолжение)
  4+  C43B              ;
  5+  C43B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C43B              ;----------------------------------------------------------------------------
  7+  C43B
  8+  C43B              ; ---------------------------------------------------------------------------
  9+  C43B              ; Обработка ESC+F
 10+  C43B
 11+  C43B 3E 80        printChar_eF:   ld    a, 80h
 12+  C43D 32 EB 8F                     ld    (bios_vars.escMode), a
 13+  C440 C9                           ret
 14+  C441
 78   C441
 79   C441                  ORG_PAD 0C443h
 79   C441             >         IF $ > 0C443h
 79   C441 ~           >           ; вывод сообщения об ошибке
 79   C441 ~           >           ASSERT 0
 79   C441 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 79   C441             >         ELSE
 79   C441             >           ; заполнение памяти
 79   C441 FF FF       >           BLOCK 0C443h-$, 0FFh
 79   C443             >         ENDIF
 79   C443             >         ORG 0C443h
 80   C443                  INCLUDE "drawCursor2.inc"
  1+  C443              ;+---------------------------------------------------------------------------
  2+  C443              ; MXOS
  3+  C443              ; Рисование курсора на экране (продолжение)
  4+  C443              ;
  5+  C443              ; 2013-12-12 Дизассемблировано vinxru
  6+  C443              ;----------------------------------------------------------------------------
  7+  C443
  8+  C443              drawCursor_1:     ; Цикл
  9+  C443 3D                       dec   a
 10+  C444 C2 6C C3                 jp nz,  drawCursor_0
 11+  C447
 12+  C447                          ; b = vars.cursorCfg & 0xF
 13+  C447 78                       ld    a, b
 14+  C448 E6 0F                    and   0Fh
 15+  C44A 47                       ld    b, a
 16+  C44B
 17+  C44B                          ; Вывод курсора (b - высота, de - адрес на экране, hl - курсор)
 18+  C44B
 19+  C44B              drawCursor_2:     ; Повторить код ниже b раз
 20+  C44B 05                       dec   b
 21+  C44C FA 25 C3                 jp M, popa_ret_2
 22+  C44F
 23+  C44F                          ; *de--     ^= hl;
 24+  C44F 1A                       ld    a, (de)
 25+  C450 AC                       xor   h
 26+  C451 12                       ld    (de),a
 27+  C452 14                       inc   d
 28+  C453 1A                       ld    a, (de)
 29+  C454 AD                       xor   l
 30+  C455 12                       ld    (de),a
 31+  C456 15                       dec   d
 32+  C457 1D                       dec   e
 33+  C458 C3 4B C4                 jp    drawCursor_2
 34+  C45B
 81   C45B              	INCLUDE "reboot1.inc"
  1+  C45B              ;+---------------------------------------------------------------------------
  2+  C45B              ; MXOS
  3+  C45B              ; Перезагрузка (продолжение)
  4+  C45B              ;
  5+  C45B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C45B              ;----------------------------------------------------------------------------
  7+  C45B
  8+  C45B              reboot1:    ; Для выключения звука
  9+  C45B 3E 36                    ld    a, 36h
 10+  C45D
 11+  C45D                          ; Включаем ОЗУ
 12+  C45D 32 FC FF                 ld    (IO_PAGE_RAM), a
 13+  C460
 14+  C460                          ; Выключаем звук
 15+  C460 32 EF FF                 ld    (IO_TIMER_MODE), a
 16+  C463
 17+  C463                          ; Инициализация переменных
 18+  C463 21 7B C4                 ld    hl, initVars      ; Откуда
 19+  C466 11 9C C4                 ld    de, initVarsEnd   ; Конец
 20+  C469 01 DF 8F                 ld    bc, bios_vars     ; Куда
 21+  C46C CD 2D C4                 call  memcpy_bc_hl
 22+  C46F
 23+  C46F                          ; Установка цвета
 24+  C46F                  IF ENABLE_COLOR
 25+  C46F 3E F0                    ld    a, COLOR_BIOS
 26+  C471 32 F8 FF                 ld    (IO_COLOR), a
 27+  C474                  ELSE
 28+  C474 ~                        ld    a, 0Fh
 29+  C474 ~                        ld    (IO_KEYB_MODE), a
 30+  C474                  ENDIF
 31+  C474
 32+  C474                  IF LOAD_FONT
 33+  C474              onceInitFont:
 34+  C474 C3 C2 CF                 jp    initFont
 35+  C477                  ELSE
 36+  C477 ~                        jp    reboot2
 37+  C477                  ENDIF
 38+  C477
 82   C477
 83   C477                  ORG_PAD 0C478h
 83   C477             >         IF $ > 0C478h
 83   C477 ~           >           ; вывод сообщения об ошибке
 83   C477 ~           >           ASSERT 0
 83   C477 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
 83   C477             >         ELSE
 83   C477             >           ; заполнение памяти
 83   C477 FF          >           BLOCK 0C478h-$, 0FFh
 83   C478             >         ENDIF
 83   C478             >         ORG 0C478h
 84   C478 C3 86 C3         jp  t_tapeReadError
 85   C47B
 86   C47B              ;---------------------------------------------------------------------------
 87   C47B              ; Переменные
 88   C47B              ;---------------------------------------------------------------------------
 89   C47B
 90   C47B              ; Начальные значения переменных хранятся здесь, и при сбросе
 91   C47B              ; копируются на адрес bios_vars (=8FDFh) функцией reboot1
 92   C47B
 93   C47B FF FF 00 C8  initVars    BIOS_VARIABLES
 93   C47F FF FF FF FF
 93   C483 20 1D 11 FF
 93   C487 FF 3A FF FF
 93   C48B FF FF 5F 20
 93   C48F FF 20 E0 FF
 93   C493 FF 10 00 00
 93   C497 00 FF FF 28
 93   C49B 3C
 94   C49C
 95   C49C              initVarsEnd:
 96   C49C 00               DB 00h
 97   C49D
 98   C49D              ; Таблица кодов клавиатуры
 99   C49D
100   C49D              v_keybTbl:
101   C49D 81 0C 19 1A      DB 81h, 0Ch, 19h, 1Ah, 09h, 1Bh, 20h,  8,  80h, 18h, 0Ah, 0Dh, 0, 0, 0, 0
101   C4A1 09 1B 20 08
101   C4A5 80 18 0A 0D
101   C4A9 00 00 00 00
102   C4AD 71 7E 73 6D      DB 71h, 7Eh, 73h, 6Dh, 69h, 74h, 78h, 62h, 60h, 2Ch, 2Fh, 7Fh, 0, 0, 0, 0
102   C4B1 69 74 78 62
102   C4B5 60 2C 2F 7F
102   C4B9 00 00 00 00
103   C4BD 66 79 77 61      DB 66h, 79h, 77h, 61h, 70h, 72h, 6Fh, 6Ch, 64h, 76h, 7Ch, 2Eh, 0, 0, 0, 0
103   C4C1 70 72 6F 6C
103   C4C5 64 76 7C 2E
103   C4C9 00 00 00 00
104   C4CD 6A 63 75 6B      DB 6Ah, 63h, 75h, 6Bh, 65h, 6Eh, 67h, 7Bh, 7Dh, 7Ah, 68h, 3Ah, 0, 0, 0, 0
104   C4D1 65 6E 67 7B
104   C4D5 7D 7A 68 3A
104   C4D9 00 00 00 00
105   C4DD 3B 31 32 33      DB 3Bh, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh, 0, 0, 0, 0
105   C4E1 34 35 36 37
105   C4E5 38 39 30 2D
105   C4E9 00 00 00 00
106   C4ED 00 01 02 03      DB 00h, 01h, 02h, 03h, 04h, 05h, 06h, 07h, 8Ah, 8Bh, 8Ch, 1Fh, 0, 0, 0, 0
106   C4F1 04 05 06 07
106   C4F5 8A 8B 8C 1F
106   C4F9 00 00 00 00
107   C4FD
108   C4FD                  ORG_PAD 0C500h
108   C4FD             >         IF $ > 0C500h
108   C4FD ~           >           ; вывод сообщения об ошибке
108   C4FD ~           >           ASSERT 0
108   C4FD ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
108   C4FD             >         ELSE
108   C4FD             >           ; заполнение памяти
108   C4FD FF FF FF    >           BLOCK 0C500h-$, 0FFh
108   C500             >         ENDIF
108   C500             >         ORG 0C500h
109   C500              	INCLUDE "printer.inc"
  1+  C500              ;+---------------------------------------------------------------------------
  2+  C500              ; MXOS
  3+  C500              ; Вывод байта на принтер
  4+  C500              ;
  5+  C500              ; На входе
  6+  C500              ;   c - байт
  7+  C500              ;
  8+  C500              ; На выходе
  9+  C500              ;   af, bc, de, hl - cохраняются
 10+  C500              ;
 11+  C500              ; 2013-12-12 Дизассемблировано vinxru
 12+  C500              ;----------------------------------------------------------------------------
 13+  C500
 14+  C500              printer:    ; Сохраняем регистры
 15+  C500 F5                       push  af
 16+  C501
 17+  C501                          ; Режим порта расширения
 18+  C501 3E 90                    ld    a, 90h
 19+  C503 32 E7 FF                 ld    (IO_PROG_MODE), a
 20+  C506
 21+  C506                          ; Выводим байт на принтер
 22+  C506 79                       ld    a, c
 23+  C507 2F                       cpl
 24+  C508 32 E5 FF                 ld    (IO_PROG_B), a
 25+  C50B
 26+  C50B              printer_loop:     ; Выход     при нажатии любой клавиши
 27+  C50B 3A E1 FF                 ld    a, (IO_KEYB_B)
 28+  C50E E6 02                    and   2
 29+  C510 CA 24 C5                 jp z, printer_ret
 30+  C513
 31+  C513                          ; Ждем пока принтер не будет готов
 32+  C513 3A E4 FF                 ld    a, (IO_PROG_A)
 33+  C516 E6 40                    and   40h
 34+  C518 C2 0B C5                 jp nz,  printer_loop
 35+  C51B
 36+  C51B                          ; Строб
 37+  C51B 3E 03                    ld    a, 3
 38+  C51D 32 E6 FF                 ld    (IO_PROG_C), a
 39+  C520 AF                       xor   a
 40+  C521 32 E6 FF                 ld    (IO_PROG_C), a
 41+  C524
 42+  C524              printer_ret:      ; Восстаналвиаем регистры
 43+  C524 F1                       pop   af
 44+  C525 C9                       ret
 45+  C526
110   C526              	INCLUDE "printString.inc"
  1+  C526              ;+---------------------------------------------------------------------------
  2+  C526              ; MXOS
  3+  C526              ; Вывод строки на экран
  4+  C526              ;
  5+  C526              ; На входе
  6+  C526              ;  hl - строка
  7+  C526              ;
  8+  C526              ; На выходе
  9+  C526              ;  af, bc, de - сохраняются
 10+  C526              ;
 11+  C526              ; 2013-12-12 Дизассемблировано vinxru
 12+  C526              ;----------------------------------------------------------------------------
 13+  C526
 14+  C526              printString:      ; Сохраняем регистры
 15+  C526 C5                       push  bc
 16+  C527 F5                       push  af
 17+  C528
 18+  C528              printString_1:    ; Читаем очередной байт
 19+  C528 7E                       ld  a, (hl)
 20+  C529
 21+  C529                          ; Если прочитан 0, выходим
 22+  C529 B7                       or    a
 23+  C52A CA 35 C5                 jp z, printString_2
 24+  C52D
 25+  C52D                          ; Выводим байт на экран
 26+  C52D 4F                       ld    c, a
 27+  C52E CD 37 C0                 call  printChar
 28+  C531
 29+  C531                          ; Следующий байт
 30+  C531 23                       inc   hl
 31+  C532 C3 28 C5                 jp    printString_1
 32+  C535
 33+  C535              ; ---------------------------------------------------------------------------
 34+  C535
 35+  C535              printString_2:    ; Восстанавливаем регистры
 36+  C535 F1                       pop   af
 37+  C536 C1                       pop   bc
 38+  C537 C9                       ret
 39+  C538
111   C538              	INCLUDE "reboot2.inc"
  1+  C538              ;+---------------------------------------------------------------------------
  2+  C538              ; MXOS
  3+  C538              ; Перезагрузка (продолжение)
  4+  C538              ;
  5+  C538              ; 2013-12-12 Дизассемблировано vinxru
  6+  C538              ;----------------------------------------------------------------------------
  7+  C538
  8+  C538              reboot2:
  9+  C538                          ; Очищаем экран
 10+  C538 CD 10 C0                 call    clearScreen
 11+  C53B
 12+  C53B                  IF BOOT_FROM_TAPE
 13+  C53B ~                        ; Проверяем, нажата ли какая нибудь клавиша
 14+  C53B ~                        call    j_keyScan
 15+  C53B ~                        push    af
 16+  C53B                  ENDIF
 17+  C53B
 18+  C53B                          ; Выводим версию ОС на экран
 19+  C53B 21 0D CF                 ld      hl, txtBiosVer
 20+  C53E CD 38 C4                 call    printString1
 21+  C541
 22+  C541                          ; Определяем размер ДОЗУ
 23+  C541 21 BB FF                 ld      hl, RAMD_PAGE_END
 24+  C544 3A F8 8F                 ld      a, (bios_vars.ramPageCount)
 25+  C547 CD AD C7                 call    checkRAMD
 26+  C54A
 27+  C54A                          ; Выводим объем ДОЗУ на экран
 28+  C54A 21 1E CF                 ld      hl, txtRAM
 29+  C54D CD 38 C4                 call    printString1
 30+  C550
 31+  C550                          ; Вычисляем объем ДОЗУ в байтах
 32+  C550 3A F8 8F                 ld      a, (bios_vars.ramPageCount)
 33+  C553 26 00                    ld      h, 0
 34+  C555 6F                       ld      l, a    ; hl = объём в страницах
 35+  C556 2C                       inc     l       ; +1 страница - основная память
 36+  C557 29                       add     hl, hl
 37+  C558 29                       add     hl, hl
 38+  C559 29                       add     hl, hl
 39+  C55A 29                       add     hl, hl
 40+  C55B 29                       add     hl, hl
 41+  C55C 29                       add     hl, hl  ; hl = hl * 64
 42+  C55D EB                       ex      hl, de
 43+  C55E CD AF CE                 call    printDecWord
 44+  C561
 45+  C561 21 25 CF                 ld      hl, txtKB
 46+  C564 CD 38 C4                 call    printString1
 47+  C567
 48+  C567                      IF BOOT_FROM_TAPE==0
 49+  C567
 50+  C567                          ; Продолжаем загрузку системы
 51+  C567 C3 00 C8                 jp      j_reboot3
 52+  C56A
 53+  C56A                      ELSE
 54+  C56A ~
 55+  C56A ~                        ; Если не нажата ни одна клавиша, продолжаем загрузку системы
 56+  C56A ~                        pop     af
 57+  C56A ~                        inc     a
 58+  C56A ~                        jp z,   j_reboot3
 59+  C56A ~
 60+  C56A ~                        ; Загружаем драйвер магнитофона
 61+  C56A ~                        ld      hl, aATape_com
 62+  C56A ~                        call    fileExec
 63+  C56A ~
 64+  C56A ~                        ; Загружаем программу с ленты (без контроля КС) и запускаем
 65+  C56A ~                        ld      hl, txtLoadingFromTape
 66+  C56A ~                        call    printString1
 67+  C56A ~                        call    t_tapeLoadInt
 68+  C56A ~                        ld      hl, (bios_vars.tapeAddr)
 69+  C56A ~                        jp      (hl)
 70+  C56A ~
 71+  C56A                      ENDIF
 72+  C56A
112   C56A              	INCLUDE "getch3.inc"
  1+  C56A              ;----------------------------------------------------------------------------
  2+  C56A              ; MXOS
  3+  C56A              ; Ожидание ввода с клавиатуры (продолжение)
  4+  C56A              ;
  5+  C56A              ; На выходе
  6+  C56A              ;  ? - код
  7+  C56A              ;
  8+  C56A              ; 2013-12-12 Дизассемблировано vinxru
  9+  C56A              ;----------------------------------------------------------------------------
 10+  C56A
 11+  C56A              loc_C55C:   ; Если нажат лишь РУС/LAT - то обрабатываем его как CAPS/LOCK
 12+  C56A CD 5A C2                 call  setKeybMode91
 13+  C56D 3E F8                    ld    a, 0F8h
 14+  C56F 32 E1 FF                 ld    (IO_KEYB_B),a
 15+  C572 3A E0 FF                 ld    a, (IO_KEYB_A)
 16+  C575 F5                       push  af
 17+  C576 CD 54 C2                 call  setKeybMode82
 18+  C579 F1                       pop   af
 19+  C57A E6 08                    and   8
 20+  C57C C2 96 C5                 jp nz,  getch_capsLock
 21+  C57F
 22+  C57F                          ; Меняем KOI-7 / KOI-8
 23+  C57F 3A EA 8F                 ld    a, (bios_vars.koi8)
 24+  C582 2F                       cpl
 25+  C583 32 EA 8F                 ld    (bios_vars.koi8),a
 26+  C586
 27+  C586                          ; Звуковой сигнал
 28+  C586 CD 70 C1                 call  beep
 29+  C589
 30+  C589 3E 3A                    ld    a, 3Ah
 31+  C58B 32 EC 8F                 ld    (bios_vars.keyLocks),a
 32+  C58E
 33+  C58E                          ; Меняем частоту
 34+  C58E 3E 5F                    ld    a, 5Fh
 35+  C590 32 F1 8F                 ld    (bios_vars.beepFreq),a
 36+  C593
 37+  C593 C3 25 C2                 jp    getch_retry
 38+  C596
 39+  C596              ; ---------------------------------------------------------------------------
 40+  C596              ; CAPS LOCK для KOI-7
 41+  C596
 42+  C596              getch_capsLock:   ; Переключаем capsLock
 43+  C596 3A EC 8F                 ld    a, (bios_vars.keyLocks)
 44+  C599 EE 80                    xor   80h
 45+  C59B 32 EC 8F                 ld    (bios_vars.keyLocks),a
 46+  C59E
 47+  C59E                          ; Изменяем высоту звуковго сигнала
 48+  C59E 3A F1 8F                 ld    a, (bios_vars.beepFreq)
 49+  C5A1 EE 10                    xor   10h
 50+  C5A3 32 F1 8F                 ld    (bios_vars.beepFreq),a
 51+  C5A6
 52+  C5A6                          ; Ждем следующую клавишу
 53+  C5A6 C3 25 C2                 jp    getch_retry
 54+  C5A9
 55+  C5A9              ; ---------------------------------------------------------------------------
 56+  C5A9              ; CAPS LOCK для KOI-7 или РУС/LAT для KOI-8
 57+  C5A9
 58+  C5A9              getch_rc:   ; В режиме KOI-8 мы переключаем кодировку
 59+  C5A9 3A EA 8F                 ld    a, (bios_vars.koi8)
 60+  C5AC 3C                       inc   a
 61+  C5AD
 62+  C5AD 3A EC 8F                 ld    a, (bios_vars.keyLocks) ; Требуется в getch_rusLat
 63+  C5B0 C2 BD C2                 jp nz,  getch_rusLat
 64+  C5B3
 65+  C5B3                          ; В режиме KOI-7 мы перключаем регистр
 66+  C5B3 C3 96 C5                 jp    getch_capsLock
 67+  C5B6
 68+  C5B6              ; ---------------------------------------------------------------------------
 69+  C5B6
 70+  C5B6              loc_C5A8:   ; Включен KOI-7
 71+  C5B6 47                       ld    b, a
 72+  C5B7
 73+  C5B7 3A E1 FF                 ld    a, (IO_KEYB_B)
 74+  C5BA E6 02                    and   2
 75+  C5BC C2 11 C3                 jp nz,  loc_C311
 76+  C5BF
 77+  C5BF 3E A0                    ld    a, 0A0h
 78+  C5C1 A8                       xor   b
 79+  C5C2 47                       ld    b, a
 80+  C5C3
 81+  C5C3 C3 11 C3                 jp    loc_C311
 82+  C5C6
113   C5C6              	INCLUDE "printChar2.inc"	; Продолжается в scrollDown
  1+  C5C6              ;+---------------------------------------------------------------------------
  2+  C5C6              ; MXOS
  3+  C5C6              ; Вывод символа на экран (или принтер)
  4+  C5C6              ;
  5+  C5C6              ; На входе
  6+  C5C6              ;  с - символ
  7+  C5C6              ;
  8+  C5C6              ; На выходе
  9+  C5C6              ;  регистры не сохраняются
 10+  C5C6              ;
 11+  C5C6              ; 2013-12-12 Дизассемблировано vinxru
 12+  C5C6              ;----------------------------------------------------------------------------
 13+  C5C6
 14+  C5C6              printChar2:
 15+  C5C6                          ; Помещаем в hl координаты курсора
 16+  C5C6 2A FC 8F                 ld  hl, (bios_vars.cursorY)
 17+  C5C9
 18+  C5C9                          ; Продолжаем, если не включен режим обработки ESC последовательности (bios_vars.escMode==0FFh)
 19+  C5C9 3A EB 8F                 ld  a, (bios_vars.escMode)
 20+  C5CC 3C                       inc a
 21+  C5CD C2 6B C6                 jp  nz,  printChar_esc
 22+  C5D0
 23+  C5D0                          ; Тут bios_vars.escMode==0FFh
 24+  C5D0
 25+  C5D0                          ; Если это печатные символы (>=20h), переходим к печати
 26+  C5D0 79                       ld  a, c
 27+  C5D1 FE 20                    cp  ' '
 28+  C5D3 D2 E5 C5                 jp  nc, printChar_real
 29+  C5D6
 30+  C5D6                          ; Это табуляция
 31+  C5D6 FE 09                    cp  9
 32+  C5D8 CA 50 C0                 jp  z, printChar_c9      ; там bios_vars.cursorX+=24 и ret
 33+  C5DB
 34+  C5DB                          ; Любой символ кроме ESC
 35+  C5DB FE 1B                    cp  1Bh
 36+  C5DD C2 1C C1                 jp  nz, printChar3
 37+  C5E0
 38+  C5E0                          ; Далее ESC. Включаем режим обработки ESC последовательности (bios_vars.escMode=0)
 39+  C5E0 AF                       xor a
 40+  C5E1 32 EB 8F                 ld  (bios_vars.escMode),a
 41+  C5E4 C9                       ret
 42+  C5E5
 43+  C5E5              ; ---------------------------------------------------------------------------
 44+  C5E5              ; Преобразование символа из KOI-7 в KOI-8 и вывод на экран (служебные коды
 45+  C5E5              ; так же будут выводится)
 46+  C5E5
 47+  C5E5              printChar_real:
 48+  C5E5                          ; Символ для печати
 49+  C5E5 4F                       ld  c, a
 50+  C5E6
 51+  C5E6                          ; Продолжаем, если включен режим KOI-7
 52+  C5E6 3A EA 8F                 ld  a, (bios_vars.koi8)
 53+  C5E9 3C                       inc a
 54+  C5EA C2 FE C5                 jp  nz, printChar_real2
 55+  C5ED
 56+  C5ED                          ; Если символ больше или равен 0C0h просто выходим
 57+  C5ED 79                       ld  a, c
 58+  C5EE FE C0                    cp  0C0h
 59+  C5F0 D0                       ret nc
 60+  C5F1
 61+  C5F1                          ; Если символ находится в пределах 60h ... 7Fh, увеличиваем его код на 80h
 62+  C5F1 FE 60                    cp  60h
 63+  C5F3 DA FE C5                 jp  c, printChar_real2
 64+  C5F6 FE 80                    cp  80h
 65+  C5F8 D2 FE C5                 jp  nc,  printChar_real2
 66+  C5FB C6 80                    add a, 80h
 67+  C5FD 4F                       ld  c, a
 68+  C5FE
 69+  C5FE              ; ---------------------------------------------------------------------------
 70+  C5FE              ; Вывод символа на экран в KOI-8 (служебные коды так же будут выводится)
 71+  C5FE
 72+  C5FE              printChar_real2:
 73+  C5FE                          ; Тут полиморфизм
 74+  C5FE 3A FA 8F                 ld    a, (bios_vars.inverse)
 75+  C601 A7                       and   a
 76+  C602
 77+  C602              printChar_poly:
 78+  C602 CC E6 C0                 call z, normalVideo
 79+  C605
 80+  C605                          ; Если bios_vars.charGen не равен 0FFFFh, то используется знакогнератор по адресу bios_vars.charGen*8
 81+  C605 2A E7 8F                 ld    hl, (bios_vars.charGen)
 82+  C608 7C                       ld    a, h
 83+  C609 3C                       inc   a
 84+  C60A C2 59 C0                 jp nz,  printChar_alt
 85+  C60D 7D                       ld    a, l
 86+  C60E 3C                       inc   a
 87+  C60F C2 59 C0                 jp nz,  printChar_alt
 88+  C612
 89+  C612                          ; Иначе используем символы из ПЗУ.
 90+  C612                          ; Адрес символа в ПЗУ (de = 0x800 + c*8)
 91+  C612 21 00 01                 ld    hl, 100h
 92+  C615 06 00                    ld    b,  0
 93+  C617 09                       add   hl, bc
 94+  C618 29                       add   hl, hl
 95+  C619 29                       add   hl, hl
 96+  C61A 29                       add   hl, hl
 97+  C61B EB                       ex    de, hl
 98+  C61C
 99+  C61C                          ; Промежуточное место для символа
100+  C61C 21 B4 C1                 ld    hl, v_char
101+  C61F E5                       push  hl
102+  C620
103+  C620                          ; Копируем 8 байт из ПЗУ
104+  C620 32 FE FF                 ld    (IO_PAGE_ROM),a
105+  C623 1A                       ld    a, (de)
106+  C624 77                       ld    (hl), a
107+  C625 23                       inc   hl
108+  C626 13                       inc   de
109+  C627 1A                       ld    a, (de)
110+  C628 77                       ld    (hl), a
111+  C629 23                       inc   hl
112+  C62A 13                       inc   de
113+  C62B 1A                       ld    a, (de)
114+  C62C 77                       ld    (hl), a
115+  C62D 23                       inc   hl
116+  C62E 13                       inc   de
117+  C62F 1A                       ld    a, (de)
118+  C630 77                       ld    (hl), a
119+  C631 23                       inc   hl
120+  C632 13                       inc   de
121+  C633 1A                       ld    a, (de)
122+  C634 77                       ld    (hl), a
123+  C635 23                       inc   hl
124+  C636 13                       inc   de
125+  C637 1A                       ld    a, (de)
126+  C638 77                       ld    (hl), a
127+  C639 23                       inc   hl
128+  C63A 13                       inc   de
129+  C63B 1A                       ld    a, (de)
130+  C63C 77                       ld    (hl), a
131+  C63D 23                       inc   hl
132+  C63E 13                       inc   de
133+  C63F 1A                       ld    a, (de)
134+  C640 77                       ld    (hl), a
135+  C641 32 FC FF                 ld    (IO_PAGE_RAM),a
136+  C644
137+  C644                          ; Вывод символа
138+  C644 D1                       pop   de
139+  C645 C3 60 C0                 jp    printChar_de
140+  C648
141+  C648              ; ---------------------------------------------------------------------------
142+  C648              ; Обработка режима ESC+F
143+  C648
144+  C648              printChar_esc80:; Если символ с кодом 0, выключаем режим обработки ESC
145+  C648 79                       ld    a, c
146+  C649 B7                       or    a
147+  C64A CA 66 C6                 jp z, printChar_esc80_exit
148+  C64D
149+  C64D                          ; Обработка кодов < 20h
150+  C64D FE 20                    cp    20h
151+  C64F DA 1C C1                 jp c, printChar3
152+  C652
153+  C652                          ; Если код >= 80h, выйти
154+  C652 FE 80                    cp    80h
155+  C654 D0                       ret nc
156+  C655
157+  C655                          ; Если c >= 40h, вывести на экран c+40h
158+  C655 FE 40                    cp    40h
159+  C657 D2 60 C6                 jp nc,  printChar_esc80_2
160+  C65A
161+  C65A                          ; Иначе вывести c - 20h
162+  C65A D6 20                    sub   20h ; ' '
163+  C65C 4F                       ld    c, a
164+  C65D C3 FE C5                 jp    printChar_real2
165+  C660
166+  C660              ; ---------------------------------------------------------------------------
167+  C660
168+  C660              printChar_esc80_2:
169+  C660                          ; Если c >= 40h, вывести на экран c+40h
170+  C660 C6 40                    add   a,40h
171+  C662 4F                       ld    c, a
172+  C663 C3 FE C5                 jp    printChar_real2
173+  C666
174+  C666              ; ---------------------------------------------------------------------------
175+  C666
176+  C666              printChar_esc80_exit:
177+  C666 3D                       dec   a
178+  C667 32 EB 8F                 ld    (bios_vars.escMode),a
179+  C66A C9                       ret
180+  C66B
181+  C66B              ; ---------------------------------------------------------------------------
182+  C66B              ; Печать символа в ESC-режиме
183+  C66B
184+  C66B              printChar_esc:    ; Перейти если bios_vars.escMode=80h
185+  C66B 3A EB 8F                 ld    a, (bios_vars.escMode)
186+  C66E FE 80                    cp    80h
187+  C670 CA 48 C6                 jp z, printChar_esc80
188+  C673
189+  C673                          ; Выключить режим обработки ESC последовательности
190+  C673 F5                       push  af
191+  C674 3E FF                    ld    a, 0FFh
192+  C676 32 EB 8F                 ld    (bios_vars.escMode),a
193+  C679 F1                       pop   af
194+  C67A
195+  C67A                          ; Перейти если bios_vars.escMode==0
196+  C67A B7                       or    a
197+  C67B CA B5 C6                 jp z, printChar_esc0
198+  C67E
199+  C67E                          ; Перейти если обработка ESC+Y (bios_vars.escMode==1)
200+  C67E 3D                       dec   a
201+  C67F CA 8B C6                 jp z, printChar_esc1
202+  C682
203+  C682                          ; Перейти если bios_vars.escMode==2
204+  C682 3D                       dec   a
205+  C683 CA A7 C6                 jp z, printChar_esc2
206+  C686
207+  C686                          ; Перейти если bios_vars.escMode==3
208+  C686 3D                       dec   a
209+  C687 CA 1B C7                 jp z, printChar_esc3
210+  C68A
211+  C68A                          ; Выйти
212+  C68A C9                       ret
213+  C68B
214+  C68B              ; ---------------------------------------------------------------------------
215+  C68B              ; Обработка ESC+Y
216+  C68B
217+  C68B              printChar_esc1:   ; Если код меньше 20h или больше 20h + 24, то пропускаем установку Y
218+  C68B 79                       ld    a, c
219+  C68C FE 39                    cp    20h + 25
220+  C68E D2 A1 C6                 jp nc,  loc_C693
221+  C691 D6 20                    sub   20h
222+  C693 DA A1 C6                 jp c, loc_C693
223+  C696
224+  C696                          ; cursorY = 8 + a*10
225+  C696 87                       add   a, a
226+  C697 4F                       ld    c, a
227+  C698 81                       add   a, c
228+  C699 81                       add   a, c
229+  C69A 81                       add   a, c
230+  C69B 81                       add   a, c
231+  C69C C6 08                    add   a,8
232+  C69E 32 FC 8F                 ld    (bios_vars.cursorY),a
233+  C6A1
234+  C6A1              loc_C693:   ; Следующий символ будет обработан в printChar_esc2
235+  C6A1 3E 02                    ld    a, 2
236+  C6A3 32 EB 8F                 ld    (bios_vars.escMode),a
237+  C6A6 C9                       ret
238+  C6A7
239+  C6A7              ; ---------------------------------------------------------------------------
240+  C6A7              ; Обработка ESC+Y
241+  C6A7
242+  C6A7              printChar_esc2:   ; Если код меньше 20h или больше 20h + 63, то пропускаем установку X
243+  C6A7 79                       ld    a, c
244+  C6A8 FE 60                    cp    60h
245+  C6AA D0                       ret nc
246+  C6AB D6 20                    sub   20h
247+  C6AD D8                       ret c
248+  C6AE
249+  C6AE                          ; cursorX = c*3;
250+  C6AE 4F                       ld    c, a
251+  C6AF 87                       add   a, a
252+  C6B0 81                       add   a, c
253+  C6B1 32 FD 8F                 ld    (bios_vars.cursorX),a
254+  C6B4 C9                       ret
255+  C6B5
256+  C6B5              ; ---------------------------------------------------------------------------
257+  C6B5              ; Обработка первого символа ESC последовательности
258+  C6B5
259+  C6B5              printChar_esc0:   ; Если код больше 20h
260+  C6B5 79                       ld    a, c
261+  C6B6 FE 28                    cp    '(' ; 28h
262+  C6B8 CA 45 C0                 jp z, printChar_e28
263+  C6BB FE 29                    cp    ')' ; 29h
264+  C6BD CA 4B C0                 jp z, printChar_e29
265+  C6C0 FE 50                    cp    'P' ; 50h
266+  C6C2 CA 0B C7                 jp z, printChar_eP
267+  C6C5 D6 41                    sub   'A' ; 41h
268+  C6C7 CA 11 C7                 jp z, printChar19
269+  C6CA 3D                       dec   a ; 'b' 42h
270+  C6CB CA 16 C7                 jp z, printChar1A
271+  C6CE 3D                       dec   a ; 'c' 43h
272+  C6CF CA F7 C6                 jp z, printChar18
273+  C6D2 3D                       dec   a ; 'd' 44h
274+  C6D3 CA FC C6                 jp z, printChar08
275+  C6D6 3D                       dec   a ; 'e' 45h
276+  C6D7 CA 01 C7                 jp z, printChar1F
277+  C6DA 3D                       dec   a ; 'F' 46h
278+  C6DB CA 3B C4                 jp z, printChar_eF
279+  C6DE 3D                       dec   a
280+  C6DF 3D                       dec   a ; 'h' 48h
281+  C6E0 CA 06 C7                 jp z, printChar0C
282+  C6E3 3D                       dec   a ; 'I' 49h
283+  C6E4 CA 35 C7                 jp z, printChar_eI
284+  C6E7 3D                       dec   a
285+  C6E8 3D                       dec   a
286+  C6E9 D6 0E                    sub   14 ; 'Y' 59h
287+  C6EB CA F1 C6                 jp z, setEscMode_eY
288+  C6EE
289+  C6EE                          ; Вывод символа
290+  C6EE C3 C6 C5                 jp    printChar2
291+  C6F1
292+  C6F1              ; ---------------------------------------------------------------------------
293+  C6F1              ; Обработка ESC+Y.
294+  C6F1
295+  C6F1              setEscMode_eY:    ; Следующий символ будет обработан в printChar_esc1
296+  C6F1 3E 01                    ld    a, 1
297+  C6F3 32 EB 8F                 ld    (bios_vars.escMode),a
298+  C6F6 C9                       ret
299+  C6F7
300+  C6F7              ; ---------------------------------------------------------------------------
301+  C6F7
302+  C6F7              printChar18:
303+  C6F7 0E 18                    ld    c, 18h
304+  C6F9 C3 C6 C5                 jp    printChar2
305+  C6FC
306+  C6FC              ; ---------------------------------------------------------------------------
307+  C6FC
308+  C6FC              printChar08:
309+  C6FC 0E 08                    ld    c, 8
310+  C6FE C3 C6 C5                 jp    printChar2
311+  C701
312+  C701              ; ---------------------------------------------------------------------------
313+  C701
314+  C701 0E 1F        printChar1F:      ld    c, 1Fh
315+  C703 C3 C6 C5                 jp    printChar2
316+  C706
317+  C706              ; ---------------------------------------------------------------------------
318+  C706
319+  C706              printChar0C:
320+  C706 0E 0C                    ld    c, 0Ch
321+  C708 C3 C6 C5                 jp    printChar2
322+  C70B
323+  C70B              ; ---------------------------------------------------------------------------
324+  C70B              ; Обработка ESP+P. Вклчюение режима эхопечати на принтере
325+  C70B
326+  C70B              printChar_eP:
327+  C70B 3E 03                    ld    a, 3
328+  C70D 32 EB 8F                 ld    (bios_vars.escMode),a
329+  C710 C9                       ret
330+  C711
331+  C711              ; ---------------------------------------------------------------------------
332+  C711
333+  C711              printChar19:
334+  C711 0E 19                    ld    c, 19h
335+  C713 C3 C6 C5                 jp    printChar2
336+  C716
337+  C716              ; ---------------------------------------------------------------------------
338+  C716
339+  C716              printChar1A:
340+  C716 0E 1A                    ld    c, 1Ah
341+  C718 C3 C6 C5                 jp    printChar2
342+  C71B
343+  C71B              ; ---------------------------------------------------------------------------
344+  C71B              ; Режим эхопечати на принтере. Включается ESC+P
345+  C71B
346+  C71B              printChar_esc3:
347+  C71B                          ; Выходим, из режима, если код нулевой
348+  C71B 79                       ld    a, c
349+  C71C B7                       or    a
350+  C71D C8                       ret z
351+  C71E
352+  C71E                          ; Печать на принтере
353+  C71E CD 00 C5                 call  printer
354+  C721
355+  C721                          ; Печать на экране
356+  C721 CD C6 C5                 call  printChar2
357+  C724
358+  C724                          ; Находимся в этом режиме до кода 0 или ESC
359+  C724 3E 03                    ld    a, 3
360+  C726 32 EB 8F                 ld    (bios_vars.escMode),a
361+  C729 C9                       ret
362+  C72A
363+  C72A              ; ---------------------------------------------------------------------------
364+  C72A              ; Продолжение обработки ESC+I. Перемещение курсора вверх с прокруткой экрана
365+  C72A
366+  C72A              printChar_eI_2:
367+  C72A                          ; Если cursorY > 18, перемещаем курсор вверх и выходим
368+  C72A FE 13                    cp    19
369+  C72C D2 C6 C5                 jp nc,  printChar2
370+  C72F
371+  C72F                          ; Устанаваливаем bios_vars.cursorY=8
372+  C72F 3E 08                    ld    a, 8
373+  C731 32 FC 8F                 ld    (bios_vars.cursorY),a
374+  C734 C9                       ret
375+  C735
376+  C735              ; ---------------------------------------------------------------------------
377+  C735              ; Обработка ESC+I. Перемещение курсора вверх с прокруткой экрана
378+  C735
379+  C735              printChar_eI:
380+  C735                          ; Используется дальше функцией printChar2
381+  C735 0E 19                    ld    c, 19h
382+  C737
383+  C737                          ; Прокручиваем экран вних, только если bios_vars.cursorY == 8.
384+  C737                          ; иначе переходим на printChar_eI_2
385+  C737 3A FC 8F                 ld    a, (bios_vars.cursorY)
386+  C73A FE 08                    cp    8
387+  C73C C2 2A C7                 jp nz,  printChar_eI_2
388+  C73F
114   C73F              	INCLUDE "scrollDown.inc"
  1+  C73F              ;+---------------------------------------------------------------------------
  2+  C73F              ; MXOS
  3+  C73F              ; Прокрутка экрана вниз
  4+  C73F              ;
  5+  C73F              ; На выходе
  6+  C73F              ;   af, bc - сохраняются
  7+  C73F              ;
  8+  C73F              ; 2013-12-12 Дизассемблировано vinxru
  9+  C73F              ;----------------------------------------------------------------------------
 10+  C73F
 11+  C73F                          ; Сохраняем регистры
 12+  C73F C5                       push    bc
 13+  C740 F5                       push    af
 14+  C741 21 00 00                 ld      hl, 0
 15+  C744 39                       add     hl,sp
 16+  C745 22 F6 8F                 ld      (bios_vars.oldSP), hl
 17+  C748
 18+  C748                          ; Подготовка переменных
 19+  C748 31 00 C0                 ld      sp, 0C000h    ; Куда
 20+  C74B 26 BF                    ld      h, 0BFh       ; Откуда
 21+  C74D 06 30                    ld      b, 48         ; Столбцов
 22+  C74F 0E 29        loc_C741:   ld      c, 246 / 6    ; 246 строк
 23+  C751 2E F5                    ld      l, 245        ; Начинаем с 245 строки
 24+  C753
 25+  C753              loc_C745:   ; Копируем 6 байт из hl в sp
 26+  C753 56                       ld      d, (hl)
 27+  C754 2B                       dec     hl
 28+  C755 5E                       ld      e, (hl)
 29+  C756 2B                       dec     hl
 30+  C757 D5                       push    de
 31+  C758 56                       ld      d, (hl)
 32+  C759 2B                       dec     hl
 33+  C75A 5E                       ld      e, (hl)
 34+  C75B 2B                       dec     hl
 35+  C75C D5                       push    de
 36+  C75D 56                       ld      d, (hl)
 37+  C75E 2B                       dec     hl
 38+  C75F 5E                       ld      e, (hl)
 39+  C760 2B                       dec     hl
 40+  C761 D5                       push    de
 41+  C762
 42+  C762                          ; Цикл
 43+  C762 0D                       dec     c
 44+  C763 C2 53 C7                 jp nz,  loc_C745
 45+  C766
 46+  C766                          ; Сохраняем h
 47+  C766 7C                       ld      a, h
 48+  C767
 49+  C767                          ; Очищаем верхние 10 строк
 50+  C767 2A FA 8F                 ld      hl, (bios_vars.inverse)
 51+  C76A E5                       push    hl
 52+  C76B E5                       push    hl
 53+  C76C E5                       push    hl
 54+  C76D E5                       push    hl
 55+  C76E E5                       push    hl
 56+  C76F
 57+  C76F                          ; Восстанавливаем h
 58+  C76F 67                       ld      h, a
 59+  C770
 60+  C770                          ; Следующий столбец
 61+  C770 05                       dec     b
 62+  C771 C2 4F C7                 jp nz,  loc_C741
 63+  C774
 64+  C774                          ; Восстанавлиаем регистры и выходим
 65+  C774 2A F6 8F                 ld      hl, (bios_vars.oldSP)
 66+  C777 F9                       ld      sp, hl
 67+  C778 F1                       pop     af
 68+  C779 C1                       pop     bc
 69+  C77A C9                       ret
 70+  C77B
115   C77B              	INCLUDE "scrollUp2.inc"
  1+  C77B              ;+---------------------------------------------------------------------------
  2+  C77B              ; MXOS
  3+  C77B              ; Прокрутка экрана вверх (продолжение)
  4+  C77B              ;
  5+  C77B              ; 2013-12-12 Дизассемблировано vinxru
  6+  C77B              ;----------------------------------------------------------------------------
  7+  C77B
  8+  C77B              scrollUp2:  ; Копируем 246 байт из sp в H0
  9+  C77B 0E 29                    ld    c, 246 / 6
 10+  C77D 2E 00                    ld    l, 0
 11+  C77F
 12+  C77F              scrollUp2_0:      ; Копирование 6 байт из sp в hl
 13+  C77F D1                       pop   de
 14+  C780 73                       ld  (hl), e
 15+  C781 23                       inc   hl
 16+  C782 72                       ld  (hl), d
 17+  C783 23                       inc   hl
 18+  C784 D1                       pop   de
 19+  C785 73                       ld  (hl), e
 20+  C786 23                       inc   hl
 21+  C787 72                       ld  (hl), d
 22+  C788 23                       inc   hl
 23+  C789 D1                       pop   de
 24+  C78A 73                       ld  (hl), e
 25+  C78B 23                       inc   hl
 26+  C78C 72                       ld  (hl), d
 27+  C78D 23                       inc   hl
 28+  C78E
 29+  C78E                          ; Цикл
 30+  C78E 0D                       dec   c
 31+  C78F C2 7F C7                 jp nz,  scrollUp2_0
 32+  C792
 33+  C792                          ; Сохраняем h
 34+  C792 7C                       ld    a, h
 35+  C793
 36+  C793                          ; Заполняем 10 байт
 37+  C793 2A FA 8F                 ld    hl, (bios_vars.inverse)
 38+  C796 E5                       push  hl
 39+  C797 E5                       push  hl
 40+  C798 E5                       push  hl
 41+  C799 E5                       push  hl
 42+  C79A E5                       push  hl
 43+  C79B
 44+  C79B                          ; Следующий столбец (sp += 20)
 45+  C79B 21 14 00                 ld    hl, 14h
 46+  C79E 39                       add   hl,sp
 47+  C79F F9                       ld    sp, hl
 48+  C7A0
 49+  C7A0                          ; Восстанавливаем h
 50+  C7A0 67                       ld    h, a
 51+  C7A1
 52+  C7A1                          ; Следующий столбец
 53+  C7A1 24                       inc   h
 54+  C7A2
 55+  C7A2                          ; Цикл
 56+  C7A2 05                       dec   b
 57+  C7A3 C2 7B C7                 jp nz,  scrollUp2
 58+  C7A6
 59+  C7A6                          ; Восстановление регистров и выход
 60+  C7A6 2A F6 8F                 ld    hl, (bios_vars.oldSP)
 61+  C7A9 F9                       ld    sp, hl
 62+  C7AA F1                       pop   af
 63+  C7AB C1                       pop   bc
 64+  C7AC C9                       ret
 65+  C7AD
116   C7AD              	INCLUDE "checkRAMD.inc"
  1+  C7AD              ;+---------------------------------------------------------------------------
  2+  C7AD              ; MXOS
  3+  C7AD              ; Исправленная функция определения размера ДОЗУ
  4+  C7AD              ; Заимствовано из RAMFOS
  5+  C7AD              ;
  6+  C7AD              ; На входе
  7+  C7AD              ;  а  = максимальный номер страницы, константа MAX_ARAM_PAGE
  8+  C7AD              ;  hl = адрес в странице ДОЗУ для записи тестового байта
  9+  C7AD              ;
 10+  C7AD              ; На выходе
 11+  C7AD              ;  bios_vars.ramPageCount = максимальный номер страницы
 12+  C7AD              ;  NZ - ДОЗУ найдено (наоборот относительно стандратной функции Ramfos)
 13+  C7AD              ;   Z - ДОЗУ не найдено
 14+  C7AD              ;
 15+  C7AD              ; 2013-11-01 Разработано vinxru
 16+  C7AD              ; 2022-02-02 Доработано SpaceEnigneer
 17+  C7AD              ;----------------------------------------------------------------------------
 18+  C7AD
 19+  C7AD              checkRAMD:  ; Устанавливаем побайтовый драйвер.
 20+  C7AD                          ; Восстанавливать блочный драйвер не надо,
 21+  C7AD                          ; т.к. он будет установлен в reboot3
 22+  C7AD 06 01                    ld      b, 1
 23+  C7AF CD 90 CA                 call    setRAMDDriver
 24+  C7B2
 25+  C7B2                          ; Записываем во все страницы порядковые номера от большей к меньшей
 26+  C7B2              checkRAMD_0:
 27+  C7B2 4F                       ld      c, a
 28+  C7B3 0C                       inc     c
 29+  C7B4 CD D0 FF                 call    bios_RAMDWrite
 30+  C7B7 3D                       dec     a
 31+  C7B8 F2 B2 C7                 jp p,   checkRAMD_0
 32+  C7BB
 33+  C7BB                          ; Читаем номера. Если номер прочитан корректно, значит есть такая страница
 34+  C7BB                          ; a = -1
 35+  C7BB
 36+  C7BB              checkRAMD_1:
 37+  C7BB                          ; Читаем следующую страницу
 38+  C7BB 3C                       inc     a
 39+  C7BC CD C0 FF                 call    bios_RAMDRead
 40+  C7BF
 41+  C7BF                           ; Должен быть записан номер страницы + 1, если нет, то выходим
 42+  C7BF 0D                       dec     c
 43+  C7C0 B9                       cp      c
 44+  C7C1 C2 CE C7                 jp nz,  checkRAMD_2
 45+  C7C4
 46+  C7C4                          ; Сохраняем номер последней страницы + 1
 47+  C7C4 3C                       inc     a
 48+  C7C5 32 F8 8F                 ld      (bios_vars.ramPageCount), a
 49+  C7C8 3D                       dec     a
 50+  C7C9
 51+  C7C9                          ; Это максимум, выходим
 52+  C7C9 FE 10                    cp      RAMD_MAX_PAGE          ; RAMD_MAX_PAGE не может быть нулем!
 53+  C7CB C2 BB C7                 jp nz,  checkRAMD_1
 54+  C7CE
 55+  C7CE              checkRAMD_2:
 56+  C7CE                          ; Если ДОЗУ найдено, выходим c флагом NZ
 57+  C7CE B7                       or      a
 58+  C7CF C0                       ret nz
 59+  C7D0
 60+  C7D0                          ; В случае ошибки заносим в ramPageCount ноль и выходим с флагом Z
 61+  C7D0 32 F8 8F                 ld      (bios_vars.ramPageCount), a
 62+  C7D3 C9                       ret
 63+  C7D4
117   C7D4                  ; Здесь есть свободное место (29 байт)
118   C7D4
119   C7D4              ;---------------------------------------------------------------------------
120   C7D4              ; Точки входа 0C800h
121   C7D4              ;---------------------------------------------------------------------------
122   C7D4
123   C7D4              	ORG_PAD 0C800h
123   C7D4             >         IF $ > 0C800h
123   C7D4 ~           >           ; вывод сообщения об ошибке
123   C7D4 ~           >           ASSERT 0
123   C7D4 ~           >           DISPLAY /l, "Error! ORG_PAD failed! ", $, " is more than ", adr
123   C7D4             >         ELSE
123   C7D4             >           ; заполнение памяти
123   C7D4 FF FF FF... >           BLOCK 0C800h-$, 0FFh
123   C7D8             >         ENDIF
123   C800             >         ORG 0C800h
124   C800              	INCLUDE "jmps_c800.inc"
  1+  C800              ;+---------------------------------------------------------------------------
  2+  C800              ; MXOS
  3+  C800              ; Стандартные точки входа C800
  4+  C800              ;
  5+  C800              ; 2013-12-12 Дизассемблировано vinxru
  6+  C800              ;---------------------------------------------------------------------------
  7+  C800
  8+  C800 C3 66 C9     j_reboot3:      jp  reboot3         ; C800: Запустить NC.COM
  9+  C803 C3 37 C3     j_getch:        jp  getch           ; C803: Ожидание ввода с клавиатуры
 10+  C806 C3 77 C3     j_tapeRead:     jp  t_tapeRead      ; C806: Чтение байта с магнитофона
 11+  C809 C3 37 C0     j_printChar:    jp  printChar       ; C809: Вывод символа на экран
 12+  C80C C3 7A C3     j_tapeWrite:    jp  t_tapeWrite      ; C80C: Запись байта на магнитофон
 13+  C80F C3 B4 C8                     jp  input           ; C80F: Ввод строки с клавиатуры
 14+  C812 C3 03 C0                     jp  j_keyScan       ; C812: Получить код нажатой клавиши
 15+  C815 C3 94 C8                     jp  printHexByte    ; C815: Вывести 16-ричное число (байт)
 16+  C818 C3 38 C4     j_printString:  jp  printString1    ; C818: Вывести строку на экран
 17+  C81B C3 03 C0                     jp  j_keyScan       ; C81B: Получить код нажатой клавиши
 18+  C81E C3 75 C8                     jp  getCursorPos    ; C81E: Получить координаты курсора в hl (координаты в пикселях)
 19+  C821 C3 72 C8                     jp  setCursorPos    ; C821: Установить координаты курсора из hl (координаты в пикселях)
 20+  C824 C3 7D C3                     jp  t_tapeLoad      ; C824: Загрузить программу с магнитофона
 21+  C827 C3 80 C3                     jp  t_tapeSave      ; C827: Сохранить программу на магнитофон
 22+  C82A C3 4F C9                     jp  calcCS          ; C82A: Расчет контрольной суммы
 23+  C82D C3 89 C8                     jp  printHexWord    ; C82D: Вывести 16-ричное число (слово)
 24+  C830 C3 85 C8                     jp  getMemTop       ; C830: Получить объем доступной памяти
 25+  C833 C3 79 C8                     jp  setMemTop       ; C833: Установить объем доступной памяти
 26+  C836 C3 00 C5                     jp  printer         ; C836: Напечатать байт на принтере
 27+  C839                  IF RAMFOS_COMPATIBILITY
 28+  C839 C3 D3 C3                     jp  strToHex        ; C839: [NEW] Преобразвоние строки в HEX формате в число
 29+  C83C                  ELSE
 30+  C83C ~                            jp  j_reboot3       ; C839: Запустить NC.COM
 31+  C83C                  ENDIF
 32+  C83C C3 66 C9                     jp  reboot3         ; C83C: Запустить NC.COM
 33+  C83F C3 17 CE                     jp  fileList        ; C83F: Получить список файлов
 34+  C842 C3 8F CB                     jp  fileGetSetDrive ; C842: Получить/установить активное устройство
 35+  C845 C3 2C CC                     jp  fileCreate      ; C845: Создать файл
 36+  C848 C3 2D CD                     jp  fileLoad        ; C848: Загрузить файл по адресу из заголовка этого файла
 37+  C84B C3 84 CD                     jp  fileDelete      ; C84B: Удалить файл
 38+  C84E C3 B1 CD                     jp  fileRename      ; C84E: Переименовать файл
 39+  C851 C3 66 CD                     jp  fileLoadInfo    ; C851: Загрузить информацию о файле
 40+  C854 C3 F5 CD                     jp  fileGetSetAddr  ; C854: Получить/установить адрес загрузки файла
 41+  C857 C3 D3 CD                     jp  fileGetSetAttr  ; C857: Получить/установить атрибуты файла
 42+  C85A C3 49 CE                     jp  fileNamePrepare ; C85A: Преобразовать имя файла во внутренний формат
 43+  C85D C3 0B CA                     jp  fileExec        ; C85D: Запустить файл
 44+  C860 C3 7B CB                     jp  installDriver   ; C860: Установить драйвер накопителя
 45+  C863 C3 F2 CA     j_diskDriver:   jp  diskDriver      ; C863: Драйвер выбранного диска
 46+  C866 C3 23 CD                     jp  fileLoad2       ; C866: Загрузить файл по адресу de
 47+  C869 C3 E5 C5                     jp  printChar_real  ; C869: [NEW] Вывод символа на экран (только реальные символы)
 48+  C86C C3 AF CE                     jp  printDecWord    ; C86C: [NEW] Вывод числа экран в десятичной форме
 49+  C86F C3 90 CA                     jp  setRAMDDriver   ; C86F: [NEW] Установить драйвер доступа к ДОЗУ
 50+  C872
125   C872              	INCLUDE "setGetCursorPos.inc"
  1+  C872              ;+---------------------------------------------------------------------------
  2+  C872              ; MXOS
  3+  C872              ; Установить положение курсора
  4+  C872              ;
  5+  C872              ; На входе
  6+  C872              ;  h - координата X в пикселях / 2
  7+  C872              ;  l - координата Y в пикселях
  8+  C872              ;
  9+  C872              ; На выходе
 10+  C872              ;  af, bc, de, hl - Сохраняются
 11+  C872              ;
 12+  C872              ; 2013-12-12 Дизассемблировано vinxru
 13+  C872              ;----------------------------------------------------------------------------
 14+  C872
 15+  C872 22 FC 8F     setCursorPos:     ld    (bios_vars.cursorY), hl
 16+  C875
 17+  C875              ;----------------------------------------------------------------------------
 18+  C875              ; Получить положение курсора
 19+  C875              ;
 20+  C875              ; На выходе
 21+  C875              ;  af, bc, de - Сохраняются
 22+  C875              ;  h - координата X в пикселях / 2
 23+  C875              ;  l - координата Y в пикселях
 24+  C875              ;----------------------------------------------------------------------------
 25+  C875
 26+  C875 2A FC 8F     getCursorPos:     ld    hl, (bios_vars.cursorY)
 27+  C878 C9                       ret
 28+  C879
126   C879              	INCLUDE "setGetMemTop.inc"
  1+  C879              ;+---------------------------------------------------------------------------
  2+  C879              ; MXOS
  3+  C879              ; Установить объем доступной памяти
  4+  C879              ;
  5+  C879              ; На входе
  6+  C879              ;  hl - доступная память. Если меньше 0D000h, то значение не изменяется.
  7+  C879              ;
  8+  C879              ; На выходе
  9+  C879              ;  все регистры сохраняются
 10+  C879              ;
 11+  C879              ; 2013-12-12 Дизассемблировано vinxru
 12+  C879              ;----------------------------------------------------------------------------
 13+  C879
 14+  C879 F5           setMemTop:  push  af
 15+  C87A 7C                       ld    a, h
 16+  C87B FE D0                    cp    0D0h
 17+  C87D DA 83 C8                 jp c, setMemTop_0
 18+  C880 22 49 CF                   ld  (v_memTop), hl
 19+  C883 F1           setMemTop_0:      pop   af
 20+  C884 C9                       ret
 21+  C885
 22+  C885              ;----------------------------------------------------------------------------
 23+  C885              ; Получить объем доступной памяти
 24+  C885              ;
 25+  C885              ; На выходе
 26+  C885              ;  hl - доступная память
 27+  C885              ;
 28+  C885              ; На выходе
 29+  C885              ;  все регистры сохраняются
 30+  C885              ;----------------------------------------------------------------------------
 31+  C885
 32+  C885 2A 49 CF     getMemTop:  ld    hl, (v_memTop)
 33+  C888 C9                       ret
 34+  C889
127   C889              	INCLUDE "printHex.inc"
  1+  C889              ;+---------------------------------------------------------------------------
  2+  C889              ; MXOS
  3+  C889              ; Вывод 16-ричного числа на экран (слово)
  4+  C889              ;
  5+  C889              ; На входе
  6+  C889              ;  hl - число
  7+  C889              ;
  8+  C889              ; На выходе
  9+  C889              ;  все регистры сохраняются
 10+  C889              ;
 11+  C889              ; 2013-12-12 Дизассемблировано vinxru
 12+  C889              ;----------------------------------------------------------------------------
 13+  C889
 14+  C889              printHexWord:     ; Сохраняем регистры
 15+  C889 F5                       push  af
 16+  C88A
 17+  C88A                          ; Старший байт
 18+  C88A 7C                       ld    a, h
 19+  C88B CD 94 C8                 call  printHexByte
 20+  C88E
 21+  C88E                          ; Младшйи байт
 22+  C88E 7D                       ld    a, l
 23+  C88F CD 94 C8                 call  printHexByte
 24+  C892
 25+  C892                          ; Восстаналиваем регистры
 26+  C892 F1                       pop   af
 27+  C893 C9                       ret
 28+  C894
 29+  C894              ;----------------------------------------------------------------------------
 30+  C894              ; Вывод 16-ричного числа на экран (байт)
 31+  C894              ;
 32+  C894              ; На входе
 33+  C894              ;  a - число
 34+  C894              ;
 35+  C894              ; На выходе
 36+  C894              ;  все регистры сохраняются
 37+  C894              ;----------------------------------------------------------------------------
 38+  C894
 39+  C894              printHexByte:     ; Сохраняем регистры
 40+  C894 C5                       push  bc
 41+  C895 F5                       push  af
 42+  C896
 43+  C896                          ; Сохраняем a для вывода второй цифры
 44+  C896 47                       ld    b, a
 45+  C897
 46+  C897                          ; Первая цифра - старшие 4 бита
 47+  C897 07                       rlca
 48+  C898 07                       rlca
 49+  C899 07                       rlca
 50+  C89A 07                       rlca
 51+  C89B CD A5 C8                 call  printHexNibble
 52+  C89E
 53+  C89E                          ; Вторая цифра - младщие 4 бита
 54+  C89E 78                       ld    a, b
 55+  C89F CD A5 C8                 call  printHexNibble
 56+  C8A2
 57+  C8A2                          ; Восстаналиваем регистры
 58+  C8A2 F1                       pop   af
 59+  C8A3 C1                       pop   bc
 60+  C8A4 C9                       ret
 61+  C8A5
 62+  C8A5              ;----------------------------------------------------------------------------
 63+  C8A5              ; Вывод 16-ричного числа на экран (цифра)
 64+  C8A5              ;
 65+  C8A5              ; На входе
 66+  C8A5              ;  a - число, используются младшие 4 бита
 67+  C8A5              ;
 68+  C8A5              ; На выходе
 69+  C8A5              ;  c, a - изменяются, остальные регистры сохраняются
 70+  C8A5              ;----------------------------------------------------------------------------
 71+  C8A5
 72+  C8A5 E6 0F        printHexNibble:   and   0Fh
 73+  C8A7 C6 30                    add   a, '0'
 74+  C8A9 FE 3A                    cp    '9'+1
 75+  C8AB DA B0 C8                 jp c, printHexNib_0
 76+  C8AE C6 07                      add a, 'A'-'0'-10
 77+  C8B0 4F           printHexNib_0:    ld    c, a
 78+  C8B1 C3 09 C8                 jp    j_printChar
 79+  C8B4
128   C8B4              	INCLUDE "input.inc"
  1+  C8B4              ;+---------------------------------------------------------------------------
  2+  C8B4              ; MXOS
  3+  C8B4              ; Ввод строки
  4+  C8B4              ;
  5+  C8B4              ; На входе
  6+  C8B4              ;  hl - начало буфера
  7+  C8B4              ;  de - конец буфера
  8+  C8B4              ;
  9+  C8B4              ; На выходе
 10+  C8B4              ;  bc, de, hl - сохраняются
 11+  C8B4              ;
 12+  C8B4              ; 2013-12-12 Дизассемблировано vinxru
 13+  C8B4              ;----------------------------------------------------------------------------
 14+  C8B4
 15+  C8B4              input:            ; Сохраняем регистры
 16+  C8B4 E5                       push  hl
 17+  C8B5 C5                       push  bc
 18+  C8B6 F5                       push  af
 19+  C8B7
 20+  C8B7                          ; Сохраняем значения
 21+  C8B7 22 3F CF                 ld    (v_input_start), hl
 22+  C8BA EB                       ex    de, hl
 23+  C8BB 22 45 CF                 ld    (v_input_end), hl
 24+  C8BE
 25+  C8BE                          ; Помещаем в конец буфера 0
 26+  C8BE 62                       ld    h, d
 27+  C8BF 6B                       ld    l, e
 28+  C8C0 36 00                    ld  (hl), 0
 29+  C8C2
 30+  C8C2              input_loop: ; Ждем клавиашу
 31+  C8C2 CD 03 C8                 call  j_getch
 32+  C8C5 4F                       ld    c, a
 33+  C8C6
 34+  C8C6                          ; Нажата служебная клавиша
 35+  C8C6 FE 20                    cp    20h
 36+  C8C8 DA 1D C9                 jp c, input_spec
 37+  C8CB
 38+  C8CB                          ; Нажата клавиша Back space
 39+  C8CB FE 7F                    cp    7Fh
 40+  C8CD CA 0C C9                 jp z, input_bkspc
 41+  C8D0
 42+  C8D0                          ; ...
 43+  C8D0 00                       nop
 44+  C8D1 00                       nop
 45+  C8D2 00                       nop
 46+  C8D3
 47+  C8D3                          ; Это конец буфера
 48+  C8D3 E5                       push  hl
 49+  C8D4 2A 45 CF                 ld    hl, (v_input_end)
 50+  C8D7 CD 89 C3                 call  cmp_hl_de_2
 51+  C8DA E1                       pop   hl
 52+  C8DB C2 E7 C8                 jp nz,  loc_C8DE
 53+  C8DE CD 89 C3                 call  cmp_hl_de_2
 54+  C8E1 CA C2 C8                 jp z, input_loop
 55+  C8E4 1A                       ld    a, (de)
 56+  C8E5 1B                       dec   de
 57+  C8E6 12                       ld    (de),a
 58+  C8E7 C5           loc_C8DE:   push  bc
 59+  C8E8 44                       ld    b, h
 60+  C8E9 4D                       ld    c, l
 61+  C8EA 03                       inc   bc
 62+  C8EB CD 97 C3                 call  memmove_bc_hl
 63+  C8EE C1                       pop   bc
 64+  C8EF 71                       ld  (hl), c       ; *hl++     = c;
 65+  C8F0 CD 09 C8                 call  j_printChar ; Вывод     символа     на экран
 66+  C8F3 23                       inc   hl
 67+  C8F4 13                       inc   de
 68+  C8F5 E5           loc_C8EC:   push  hl
 69+  C8F6 2A FC 8F                 ld    hl, (bios_vars.cursorY)
 70+  C8F9 E3                       ex    (sp), hl
 71+  C8FA E5                       push  hl
 72+  C8FB CD 18 C8                 call  j_printString
 73+  C8FE 0E 20                    ld    c, ' '
 74+  C900 CD 09 C8                 call  j_printChar
 75+  C903 E1                       pop   hl
 76+  C904 E3                       ex    (sp), hl
 77+  C905 22 FC 8F                 ld    (bios_vars.cursorY), hl
 78+  C908 E1                       pop   hl
 79+  C909
 80+  C909                          ; Продолжение
 81+  C909 C3 C2 C8                 jp    input_loop
 82+  C90C
 83+  C90C              ; ---------------------------------------------------------------------------
 84+  C90C
 85+  C90C              input_bkspc:      ; Если курсор в начале строки ничего не удаляем
 86+  C90C CD 89 C3                 call  cmp_hl_de_2
 87+  C90F CA C2 C8                 jp z, input_loop
 88+  C912
 89+  C912                          ; Сдвигаем строку
 90+  C912 44                       ld    b, h
 91+  C913 4D                       ld    c, l
 92+  C914 23                       inc   hl
 93+  C915 CD 97 C3                 call  memmove_bc_hl
 94+  C918
 95+  C918                          ; Уменьшаем положение курсора
 96+  C918 2B                       dec   hl
 97+  C919
 98+  C919 1B                       dec   de
 99+  C91A C3 F5 C8                 jp    loc_C8EC
100+  C91D
101+  C91D              ; ---------------------------------------------------------------------------
102+  C91D
103+  C91D              input_spec: ; Нажато влево
104+  C91D FE 08                    cp    8
105+  C91F CA 31 C9                 jp z, input_left
106+  C922
107+  C922                          ; Нажато вправо
108+  C922 FE 18                    cp    18h
109+  C924 CA 45 C9                 jp z, input_right
110+  C927
111+  C927                          ; Нажат не ввод
112+  C927 FE 0D                    cp    0Dh
113+  C929 C2 C2 C8                 jp nz,  input_loop
114+  C92C
115+  C92C                          ; Нажат ввод
116+  C92C
117+  C92C                          ; Сохраняем в конец стрки 0D
118+  C92C 12                       ld    (de),a
119+  C92D
120+  C92D                          ; Восстанавливаем регистры и выходим
121+  C92D F1                       pop   af
122+  C92E C1                       pop   bc
123+  C92F E1                       pop   hl
124+  C930 C9                       ret
125+  C931
126+  C931              ; ---------------------------------------------------------------------------
127+  C931
128+  C931              input_left: ; Если курсор в начале строки (hl==v_input_start) не перемещаем курсор
129+  C931 EB                       ex    de, hl
130+  C932 E5                       push  hl
131+  C933 2A 3F CF                 ld    hl, (v_input_start)
132+  C936 CD 89 C3                 call  cmp_hl_de_2
133+  C939 E1                       pop   hl
134+  C93A EB                       ex    de, hl
135+  C93B CA C2 C8                 jp z, input_loop
136+  C93E
137+  C93E                          ; Уменьшаем положение курсора
138+  C93E 2B                       dec   hl
139+  C93F
140+  C93F              input_lr:   ; Перемещаем курсор вправо/влево
141+  C93F CD 09 C8                 call  j_printChar
142+  C942
143+  C942                          ; Продолжаем ввод
144+  C942 C3 C2 C8                 jp    input_loop
145+  C945
146+  C945              ; ---------------------------------------------------------------------------
147+  C945
148+  C945              input_right:      ; Если курсор в конце строк (hl==de) не перемещаем курсор
149+  C945 CD 89 C3                 call  cmp_hl_de_2
150+  C948 CA C2 C8                 jp z, input_loop
151+  C94B
152+  C94B                          ; Увеличиваем положение курсора
153+  C94B 23                       inc   hl
154+  C94C
155+  C94C                          ; Общее продолжение
156+  C94C C3 3F C9                 jp    input_lr
157+  C94F
129   C94F              	INCLUDE "calcCS.inc"
  1+  C94F              ;+---------------------------------------------------------------------------
  2+  C94F              ; MXOS
  3+  C94F              ; Расчет контрольной суммы
  4+  C94F              ;
  5+  C94F              ; На входе
  6+  C94F              ;  hl - начальный адрес
  7+  C94F              ;  de - конечный адрес
  8+  C94F              ;
  9+  C94F              ; На выходе
 10+  C94F              ;  bc - контрольная сумма
 11+  C94F              ;
 12+  C94F              ; 2013-12-12 Дизассемблировано vinxru
 13+  C94F              ;----------------------------------------------------------------------------
 14+  C94F
 15+  C94F 01 00 00     calcCS:     ld      bc, 0
 16+  C952 7E           calcCS_1:   ld      a, (hl)
 17+  C953 81                       add     a, c
 18+  C954 4F                       ld      c, a
 19+  C955 F5                       push    af
 20+  C956 CD 89 C3                 call    cmp_hl_de_2
 21+  C959 CA 64 C9                 jp z,   calcCS_2
 22+  C95C F1                       pop     af
 23+  C95D 78                       ld      a, b
 24+  C95E 8E                       ADC     a, (hl)
 25+  C95F 47                       ld      b, a
 26+  C960 23                       inc     hl
 27+  C961 C3 52 C9                 jp      calcCS_1
 28+  C964 F1           calcCS_2:   pop     af
 29+  C965 C9                       ret
 30+  C966
130   C966              	INCLUDE "reboot3.inc"
  1+  C966              ;+---------------------------------------------------------------------------
  2+  C966              ; MXOS
  3+  C966              ; Обновление драйвера по адресу 0FFC0h и запуск NC.COM
  4+  C966              ;
  5+  C966              ; А так же однократный запуск AUTOEX.BAT, если не нажата клавиша.
  6+  C966              ;
  7+  C966              ; 2013-12-12 Дизассемблировано vinxru
  8+  C966              ;----------------------------------------------------------------------------
  9+  C966
 10+  C966              reboot3:    ; Инициализация стека
 11+  C966 31 C0 FF                 ld      sp, STACK_ADDR
 12+  C969
 13+  C969                          ; Устанавливаем блочный драйвер
 14+  C969 06 00                    ld      b, 0
 15+  C96B CD 90 CA                 call    setRAMDDriver
 16+  C96E
 17+  C96E                          ; Обновляем переменные
 18+  C96E 21 00 C8                 ld      hl, j_reboot3
 19+  C971 22 E1 8F                 ld      (bios_vars.tapeError), hl
 20+  C974
 21+  C974              reboot3_0:
 22+  C974 C3 77 C9                 jp      reboot3_1
 23+  C977
 24+  C977              ; -------------------------------------
 25+  C977              ; Код ниже будет выполнен лишь один раз после холодной перезагрузки.
 26+  C977              ; То есть при теплой перезагрузке он не вызывается.
 27+  C977
 28+  C977              reboot3_1:
 29+  C977                          ; Патчим предыдущую инструкцию - теперь она стала jp reboot3_2
 30+  C977 21 AE C9                 ld      hl, reboot3_2
 31+  C97A 22 75 C9                 ld      (reboot3_0+1), hl
 32+  C97D
 33+  C97D                          ; Устанавливаем побайтовый драйвер
 34+  C97D 06 01                    ld      b, 1
 35+  C97F CD 90 CA                 call    setRAMDDriver
 36+  C982
 37+  C982                          ; Если в рам-диске по адресу 0FF00h (последний неполный сектор)
 38+  C982                          ; нет специальной метки, значит, не запускали форматирование
 39+  C982 21 BF FF                 ld      hl, 0FFBFh      ; адрес в странице
 40+  C985 AF                       xor     a               ; 0 страница
 41+  C986 CD C0 FF                 call    bios_RAMDRead
 42+  C989 79                       ld      a, c            ; считанный байт в c
 43+  C98A FE 5A                    cp      5Ah
 44+  C98C CA A0 C9                 jp z,   skipFormat      ; метка есть - пропускаем форматирование
 45+  C98F
 46+  C98F                          ; Записываем метку
 47+  C98F AF                       xor     a               ; 0 страница
 48+  C990 0E 5A                    ld      c, 5Ah          ; записываемый байт
 49+  C992 CD D0 FF                 call    bios_RAMDWrite
 50+  C995
 51+  C995                          ; Устанавливаем блочный драйвер
 52+  C995 06 00                    ld      b, 0
 53+  C997 CD 90 CA                 call    setRAMDDriver
 54+  C99A
 55+  C99A                          ; Запуск файла "A:FORMAT.BAT"
 56+  C99A 21 6C CF                 ld      hl, pathFormatBat
 57+  C99D CD 0B CA                 call    fileExec
 58+  C9A0
 59+  C9A0              skipFormat:
 60+  C9A0                          ; Если нажата клавиша, пропустить запуск A:AUTOEX.BAT
 61+  C9A0 3A E1 FF                 ld      a, (IO_KEYB_B)
 62+  C9A3 E6 02                    and     2
 63+  C9A5 CA AE C9                 jp z,   reboot3_2
 64+  C9A8
 65+  C9A8                          ; Запуск файла A:AUTOEX.BAT
 66+  C9A8 21 5F CF                 ld      hl, pathAutoexecBat
 67+  C9AB CD 0B CA                 call    fileExec
 68+  C9AE
 69+  C9AE              ; -------------------------------------
 70+  C9AE
 71+  C9AE              reboot3_2:
 72+  C9AE                          ; Запуск файла A:NC.COM
 73+  C9AE 21 56 CF                 ld      hl, pathNcCom
 74+  C9B1 CD 0B CA                 call    fileExec
 75+  C9B4
 76+  C9B4                          ; Теплая перезагрузка
 77+  C9B4 C3 00 C8                 jp      j_reboot3
 78+  C9B7
131   C9B7              	INCLUDE "fileExecBat.inc"
  1+  C9B7              ;+---------------------------------------------------------------------------
  2+  C9B7              ; MXOS
  3+  C9B7              ; Запустить BAT файл. Вызывается функцией fileExec
  4+  C9B7              ;
  5+  C9B7              ; 2013-12-12 Дизассемблировано vinxru
  6+  C9B7              ;----------------------------------------------------------------------------
  7+  C9B7
  8+  C9B7              execBat:
  9+  C9B7 D1                       pop   de
 10+  C9B8
 11+  C9B8                          ; Устанавливаем адрес загрузки BAT-файла на BAT_BUFFER (= FC00h)
 12+  C9B8 21 00 FC                 ld      hl, BAT_BUFFER
 13+  C9BB 22 47 CF                 ld      (v_batPtr), hl
 14+  C9BE EB                       ex      de, hl
 15+  C9BF
 16+  C9BF                          ; Изменяем адрес загрузки BAT-файла
 17+  C9BF                          ; TODO: это не работает с ром-диском (A: без поддержки записи). Поэтому
 18+  C9BF                          ; нельзя запустить BAT-файл с диска A:, если его адрес загрузки в каталоге
 19+  C9BF                          ; уже не прошит как FC00h (= BAT_BUFFER)
 20+  C9BF 21 82 CF                 ld      hl, v_curFileDescr
 21+  C9C2 0E 01                    ld      c, 1
 22+  C9C4 CD F5 CD                 call    fileGetSetAddr
 23+  C9C7 DA 6C CA                 jp c,   badCommand
 24+  C9CA
 25+  C9CA                          ; Сохраняем имя BAT-файла
 26+  C9CA 21 82 CF                 ld      hl, v_curFileDescr
 27+  C9CD 11 8D CF                 ld      de, v_curFileDescr + DIR_NAME_LENGTH + 3
 28+  C9D0 01 A2 CF                 ld      bc, v_batFileDescr
 29+  C9D3 CD 97 C3                 call    memmove_bc_hl
 30+  C9D6
 31+  C9D6                          ; Сохраняем диск содержащий BAT-файл
 32+  C9D6 3A 3E CF                 ld      a, (v_drive)
 33+  C9D9 32 E1 C9                 ld      (v_batDrive+1), a   ; самомодификация кода
 34+  C9DC
 35+  C9DC                          ; Этот цикл выполняется для каждой строки BAT-файла
 36+  C9DC              execBat_loop:
 37+  C9DC
 38+  C9DC                          ; Сохраняем текущий диск в регистре b
 39+  C9DC 3A 3E CF                 ld  a, (v_drive)
 40+  C9DF 47                       ld   b, a
 41+  C9E0
 42+  C9E0              v_batDrive:
 43+  C9E0                          ; Выбрать диск содержащий BAT файл
 44+  C9E0 3E 01                    ld   a, 1 ; << сюда вместо 1 пишется диск, содержащий BAT файл
 45+  C9E2 CD 97 CB                 call fileSelectDrive
 46+  C9E5
 47+  C9E5                          ; Загрузить BAT-файл в память
 48+  C9E5 21 A2 CF                 ld  hl, v_batFileDescr
 49+  C9E8 CD 2D CD                 call fileLoad
 50+  C9EB 2A 47 CF                 ld hl, (v_batPtr)
 51+  C9EE
 52+  C9EE                          ; Сохраняем начало строки
 53+  C9EE 54                       ld    d, h
 54+  C9EF 5D                       ld    e, l
 55+  C9F0
 56+  C9F0                          ; Ищем конец строки
 57+  C9F0              execBat_0:
 58+  C9F0 7E                       ld  a, (hl)
 59+  C9F1 23                       inc   hl
 60+  C9F2
 61+  C9F2                          ; Найден конец строки, запускаем файл
 62+  C9F2 FE 0D                    cp    0Dh
 63+  C9F4 CA FD C9                 jp z, execBat_1
 64+  C9F7
 65+  C9F7                          ; Конец     файла
 66+  C9F7 FE FF                    cp    0FFh
 67+  C9F9 C2 F0 C9                 jp nz,  execBat_0
 68+  C9FC C9                       ret
 69+  C9FD
 70+  C9FD              ; ---------------------------------------------------------------------------
 71+  C9FD
 72+  C9FD              execBat_1:
 73+  C9FD                          ; Сохраняем указатель
 74+  C9FD 22 47 CF                 ld (v_batPtr), hl
 75+  CA00
 76+  CA00                          ; Восстановление активного диска
 77+  CA00 78                       ld   a, b
 78+  CA01 CD 97 CB                 call fileSelectDrive
 79+  CA04
 80+  CA04                          ; Запустить файл
 81+  CA04 EB                       ex    de, hl
 82+  CA05 CD 0B CA                 call fileExec
 83+  CA08
 84+  CA08 C3 DC C9                 jp execBat_loop
 85+  CA0B
132   CA0B              	INCLUDE "fileExec.inc"
  1+  CA0B              ;+---------------------------------------------------------------------------
  2+  CA0B              ; MXOS
  3+  CA0B              ; Запустить файл
  4+  CA0B              ;
  5+  CA0B              ; На входе
  6+  CA0B              ;  hl - ком строка в формате [Диск:]файл[ аргументы]
  7+  CA0B              ;
  8+  CA0B              ; На выходе
  9+  CA0B              ;  сf - ошибка
 10+  CA0B              ;
 11+  CA0B              ; 2013-12-12 Дизассемблировано vinxru
 12+  CA0B              ;----------------------------------------------------------------------------
 13+  CA0B
 14+  CA0B              fileExec:   ; Сюда будем записывать результат
 15+  CA0B 11 00 FF                 ld      de, CMD_LINE
 16+  CA0E
 17+  CA0E                          ; Если первый символ меньше пробела, выходим c CF
 18+  CA0E 7E                       ld      a, (hl)
 19+  CA0F FE 20                    cp      ' '
 20+  CA11 DA 72 CA                 jp      c, stc_ret
 21+  CA14
 22+  CA14                          ; Максимальный размер ком строки (+2 терминатора, итого 82h)
 23+  CA14 0E 80                    ld      c, 80h
 24+  CA16
 25+  CA16              fileExec_0: ; Если символ меньше пробела, выходим
 26+  CA16 7E                       ld      a, (hl)
 27+  CA17 FE 20                    cp      20h
 28+  CA19 DA 23 CA                 jp c,   fileExec_1
 29+  CA1C
 30+  CA1C                          ; Копируем симовол из hl в de
 31+  CA1C 12                       ld      (de),a
 32+  CA1D 23                       inc     hl
 33+  CA1E 13                       inc     de
 34+  CA1F
 35+  CA1F                          ; Повторяем 80h раз
 36+  CA1F 0D                       dec     c
 37+  CA20 C2 16 CA                 jp nz,  fileExec_0
 38+  CA23
 39+  CA23              fileExec_1: ; В конец имени помещаем 13, 0
 40+  CA23 3E 0D                    ld      a, 0Dh
 41+  CA25 12                       ld      (de), a
 42+  CA26 13                       inc     de
 43+  CA27 AF                       xor     a
 44+  CA28 12                       ld      (de), a
 45+  CA29
 46+  CA29                          ; Выводим на экран 0Ah
 47+  CA29 CD 74 CA                 call    printCharA
 48+  CA2C
 49+  CA2C                          ; Выводим на экран имя файла
 50+  CA2C 21 00 FF                 ld      hl, CMD_LINE
 51+  CA2F CD 18 C8                 call    j_printString
 52+  CA32
 53+  CA32                          ; Подготовка имени файла
 54+  CA32 21 00 FF                 ld      hl, CMD_LINE
 55+  CA35 11 82 CF                 ld      de, v_curFileDescr
 56+  CA38 CD 49 CE                 call    fileNamePrepare
 57+  CA3B
 58+  CA3B                          ; Запоминаем в стеке текущий адрес командной строки (начало списка аргументов)
 59+  CA3B E5                       push    hl
 60+  CA3C
 61+  CA3C                          ; Если это BAT файл
 62+  CA3C 11 79 CF                 ld      de, aBat ; "BAT"
 63+  CA3F CD 79 CA                 call    cmpFileExt
 64+  CA42 CA B7 C9                 jp z,   execBat
 65+  CA45
 66+  CA45                          ; Если это COM или EXE файл
 67+  CA45 CD 79 CA                 call    cmpFileExt
 68+  CA48 CA 51 CA                 jp z,   execExeCom
 69+  CA4B CD 79 CA                 call    cmpFileExt
 70+  CA4E C2 6B CA                 jp nz,  execError
 71+  CA51
 72+  CA51              execExeCom:
 73+  CA51                          ; Вытаскиваем из стека текущий адрес командной строки (начало списка аргументов)
 74+  CA51 D1                       pop     de
 75+  CA52
 76+  CA52                          ; Загрузить файл
 77+  CA52 21 82 CF                 ld      hl, v_curFileDescr
 78+  CA55 CD 2D CD                 call    fileLoad
 79+  CA58 DA 6C CA                 jp c,   badCommand
 80+  CA5B
 81+  CA5B                          ; Адрес командной строки
 82+  CA5B D5                       push    de
 83+  CA5C
 84+  CA5C                          ; Выводим на экран 0Ah
 85+  CA5C                          ;call printCharA
 86+  CA5C
 87+  CA5C                          ; hl = указатель на адрес загрузки (= адрес запуска) файла
 88+  CA5C 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress   ; смещение поля с адресом загрузки
 89+  CA5F 19                       add     hl, de
 90+  CA60
 91+  CA60                          ; de = адрес загрузки (= адрес запуска) файла
 92+  CA60 5E                       ld      e, (hl)
 93+  CA61 23                       inc     hl
 94+  CA62 56                       ld      d, (hl)
 95+  CA63
 96+  CA63                          ; Адрес возврата
 97+  CA63 21 69 CA                 ld      hl, defAppReturn
 98+  CA66 E3                       ex      (sp), hl
 99+  CA67
100+  CA67                          ; Запуск программы (переход на de)
101+  CA67 EB                       ex      de, hl  ; hl <--> de
102+  CA68 E9                       jp      (hl)    ; pc <-- hl
103+  CA69
104+  CA69              ; ---------------------------------------------------------------------------
105+  CA69
106+  CA69              defAppReturn:
107+  CA69 B7                       or  a
108+  CA6A C9                       ret
109+  CA6B
110+  CA6B              ; ---------------------------------------------------------------------------
111+  CA6B
112+  CA6B              execError:
113+  CA6B D1                       pop     de
114+  CA6C              badCommand:
115+  CA6C 21 F3 CE                 ld      hl, txtBadCommand; "\nBAD COMMAND or FILE NAME"
116+  CA6F CD 18 C8                 call    j_printString
117+  CA72              stc_ret:
118+  CA72 37                       scf
119+  CA73 C9                       ret
120+  CA74
121+  CA74              ; ---------------------------------------------------------------------------
122+  CA74
123+  CA74              printCharA:
124+  CA74 0E 0A                    ld  c, 0Ah
125+  CA76 C3 09 C8                 jp  j_printChar
126+  CA79
133   CA79              	INCLUDE "fileCmpExt.inc"
  1+  CA79              ;+---------------------------------------------------------------------------
  2+  CA79              ; MXOS
  3+  CA79              ; Сранивать расширения файлов
  4+  CA79              ;
  5+  CA79              ; На входе
  6+  CA79              ;  de - адрес расширения 1
  7+  CA79              ;  v_curFileDescr - имя с расширением 2
  8+  CA79              ;
  9+  CA79              ; На выходе
 10+  CA79              ;  zf=0 - расширения равны
 11+  CA79              ;  de - de+3
 12+  CA79              ;
 13+  CA79              ; 2013-12-12 Дизассемблировано vinxru
 14+  CA79              ;----------------------------------------------------------------------------
 15+  CA79
 16+  CA79              cmpFileExt:
 17+  CA79                          ; Адрес расширения
 18+  CA79 21 8A CF                 ld      hl, v_curFileDescr + DIR_NAME_LENGTH
 19+  CA7C 01 03 00                 ld      bc, 3   ; Сравниваем 3 символа
 20+  CA7F              cmpFileExt_0:
 21+  CA7F 1A                       ld      a, (de)
 22+  CA80 BE                       cp      (hl)
 23+  CA81 C2 8A CA                 jp nz,  cmpFileExt_1
 24+  CA84 23                       inc     hl
 25+  CA85 13                       inc     de
 26+  CA86 0D                       dec     c
 27+  CA87 C2 7F CA                 jp nz,  cmpFileExt_0
 28+  CA8A
 29+  CA8A                          ; ZF=1 если равны
 30+  CA8A
 31+  CA8A              cmpFileExt_1:
 32+  CA8A                          ; Делаем так, чтобы de на выходе функции был на 3 больше,
 33+  CA8A                          ; чем на входе в функцию
 34+  CA8A F5                       push    af
 35+  CA8B EB                       ex      de, hl
 36+  CA8C 09                       add     hl, bc
 37+  CA8D EB                       ex      de, hl
 38+  CA8E F1                       pop     af
 39+  CA8F
 40+  CA8F                          ; Выход
 41+  CA8F C9                       ret
 42+  CA90
134   CA90              	INCLUDE "driverFFC0.inc"
  1+  CA90              ;+---------------------------------------------------------------------------
  2+  CA90              ; MXOS
  3+  CA90              ; Драйверы диска в ДОЗУ (часть, которая копируется на адрес 0FFC0h)
  4+  CA90              ;
  5+  CA90              ; 2013-12-12 Дизассемблировано и доработано vinxru
  6+  CA90              ; 2022-02-02 Доработано SpaceEngineer
  7+  CA90              ;----------------------------------------------------------------------------
  8+  CA90
  9+  CA90              ;----------------------------------------------------------------------------
 10+  CA90              ; Установить драйвер доступа к ДОЗУ в окно разделяемой памяти
 11+  CA90              ; Специалиста-MX (FFC0h-FFDEh)
 12+  CA90              ;
 13+  CA90              ; вход:
 14+  CA90              ;  b = 0 - установить блочный драйвер, b = 1 - установить побайтовый драйвер
 15+  CA90              ;
 16+  CA90              ; 2022-02-02 SpaceEngineer
 17+  CA90              ;----------------------------------------------------------------------------
 18+  CA90
 19+  CA90              setRAMDDriver:
 20+  CA90 E5                       push  hl
 21+  CA91 D5                       push  de
 22+  CA92 C5                       push  bc
 23+  CA93 F5                       push  af
 24+  CA94 05                       dec   b
 25+  CA95 CA A1 CA                 jp z, setRAMDDriver_1
 26+  CA98
 27+  CA98                          ; Адреса блочного драйвера
 28+  CA98 21 B2 CA                 ld    hl, driverBlockStart
 29+  CA9B 11 D2 CA                 ld    de, driverBlockEnd
 30+  CA9E C3 A7 CA                 jp    setRAMDDriver_2
 31+  CAA1
 32+  CAA1              setRAMDDriver_1:
 33+  CAA1                          ; Адреса побайтового драйвера
 34+  CAA1 21 D2 CA                 ld    hl, driverByteStart
 35+  CAA4 11 F2 CA                 ld    de, driverByteEnd
 36+  CAA7
 37+  CAA7                          ; Копируем драйвер на адрес bc = bios_RAMDRead = 0FFC0h
 38+  CAA7              setRAMDDriver_2:
 39+  CAA7 01 C0 FF                 ld    bc, bios_RAMDRead
 40+  CAAA CD 2D C4                 call  memcpy_bc_hl
 41+  CAAD
 42+  CAAD                          ; Восстанавливаем регистры и выходим
 43+  CAAD F1                       pop   af
 44+  CAAE C1                       pop   bc
 45+  CAAF D1                       pop   de
 46+  CAB0 E1                       pop   hl
 47+  CAB1 C9                       ret
 48+  CAB2
 49+  CAB2              ;----------------------------------------------------------------------------
 50+  CAB2              ; Блочный драйвер, обрабатывает сразу блок 256 байт
 51+  CAB2              ;
 52+  CAB2              ; FFC0h - чтение 256-байтного блока
 53+  CAB2              ;   вход:
 54+  CAB2              ;     c = номер страницы
 55+  CAB2              ;     d = номер блока
 56+  CAB2              ;     e = 0
 57+  CAB2              ;     hl = адрес буфера в памяти
 58+  CAB2              ;
 59+  CAB2              ; FFD0h - запись 256-байтного блока
 60+  CAB2              ;   вход:
 61+  CAB2              ;     c = номер страницы
 62+  CAB2              ;     d = номер блока
 63+  CAB2              ;     e = 0
 64+  CAB2              ;     hl = адрес буфера в памяти
 65+  CAB2              ;
 66+  CAB2              ;----------------------------------------------------------------------------
 67+  CAB2
 68+  CAB2              ; Чтение 256-байтного блока с диска
 69+  CAB2
 70+  CAB2              driverBlockStart: ; эта п/п копируется на FFC0h
 71+  CAB2 79                       ld      a, c
 72+  CAB3 32 FD FF                 ld      (IO_PAGE_RAMD), a
 73+  CAB6 1A                       ld      a, (de)
 74+  CAB7 32 FC FF                 ld      (IO_PAGE_RAM), a
 75+  CABA 77                       ld      (hl), a
 76+  CABB 23                       inc     hl
 77+  CABC 1C                       inc     e
 78+  CABD C2 C0 FF                 jp nz,  0FFC0h
 79+  CAC0 C9                       ret
 80+  CAC1
 81+  CAC1                          ; осталось места: 1 байт
 82+  CAC1 00                       nop
 83+  CAC2
 84+  CAC2              ; Запись 256-байтного блока на диск
 85+  CAC2
 86+  CAC2              driverBlockWrite: ; эта п/п копируется на FFD0h
 87+  CAC2 46                       ld      b, (hl)
 88+  CAC3 79                       ld      a, c
 89+  CAC4 32 FD FF                 ld      (IO_PAGE_RAMD), a
 90+  CAC7 78                       ld      a, b
 91+  CAC8 12                       ld      (de), a
 92+  CAC9 32 FC FF                 ld      (IO_PAGE_RAM), a
 93+  CACC 23                       inc     hl
 94+  CACD 1C                       inc     e
 95+  CACE C2 D0 FF                 jp nz,  0FFD0h
 96+  CAD1 C9                       ret
 97+  CAD2
 98+  CAD2                          ; осталось места: 0 байт
 99+  CAD2
100+  CAD2              driverBlockEnd:
101+  CAD2
102+  CAD2              ;----------------------------------------------------------------------------
103+  CAD2              ; Побайтовый драйвер, обрабатывает только 1 байт
104+  CAD2              ;
105+  CAD2              ; FFC0h - чтение байта
106+  CAD2              ;   вход:
107+  CAD2              ;     a  = номер страницы
108+  CAD2              ;     hl = адрес байта в странице ДОЗУ
109+  CAD2              ;   выход:
110+  CAD2              ;     c  = считанный байт
111+  CAD2              ;
112+  CAD2              ; FFD0h - запись байта
113+  CAD2              ;   вход:
114+  CAD2              ;     a  = номер страницы
115+  CAD2              ;     hl = байта в странице ДОЗУ
116+  CAD2              ;     c  = записываемый байт
117+  CAD2              ;
118+  CAD2              ;----------------------------------------------------------------------------
119+  CAD2
120+  CAD2              driverByteStart: ; эта п/п копируется на FFC0h
121+  CAD2 32 FD FF                 ld      (IO_PAGE_RAMD), a
122+  CAD5 4E                       ld      c, (hl)
123+  CAD6 32 FC FF                 ld      (IO_PAGE_RAM), a
124+  CAD9 C9                       ret
125+  CADA
126+  CADA                          ; осталось места: 8 байт
127+  CADA 00                       nop
128+  CADB 00                       nop
129+  CADC 00                       nop
130+  CADD 00                       nop
131+  CADE 00                       nop
132+  CADF 00                       nop
133+  CAE0 00                       nop
134+  CAE1 00                       nop
135+  CAE2
136+  CAE2              driverByteWrite: ; эта п/п копируется на FFD0h
137+  CAE2 32 FD FF                 ld      (IO_PAGE_RAMD), a
138+  CAE5 71                       ld      (hl), c
139+  CAE6 32 FC FF                 ld      (IO_PAGE_RAM), a
140+  CAE9 C9                       ret
141+  CAEA
142+  CAEA                          ; осталось места: 8 байт
143+  CAEA 00                       nop
144+  CAEB 00                       nop
145+  CAEC 00                       nop
146+  CAED 00                       nop
147+  CAEE 00                       nop
148+  CAEF 00                       nop
149+  CAF0 00                       nop
150+  CAF1 00                       nop
151+  CAF2
152+  CAF2              driverByteEnd:
153+  CAF2
154+  CAF2              ; ---------------------------------------------------------------------------
155+  CAF2
156+  CAF2              ; Проверка, что драйверы влезаеют в 32 байта разделяемой памяти Специалиста-MX
157+  CAF2
158+  CAF2                  IF driverBlockWrite-driverBlockStart+bios_RAMDRead != bios_RAMDWrite
159+  CAF2 ~                    ASSERT 0
160+  CAF2 ~                    DISPLAY /l, "Error! Block briver entry point FFD0 has been shifted: ", driverBlockWrite-driverBlockStart+bios_RAMDRead, " != 0xFFD0"
161+  CAF2                  ENDIF
162+  CAF2
163+  CAF2                  IF driverByteWrite-driverByteStart+bios_RAMDRead != bios_RAMDWrite
164+  CAF2 ~                    ASSERT 0
165+  CAF2 ~                    DISPLAY /l, "Error! Byte briver entry point FFD0 has been shifted: ", driverByteWrite-driverByteStart+bios_RAMDRead, " != 0xFFD0"
166+  CAF2                  ENDIF
167+  CAF2
168+  CAF2                  IF driverBlockEnd-driverBlockStart > 32
169+  CAF2 ~                    ASSERT 0
170+  CAF2 ~                    DISPLAY /d, "Error! Block briver did not fit: ", driverBlockEnd-driverBlockStart, " > 32 bytes"
171+  CAF2                  ENDIF
172+  CAF2
173+  CAF2                  IF driverByteEnd-driverByteStart > 32
174+  CAF2 ~                    ASSERT 0
175+  CAF2 ~                    DISPLAY /d, "Error! Byte briver did not fit: ", driverByteEnd-driverByteStart, " > 32 bytes"
176+  CAF2                  ENDIF
177+  CAF2
135   CAF2              	INCLUDE "driver.inc"
  1+  CAF2              ;+---------------------------------------------------------------------------
  2+  CAF2              ; MXOS
  3+  CAF2              ; Драйвер диска в ДОЗУ, ПЗУ
  4+  CAF2              ;
  5+  CAF2              ; Запись 256-байтного блока
  6+  CAF2              ;   На входе
  7+  CAF2              ;     b = 1                 // было: e = 1
  8+  CAF2              ;     de = номер кластера   // было: d = номер блока
  9+  CAF2              ;     hl = адрес буфера в памяти
 10+  CAF2              ;   На выходе
 11+  CAF2              ;     все регистры сохраняются
 12+  CAF2              ;
 13+  CAF2              ; Чтение 256-байтного блока
 14+  CAF2              ;   На входе
 15+  CAF2              ;     b = 2                 // было: e = 2
 16+  CAF2              ;     de = номер кластера   // было: d = номер блока
 17+  CAF2              ;     hl = адрес буфера в памяти
 18+  CAF2              ;   На выходе
 19+  CAF2              ;     все регистры сохраняются
 20+  CAF2              ;
 21+  CAF2              ; Получение размера накопителя
 22+  CAF2              ;   На входе
 23+  CAF2              ;     b = 3                 // было: e = 3
 24+  CAF2              ;   На выходе
 25+  CAF2              ;     de = кол-во секторов на диске
 26+  CAF2              ;
 27+  CAF2              ; 2013-12-12 Дизассемблировано и доработано vinxru
 28+  CAF2              ; 2022-02-02 Доработано SpaceEngineer
 29+  CAF2              ;----------------------------------------------------------------------------
 30+  CAF2
 31+  CAF2                  IF ROM_64K
 32+  CAF2              ROM_SIZE  =  0100h  ; 64 кб
 33+  CAF2                  ELSE
 34+  CAF2 ~            ROM_SIZE  =  00C0h  ; 48 кб
 35+  CAF2                  ENDIF
 36+  CAF2
 37+  CAF2              diskDriver: ; Сохраняем регистры
 38+  CAF2 F5                       push    af
 39+  CAF3
 40+  CAF3                          ; Функция 3 - Получение размера диска
 41+  CAF3 78                       ld      a, b
 42+  CAF4 FE 03                    cp      3
 43+  CAF6 CA 66 CB                 jp z,   diskDriver_s
 44+  CAF9
 45+  CAF9                           ; Сохраняем регистры
 46+  CAF9 E5                       push    hl
 47+  CAFA C5                       push    bc
 48+  CAFB D5                       push    de
 49+  CAFC
 50+  CAFC                          ; Заранее загружаем в С активный диск
 51+  CAFC 3A 3E CF                 ld      a, (v_drive)
 52+  CAFF 4F                       ld      c, a
 53+  CB00
 54+  CB00                          ; Функция 1 - Запись блока
 55+  CB00 05                       dec     b
 56+  CB01 CA 58 CB                 jp z,   diskDriver_w
 57+  CB04
 58+  CB04                          ; Функция 2 - Чтение блока
 59+  CB04 05                       dec     b
 60+  CB05 CA 0D CB                 jp z,   diskDriver_r
 61+  CB08
 62+  CB08              popDBHA_ret:
 63+  CB08                          ; Восстанавливаем регистры и выходим
 64+  CB08 D1                       pop     de
 65+  CB09 C1                       pop     bc
 66+  CB0A E1                       pop     hl
 67+  CB0B F1                       pop     af
 68+  CB0C C9                       ret
 69+  CB0D
 70+  CB0D
 71+  CB0D              ; ---------------------------------------------------------------------------
 72+  CB0D              ; Функция 2 - Чтение блока
 73+  CB0D
 74+  CB0D              diskDriver_r:
 75+  CB0D                          ; Это ROM-диск?
 76+  CB0D B7                       or      a
 77+  CB0E C2 4E CB                 jp nz,  ramDRead ; нет, переходим к драйверу RAM-диска
 78+  CB11
 79+  CB11                  IF ROM_64K
 80+  CB11
 81+  CB11                          ; Это старшая часть ПЗУ?
 82+  CB11 3E 80                    ld      a, 80h
 83+  CB13 AB                       xor     e   ;   // xor     d
 84+  CB14 FA 3A CB                 jp m,   romMXRead; нет переходим к драйверу ROM-диска MX (Специалист-MX2)
 85+  CB17
 86+  CB17                          ; Драйвер ROM-диска STD (Специалист-MX2)
 87+  CB17 57                       ld      d, a
 88+  CB18 1E 00                    ld      e, 0 ;  // new
 89+  CB1A 13                       inc     de ; пропускаем первые 4 байта в ПЗУ STD (это код перехода на загрузчик)
 90+  CB1B 13                       inc     de
 91+  CB1C 13                       inc     de
 92+  CB1D 13                       inc     de
 93+  CB1E                          ; Включаем ПЗУ STD (да, надо регистр цвета сбросить для этого)
 94+  CB1E AF                       xor     a
 95+  CB1F 32 F8 FF                 ld      (IO_COLOR), a
 96+  CB22              romStdReadLoop:
 97+  CB22                          ; Включаем режим STD
 98+  CB22 32 FF FF                 ld      (IO_PAGE_STD), a
 99+  CB25                          ; Чтение
100+  CB25 1A                       ld      a, (de)
101+  CB26                          ; Включаем ОЗУ MX
102+  CB26 32 FC F7                 ld      (IO_PAGE_RAM-800h),a
103+  CB29                          ; Запись
104+  CB29 77                       ld      (hl), a
105+  CB2A 23                       inc     hl
106+  CB2B                          ; Цикл
107+  CB2B 13                       inc     de
108+  CB2C 3E 04                    ld      a, 4
109+  CB2E BB                       cp      e
110+  CB2F C2 22 CB                 jp nz,  romStdReadLoop
111+  CB32
112+  CB32                          ; Восстаналиваем цвет
113+  CB32 3E F0                    ld      a, COLOR_BIOS
114+  CB34 32 F8 FF                 ld      (IO_COLOR), a
115+  CB37
116+  CB37                          ; Восстанавливаем регистры и выходим
117+  CB37 C3 08 CB                 jp      popDBHA_ret
118+  CB3A
119+  CB3A                  ENDIF
120+  CB3A
121+  CB3A              romMXRead:
122+  CB3A              romMXReadDrv:
123+  CB3A 79                       ld      a, c    ; c = номер страницы = 0
124+  CB3B 53                       ld      d, e    ; d = номер блока
125+  CB3C 1E 00                    ld      e, 0    ; e = 0
126+  CB3E                                          ; hl = адрес буфера в памяти
127+  CB3E              romMXReadLoop:
128+  CB3E 32 FE FF                 ld      (IO_PAGE_ROM), a
129+  CB41 1A                       ld      a, (de)
130+  CB42 32 FC FF                 ld      (IO_PAGE_RAM), a
131+  CB45 77                       ld      (hl), a
132+  CB46 23                       inc     hl
133+  CB47 1C                       inc     e
134+  CB48 C2 3E CB                 jp nz,  romMXReadLoop
135+  CB4B C3 08 CB                 jp      popDBHA_ret
136+  CB4E
137+  CB4E              ramDRead:
138+  CB4E                          ; Вызываем драйвер чтения RAM-диска
139+  CB4E 4A                       ld      c, d    ; c = номер страницы
140+  CB4F 53                       ld      d, e    ; d = номер блока
141+  CB50 1E 00                    ld      e, 0    ; e = 0
142+  CB52                                          ; hl = адрес буфера в памяти
143+  CB52 CD C0 FF                 call    bios_RAMDRead
144+  CB55
145+  CB55                          ; Восстановливаем регистры и выходим
146+  CB55 C3 08 CB                 jp      popDBHA_ret
147+  CB58
148+  CB58              ; ---------------------------------------------------------------------------
149+  CB58              ; Функция 1 - Запись блока
150+  CB58
151+  CB58              diskDriver_w:
152+  CB58                          ; Это ROM-диск?
153+  CB58 B7                       or      a
154+  CB59 CA 08 CB                 jp z,   popDBHA_ret    ; да, запись не поддерживается
155+  CB5C
156+  CB5C                          ; Вызываем драйвер записи RAM-диска
157+  CB5C 4A                       ld      c, d    ; c = номер страницы
158+  CB5D 53                       ld      d, e    ; d = номер блока
159+  CB5E 1E 00                    ld      e, 0    ; e = 0
160+  CB60                                          ; hl = адрес буфера в памяти
161+  CB60 CD D0 FF                 call    bios_RAMDWrite
162+  CB63
163+  CB63                          ; Восстановливаем регистры и выходим
164+  CB63 C3 08 CB                 jp      popDBHA_ret
165+  CB66
166+  CB66              ; ---------------------------------------------------------------------------
167+  CB66              ; Функция 3 - Получение размера диска
168+  CB66
169+  CB66              diskDriver_s:
170+  CB66 3A 3E CF                 ld      a, (v_drive)
171+  CB69 B7                       or      a               ; Это ROM-диск?
172+  CB6A C2 73 CB                 jp nz,  diskDriver_s_ram
173+  CB6D 11 00 01                 ld      de, ROM_SIZE    ; Размер ROM-диска
174+  CB70 C3 79 CB                 jp      diskDriver_s_exit
175+  CB73              diskDriver_s_ram:
176+  CB73 3A F8 8F                 ld      a, (bios_vars.ramPageCount)
177+  CB76 57                       ld      d, a
178+  CB77 1E 00                    ld      e, 0            ; Размер RAM-диска = 256 секторов * число страниц
179+  CB79              diskDriver_s_exit:
180+  CB79                          ; Восстановливаем регистры и выходим
181+  CB79 F1                       pop     af
182+  CB7A C9                       ret
183+  CB7B
184+  CB7B              ;----------------------------------------------------------------------------
185+  CB7B              ; MXOS
186+  CB7B              ; "Пустой" драйвер диска
187+  CB7B              ; Назначается при старте на устройства C: ... H:
188+  CB7B              ;
189+  CB7B              ; 2022-02-07 SpaceEngineer
190+  CB7B              ;----------------------------------------------------------------------------
191+  CB7B
192+  CB7B              ;diskDriverDummy:
193+  CB7B              ;            push    af
194+  CB7B              ;
195+  CB7B              ;            ; Функция 3 - Получение размера диска
196+  CB7B              ;            ld      a, b
197+  CB7B              ;            cp      3
198+  CB7B              ;            jp nz,  diskDriverDummyExit
199+  CB7B              ;
200+  CB7B              ;            ld      de, 0   ; вернуть 0 размер
201+  CB7B              ;
202+  CB7B              ;diskDriverDummyExit:
203+  CB7B              ;            ; Остальные функции просто ничего не делают
204+  CB7B              ;            pop     af
205+  CB7B              ;            ret
206+  CB7B
136   CB7B              	INCLUDE "installDriver.inc"
  1+  CB7B              ;+---------------------------------------------------------------------------
  2+  CB7B              ; MXOS
  3+  CB7B              ; Установить драйвер устройства
  4+  CB7B              ;
  5+  CB7B              ; На входе
  6+  CB7B              ;  a - диск
  7+  CB7B              ;  hl - адрес драйвера
  8+  CB7B              ;
  9+  CB7B              ; На выходе
 10+  CB7B              ;  bc, de, hl - сохраняются
 11+  CB7B              ;
 12+  CB7B              ; 2013-12-12 Дизассемблировано vinxru
 13+  CB7B              ;----------------------------------------------------------------------------
 14+  CB7B
 15+  CB7B              installDriver:    ; Сохранение регистров
 16+  CB7B D5                       push de
 17+  CB7C E5                       push hl
 18+  CB7D
 19+  CB7D                          ; Максимум дисков
 20+  CB7D E6 07                    and 7
 21+  CB7F
 22+  CB7F                          ; Вычисление адреса в таблице дисков
 23+  CB7F 87                       add   a, a
 24+  CB80 6F                       ld    l, a
 25+  CB81 26 00                    ld    h, 0
 26+  CB83 11 2A CF                 ld    de, v_drives
 27+  CB86 19                       add   hl, de
 28+  CB87
 29+  CB87                          ; Установка драйвера
 30+  CB87 D1                       pop   de
 31+  CB88 73                       ld  (hl), e
 32+  CB89 23                       inc   hl
 33+  CB8A 72                       ld  (hl), d
 34+  CB8B
 35+  CB8B                          ; Восстановление регистров
 36+  CB8B EB                       ex  de, hl
 37+  CB8C D1                       pop de
 38+  CB8D 0F                       rrca
 39+  CB8E
 40+  CB8E                          ; Выход
 41+  CB8E C9                       ret
 42+  CB8F
137   CB8F              	INCLUDE "fileGetSetDrive.inc"
  1+  CB8F              ;+---------------------------------------------------------------------------
  2+  CB8F              ; MXOS
  3+  CB8F              ; Получение/установка текущего накопителя.
  4+  CB8F              ; В режиме 1 функция переключает драйвер накопителя.
  5+  CB8F              ;
  6+  CB8F              ; На входе
  7+  CB8F              ;   e  - 0=чтение, 1=установка
  8+  CB8F              ;   a  - накопитель от 0 до 7
  9+  CB8F              ;
 10+  CB8F              ; На выходе
 11+  CB8F              ;   a  - накопитель
 12+  CB8F              ;   bc, de, hl - сохраняются
 13+  CB8F              ;
 14+  CB8F              ; 2013-12-12 Дизассемблировано vinxru
 15+  CB8F              ; 2022-02-02 Доработано SpaceEngineer
 16+  CB8F              ;----------------------------------------------------------------------------
 17+  CB8F
 18+  CB8F              fileGetSetDrive:
 19+  CB8F 1D                       dec     e
 20+  CB90 CA 97 CB                 jp z,   fileSelectDrive
 21+  CB93 3A 3E CF                 ld      a, (v_drive)
 22+  CB96 C9                       ret
 23+  CB97
 24+  CB97              ; ---------------------------------------------------------------------------
 25+  CB97
 26+  CB97              fileSelectDrive:
 27+  CB97                          ; Максимум устройств - 1
 28+  CB97 E6 07                    and     7
 29+  CB99
 30+  CB99                          ; Сохраняем выбранное устройство
 31+  CB99 32 3E CF                 ld      (v_drive), a
 32+  CB9C
 33+  CB9C                          ; Пригодится ниже (a = a * 2)
 34+  CB9C 87                       add     a, a
 35+  CB9D
 36+  CB9D                          ; Сохраняем регистры
 37+  CB9D E5                       push    hl
 38+  CB9E D5                       push    de
 39+  CB9F
 40+  CB9F                          ; Получаем точку входа драйвера
 41+  CB9F 6F                       ld      l, a
 42+  CBA0 26 00                    ld      h, 0
 43+  CBA2 11 2A CF                 ld      de, v_drives
 44+  CBA5 19                       add     hl, de
 45+  CBA6 5E                       ld      e, (hl)
 46+  CBA7 23                       inc     hl
 47+  CBA8 56                       ld      d, (hl)
 48+  CBA9 EB                       ex      de, hl
 49+  CBAA
 50+  CBAA                          ; Сохраняем её
 51+  CBAA 22 64 C8                 ld      (j_diskDriver+1), hl
 52+  CBAD
 53+  CBAD                          ; Восстаналвиаем a
 54+  CBAD 0F                       rrca
 55+  CBAE
 56+  CBAE                          ; Восстанавливаем регистры и выходим
 57+  CBAE D1                       pop     de
 58+  CBAF E1                       pop     hl
 59+  CBB0 C9                       ret
 60+  CBB1
138   CBB1              	INCLUDE "loadSaveFatDir.inc"
  1+  CBB1              ;+---------------------------------------------------------------------------
  2+  CBB1              ; MXOS
  3+  CBB1              ; Сохранить FAT и корневой каталог на устройство
  4+  CBB1              ;
  5+  CBB1              ; На выходе
  6+  CBB1              ;  регистры bc, de, hl сохраняются
  7+  CBB1              ;
  8+  CBB1              ; 2013-12-12 Дизассемблировано vinxru
  9+  CBB1              ;----------------------------------------------------------------------------
 10+  CBB1
 11+  CBB1              saveFatDir: ; Сохраняем регистры
 12+  CBB1 C5                       push    bc
 13+  CBB2 D5                       push    de
 14+  CBB3
 15+  CBB3                          ; Режим - запись
 16+  CBB3 06 01                    ld      b, 1
 17+  CBB5
 18+  CBB5                          ; Переход к общему коду
 19+  CBB5 C3 BC CB                 jp      loadFatDirCommon
 20+  CBB8
 21+  CBB8              ;----------------------------------------------------------------------------
 22+  CBB8              ; Загрузить FAT и корневой каталог с устройства
 23+  CBB8              ;
 24+  CBB8              ; На выходе
 25+  CBB8              ;  регистры bc, de, hl сохраняются
 26+  CBB8              ;----------------------------------------------------------------------------
 27+  CBB8
 28+  CBB8              loadFatDir: ; Сохраняем регистры
 29+  CBB8 C5                       push    bc
 30+  CBB9 D5                       push    de
 31+  CBBA
 32+  CBBA                          ; Режим - чтение
 33+  CBBA 06 02                    ld      b, 2
 34+  CBBC
 35+  CBBC              loadFatDirCommon:
 36+  CBBC                          ; Сохраняем регистры
 37+  CBBC E5                       push    hl
 38+  CBBD
 39+  CBBD                          ; Чтение/запись буфера fat и каталога в начало диска
 40+  CBBD 0E 14                    ld      c, FAT_CLUSTERS + DIR_CLUSTERS  ; сколько кластеров читать/писать
 41+  CBBF 21 00 6C                 ld      hl, FAT_BUFFER                  ; адрес буфера
 42+  CBC2 11 00 00                 ld      de, 0                           ; первый кластер
 43+  CBC5
 44+  CBC5              loadFatDirLoop:
 45+  CBC5 CD 63 C8                 call    j_diskDriver
 46+  CBC8 24                       inc     h       ; следующий блок в памяти, TODO: это работает только для кластеров 256 байт!
 47+  CBC9 1C                       inc     e       ; следующий кластер
 48+  CBCA 0D                       dec     c
 49+  CBCB C2 C5 CB                 jp nz,  loadFatDirLoop
 50+  CBCE
 51+  CBCE                          ; Восстанавливаем регистры и выходим
 52+  CBCE E1                       pop     hl
 53+  CBCF D1                       pop     de
 54+  CBD0 C1                       pop     bc
 55+  CBD1 C9                       ret
 56+  CBD2
139   CBD2              	INCLUDE "fatFindCluster.inc"
  1+  CBD2              ;+---------------------------------------------------------------------------
  2+  CBD2              ; MXOS
  3+  CBD2              ; Поиск свободного кластера
  4+  CBD2              ;
  5+  CBD2              ; На выходе
  6+  CBD2              ;  cf - ошибка
  7+  CBD2              ;  de - номер кластера
  8+  CBD2              ;  регистры bc, hl сохраняются
  9+  CBD2              ;
 10+  CBD2              ; 2013-12-12 Дизассемблировано vinxru
 11+  CBD2              ; 2022-02-04 Переработано SpaceEngineer
 12+  CBD2              ;----------------------------------------------------------------------------
 13+  CBD2
 14+  CBD2              fatFindClusterFirst:
 15+  CBD2                          ; Сохраняем регистры
 16+  CBD2 E5                       push  hl
 17+  CBD3
 18+  CBD3                          ; de = номер первого кластера для поиска
 19+  CBD3                          ; Первые FAT_CLUSTERS + DIR_CLUSTERS ячеек fat не используются
 20+  CBD3 11 14 00                 ld    de, FAT_CLUSTERS + DIR_CLUSTERS
 21+  CBD6
 22+  CBD6 C3 DF CB                 jp    fatFindClusterCommon
 23+  CBD9
 24+  CBD9              ;----------------------------------------------------------------------------
 25+  CBD9              ; Поиск следующего свободного кластера
 26+  CBD9              ;
 27+  CBD9              ; На выходе
 28+  CBD9              ;  cf - ошибка
 29+  CBD9              ;  de - номер кластера
 30+  CBD9              ;  регистры bc, hl сохраняются
 31+  CBD9              ;----------------------------------------------------------------------------
 32+  CBD9
 33+  CBD9              fatFindClusterNext:
 34+  CBD9                          ; Сохраняем регистры
 35+  CBD9 E5                       push    hl
 36+  CBDA
 37+  CBDA                          ; Предыдущий найденный кластер
 38+  CBDA 2A 3A CF                 ld      hl, (v_findCluster)
 39+  CBDD
 40+  CBDD                          ; Начинаем поиск со следующего кластера
 41+  CBDD 23                       inc     hl
 42+  CBDE EB                       ex      hl, de
 43+  CBDF
 44+  CBDF                          ; Ищем свободный кластер: перебераем все ячейки fat, пока не найдём 0
 45+  CBDF              fatFindClusterCommon:
 46+  CBDF C5                       push    bc
 47+  CBE0 01 00 08                 ld      bc, FAT_SIZE / FAT_ITEM_SIZE; кол-во ячеек fat
 48+  CBE3
 49+  CBE3              fatFindClusterLoop:
 50+  CBE3                          ; Запоминаем номер последнего кластера в hl
 51+  CBE3 62                       ld      h, d
 52+  CBE4 6B                       ld      l, e
 53+  CBE5
 54+  CBE5                          ; de = fat[de]
 55+  CBE5 CD 04 CC                 call    fatReadCluster
 56+  CBE8
 57+  CBE8                          ; Сравниваем de с нулем
 58+  CBE8 7A                       ld      a, d
 59+  CBE9 B3                       or      e
 60+  CBEA CA FC CB                 jp z,   fatFindClusterOk  ; найден
 61+  CBED
 62+  CBED                          ; Следующий кластер
 63+  CBED 54                       ld      d, h
 64+  CBEE 5D                       ld      e, l
 65+  CBEF 13                       inc     de
 66+  CBF0
 67+  CBF0                          ; Счётчик просмотренных ячеек fat
 68+  CBF0 0B                       dec     bc
 69+  CBF1 78                       ld      a, b
 70+  CBF2 B1                       or      c
 71+  CBF3 C2 E3 CB                 jp nz,  fatFindClusterLoop  ; повтор цикла
 72+  CBF6
 73+  CBF6              ; ---------------------------------------------------------------------------
 74+  CBF6
 75+  CBF6                          ; Свободный кластер не найден
 76+  CBF6                          ; Восстанавливаем регистры и выходим с a=1, CF=1, ZF=0
 77+  CBF6 C1                       pop     bc
 78+  CBF7 E1                       pop     hl
 79+  CBF8 3E 01                    ld      a, 1
 80+  CBFA 37                       scf
 81+  CBFB C9                       ret
 82+  CBFC
 83+  CBFC              ; ---------------------------------------------------------------------------
 84+  CBFC
 85+  CBFC                          ; Свободный кластер найден
 86+  CBFC              fatFindClusterOk:
 87+  CBFC                          ; Устаналиваем ZF=0. Номер кластера не может быть нулевым.
 88+  CBFC                          ; В случае ошибки мы тоже выходим с ZF=1
 89+  CBFC B7                       or      a
 90+  CBFD
 91+  CBFD                          ; Для ускорения поиска сохраняем номер найденного кластера в v_findCluster
 92+  CBFD 22 3A CF                 ld      (v_findCluster), hl
 93+  CC00 EB                       ex      hl, de
 94+  CC01
 95+  CC01                          ; Восстанавливаем регистры и выходим с CF=0, ZF=0
 96+  CC01 C1                       pop     bc
 97+  CC02 E1                       pop     hl
 98+  CC03 C9                       ret
 99+  CC04
140   CC04                  INCLUDE "fatReadWriteCluster.inc"
  1+  CC04              ;----------------------------------------------------------------------------
  2+  CC04              ; MXOS
  3+  CC04              ;
  4+  CC04              ; Чтение номера кластера из таблицы fat
  5+  CC04              ;
  6+  CC04              ; вход:
  7+  CC04              ;   de = номер кластера
  8+  CC04              ;
  9+  CC04              ; выход:
 10+  CC04              ;   de = номер следующего кластера
 11+  CC04              ;   остальные регистры сохраняются
 12+  CC04              ;
 13+  CC04              ; СИ аналог:
 14+  CC04              ;   de = fat[de]
 15+  CC04              ;
 16+  CC04              ; 2022-02-04 SpaceEngineer
 17+  CC04              ;----------------------------------------------------------------------------
 18+  CC04
 19+  CC04              fatReadCluster:
 20+  CC04 E5                       push    hl
 21+  CC05
 22+  CC05                          ; уможаем de на 2 - смещение элемента с номером кластера в таблице fat
 23+  CC05 EB                       ex      de, hl
 24+  CC06 29                       add     hl, hl
 25+  CC07
 26+  CC07                          ; прибавляем к адресу таблицы fat
 27+  CC07 11 00 6C                 ld      de, FAT_BUFFER   ; de = адрес таблицы fat в памяти
 28+  CC0A 19                       add     hl, de          ; hl = адрес следующего элемента в таблице fat
 29+  CC0B
 30+  CC0B                          ; читаем номер кластера из fat
 31+  CC0B 5E                       ld      e, (hl)
 32+  CC0C 23                       inc     hl
 33+  CC0D 56                       ld      d, (hl)
 34+  CC0E
 35+  CC0E                          ; восстанавливаем регистры и выходим
 36+  CC0E E1                       pop     hl
 37+  CC0F C9                       ret
 38+  CC10
 39+  CC10              ;----------------------------------------------------------------------------
 40+  CC10              ; MXOS
 41+  CC10              ;
 42+  CC10              ; Запись номера кластера в таблицу fat и переход на следующий адрес ячейки
 43+  CC10              ;
 44+  CC10              ; вход:
 45+  CC10              ;   hl = адрес ячейки fat, куда писать
 46+  CC10              ;   de = номер кластера, чтобы записать
 47+  CC10              ;
 48+  CC10              ; выход:
 49+  CC10              ;   hl = адрес ячейки fat, куда указывал de
 50+  CC10              ;   остальные регистры сохраняются
 51+  CC10              ;
 52+  CC10              ; СИ аналог:
 53+  CC10              ;   fat[de] = de;
 54+  CC10              ;   hl = &fat[de];
 55+  CC10              ;
 56+  CC10              ; 2022-02-04 SpaceEngineer
 57+  CC10              ;----------------------------------------------------------------------------
 58+  CC10
 59+  CC10              fatWriteCluster:
 60+  CC10 D5                       push    de
 61+  CC11
 62+  CC11                          ; записываем номер кластера в fat по адресу hl
 63+  CC11 73                       ld      (hl), e
 64+  CC12 23                       inc     hl
 65+  CC13 72                       ld      (hl), d
 66+  CC14
 67+  CC14                          ; уможаем de на 2 - смещение ячейки с номером de в таблице fat
 68+  CC14 EB                       ex      de, hl
 69+  CC15 29                       add     hl, hl
 70+  CC16
 71+  CC16                          ; прибавляем к адресу таблицы fat
 72+  CC16 11 00 6C                 ld      de, FAT_BUFFER   ; de = адрес таблицы fat в памяти
 73+  CC19 19                       add     hl, de          ; hl = адрес ячеки с номером de в таблице fat
 74+  CC1A
 75+  CC1A                          ; восстанавливаем регистры и выходим
 76+  CC1A D1                       pop     de
 77+  CC1B C9                       ret
 78+  CC1C
 79+  CC1C              ;----------------------------------------------------------------------------
 80+  CC1C              ; MXOS
 81+  CC1C              ;
 82+  CC1C              ; Освобождение номера кластера в таблице fat
 83+  CC1C              ;
 84+  CC1C              ; вход:
 85+  CC1C              ;   de = номер кластера
 86+  CC1C              ;
 87+  CC1C              ; выход:
 88+  CC1C              ;   de = номер следующего кластера
 89+  CC1C              ;   остальные регистры сохраняются
 90+  CC1C              ;
 91+  CC1C              ; СИ аналог:
 92+  CC1C              ;   de = fat[de]
 93+  CC1C              ;
 94+  CC1C              ; 2022-02-04 SpaceEngineer
 95+  CC1C              ;----------------------------------------------------------------------------
 96+  CC1C
 97+  CC1C              fatFreeCluster:
 98+  CC1C E5                       push    hl
 99+  CC1D
100+  CC1D                          ; уможаем de на 2 - смещение элемента с номером кластера в таблице fat
101+  CC1D EB                       ex      de, hl
102+  CC1E 29                       add     hl, hl
103+  CC1F
104+  CC1F                          ; прибавляем к адресу таблицы fat
105+  CC1F 11 00 6C                 ld      de, FAT_BUFFER   ; de = адрес таблицы fat в памяти
106+  CC22 19                       add     hl, de          ; hl = адрес следующего элемента в таблице fat
107+  CC23
108+  CC23                          ; читаем номер кластера из fat, и сразу записываем туда нули
109+  CC23 5E                       ld      e, (hl)
110+  CC24 36 00                    ld      (hl), 0
111+  CC26 23                       inc     hl
112+  CC27 56                       ld      d, (hl)
113+  CC28 36 00                    ld      (hl), 0
114+  CC2A
115+  CC2A                          ; восстанавливаем регистры и выходим
116+  CC2A E1                       pop     hl
117+  CC2B C9                       ret
118+  CC2C
119+  CC2C
141   CC2C              	INCLUDE "fileCreate.inc"
  1+  CC2C              ;----------------------------------------------------------------------------
  2+  CC2C              ; MXOS
  3+  CC2C              ; Создать файл
  4+  CC2C              ;
  5+  CC2C              ; На входе
  6+  CC2C              ;  hl - адрес дескриптора файла в формате FAT (имя, фтрибуты, размер и т.д.)
  7+  CC2C              ;
  8+  CC2C              ; На выходе
  9+  CC2C              ;  сf - ошибка
 10+  CC2C              ;
 11+  CC2C              ; 2013-12-12 Дизассемблировано vinxru
 12+  CC2C              ; 2022-02-04 Переработано SpaceEngineer
 13+  CC2C              ;----------------------------------------------------------------------------
 14+  CC2C
 15+  CC2C              fileCreate: ; Сохраняем регистры
 16+  CC2C E5                       push    hl
 17+  CC2D C5                       push    bc
 18+  CC2E D5                       push    de
 19+  CC2F
 20+  CC2F                          ; Если файл существует, то удаляем его
 21+  CC2F CD EB CC                 call    fileFind
 22+  CC32 D4 90 CD                 call nc,deleteFileInt
 23+  CC35
 24+  CC35                          ; Сохраняем готовый дескриптор файла
 25+  CC35 E5                       push    hl
 26+  CC36
 27+  CC36                          ; Ищем свободную запись в каталоге
 28+  CC36 21 00 7C                 ld      hl, DIR_BUFFER      ; адрес каталога
 29+  CC39 11 20 00                 ld      de, DIR_DESCR_SIZE  ; размер записи в каталоге
 30+  CC3C 06 20                    ld      b,  DIR_MAX_FILES   ; максимум файлов
 31+  CC3E              fileCreate_0:
 32+  CC3E 7E                       ld      a, (hl)             ; читаем байт из каталога
 33+  CC3F 3C                       inc     a                   ; если байт = 0FFh, значит
 34+  CC40 CA 4F CC                 jp z,   fileCreate_1        ; свободная запись найдена
 35+  CC43 19                       add     hl, de              ; следующая запись
 36+  CC44 05                       dec     b                   ; счетчик макс. кол-ва файлов
 37+  CC45 C2 3E CC                 jp nz,  fileCreate_0
 38+  CC48
 39+  CC48                          ; Свободных записей нет
 40+  CC48
 41+  CC48                          ; Освобождаем стек
 42+  CC48 E1                       pop     hl
 43+  CC49
 44+  CC49                          ; Установка a=0, ZF=1
 45+  CC49 AF                       xor     a
 46+  CC4A
 47+  CC4A              stc_popDBH_ret:
 48+  CC4A                          ; Установка флага CF=1
 49+  CC4A 37                       scf
 50+  CC4B
 51+  CC4B              popDBH_ret: ; Восстановление регистров и выход
 52+  CC4B D1                       pop     de
 53+  CC4C C1                       pop     bc
 54+  CC4D E1                       pop     hl
 55+  CC4E C9                       ret
 56+  CC4F
 57+  CC4F              ; ---------------------------------------------------------------------------
 58+  CC4F              ; Свободная запись найдена
 59+  CC4F
 60+  CC4F              fileCreate_1:
 61+  CC4F                          ; Сохраняем адрес дескриптора создаваемого файла в буфере каталога
 62+  CC4F 22 41 CF                 ld      (v_createdFile), hl
 63+  CC52
 64+  CC52                          ; Копируем в de
 65+  CC52 EB                       ex      de, hl
 66+  CC53
 67+  CC53                          ; Адрес готового дескриптора файла в hl
 68+  CC53 E1                       pop     hl
 69+  CC54
 70+  CC54                          ; Копируем готовый дескриптор файла в каталог (из hl в de)
 71+  CC54 0E 20                    ld      c, DIR_DESCR_SIZE
 72+  CC56              fileCreate_2:
 73+  CC56 7E                       ld      a, (hl)
 74+  CC57 12                       ld      (de), a
 75+  CC58 23                       inc     hl
 76+  CC59 13                       inc     de
 77+  CC5A 0D                       dec     c
 78+  CC5B C2 56 CC                 jp nz,  fileCreate_2
 79+  CC5E
 80+  CC5E CD D2 CB                 call    fatFindClusterFirst ; de = первый свободный кластер
 81+  CC61 DA 4A CC                 jp c,   stc_popDBH_ret      ; если нет свободных кластеров - выходим с ошибкой
 82+  CC64
 83+  CC64                          ; Сохраняем его в переменную v_fileFirstCluster
 84+  CC64 EB                       ex      hl, de
 85+  CC65 22 3C CF                 ld      (v_fileFirstCluster), hl
 86+  CC68 EB                       ex      hl, de
 87+  CC69
 88+  CC69                          ; Сохраняем в каталог номер первого кластера
 89+  CC69                          ; de = номер первого кластера
 90+  CC69 2A 41 CF                 ld      hl, (v_createdFile)
 91+  CC6C 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
 92+  CC6F 09                       add     hl, bc  ; hl = адрес поля firstCluster (мл. байт) в дескрипторе файла
 93+  CC70 73                       ld      (hl), e
 94+  CC71 23                       inc     hl      ; hl = адрес поля firstCluster (ст. байт) в дескрипторе файла
 95+  CC72 72                       ld      (hl), d
 96+  CC73
 97+  CC73              		    ; Читаем адрес загрузки файла
 98+  CC73                          ; de = адрес загрузки файла
 99+  CC73 2A 41 CF                 ld      hl, (v_createdFile)
100+  CC76 01 12 00                 ld      bc, FILE_DESCRIPTOR.loadAddress
101+  CC79 09                       add     hl, bc  ; hl = адрес поля loadAddress (мл. байт) в дескрипторе файла
102+  CC7A 5E                       ld      e, (hl)
103+  CC7B 23                       inc     hl      ; hl = адрес поля loadAddress (ст. байт) в дескрипторе файла
104+  CC7C 56                       ld      d, (hl) ; de = адрес загрузки
105+  CC7D
106+  CC7D                          ; Сохраняем адрес загрузки в переменную v_input_start
107+  CC7D EB                       ex      de, hl
108+  CC7E 22 3F CF                 ld      (v_input_start), hl ; v_input_start = адрес загрузки файла
109+  CC81
110+  CC81                          ; Читаем размер файла
111+  CC81                          ; de = размер файла
112+  CC81 2A 41 CF                 ld      hl, (v_createdFile)
113+  CC84 01 1C 00                 ld      bc, FILE_DESCRIPTOR.size
114+  CC87 09                       add     hl, bc  ; hl = адрес поля size (мл. байт) в дескрипторе файла
115+  CC88 5E                       ld      e, (hl)
116+  CC89 23                       inc     hl      ; hl = адрес поля size (ст. байт) в дескрипторе файла
117+  CC8A 56                       ld      d, (hl)
118+  CC8B
119+  CC8B                          ; Сохраняем размер файла в переменную v_input_end
120+  CC8B EB                       ex      de, hl
121+  CC8C 22 45 CF                 ld      (v_input_end), hl   ; v_input_end = размер файла
122+  CC8F
123+  CC8F                          ; Счётчик кластеров файла
124+  CC8F 4C                       ld      c, h        ; c  = старший байт размера = количество кластеров файла - 1, т.к. кластер размером 256 байт.
125+  CC90 0C                       inc     c           ; c  = количество кластеров файла. TODO: это не будет работать с другим размером кластера!
126+  CC91 41                       ld      b, c        ; сохраняем в b - пригодится позже
127+  CC92
128+  CC92                          ; Вычисляем первый кластер в fat
129+  CC92 2A 3C CF                 ld      hl, (v_fileFirstCluster)    ; hl = номер первого кластера файла
130+  CC95 E5                       push    hl
131+  CC96 29                       add     hl, hl
132+  CC97 11 00 6C                 ld      de, FAT_BUFFER   ; de = адрес таблицы fat в памяти
133+  CC9A 19                       add     hl, de          ; hl = указатель на первый кластер файла в таблице fat
134+  CC9B D1                       pop     de              ; de = номер первого кластера файла
135+  CC9C
136+  CC9C C3 A5 CC                 jp      writeFirstCluster
137+  CC9F
138+  CC9F              ; ---------------------------------------------------------------------------
139+  CC9F              ; Записываем кластеры файла в таблицу fat в памяти
140+  CC9F
141+  CC9F              allocClusters:
142+  CC9F CD D9 CB                 call    fatFindClusterNext  ; de = следующий свободный кластер
143+  CCA2 DA 4A CC                 jp c,   stc_popDBH_ret      ; если больше нет свободных кластеров - выходим с ошибкой
144+  CCA5
145+  CCA5              writeFirstCluster:
146+  CCA5                          ; записываем номер кластера в fat и переходим на следущий
147+  CCA5                          ; hl = адрес ячейки с номером кластера
148+  CCA5                          ; de = номер кластера
149+  CCA5 CD 10 CC                 call    fatWriteCluster
150+  CCA8
151+  CCA8 0D                       dec     c               ; счётчик записанных кластеров
152+  CCA9 C2 9F CC                 jp nz,  allocClusters   ; повтор цикла
153+  CCAC
154+  CCAC                          ; Конец, последний кластер файла указывает сам на себя
155+  CCAC 73                       ld      (hl), e
156+  CCAD 23                       inc     hl
157+  CCAE 72                       ld      (hl), d
158+  CCAF
159+  CCAF              ; ---------------------------------------------------------------------------
160+  CCAF              ; Сохраняем файл на диск
161+  CCAF
162+  CCAF 2A 3C CF                 ld      hl, (v_fileFirstCluster)
163+  CCB2 EB                       ex      hl, de                      ; de = номер первого кластера файла
164+  CCB3 2A 3F CF                 ld      hl, (v_input_start)         ; hl = адрес загрузки файла
165+  CCB6 48                       ld      c, b                        ; c = количество кластеров файла
166+  CCB7 06 01                    ld      b, 1                        ; режим драйвера 1 - запись
167+  CCB9              writeFileLoop:
168+  CCB9 CD 63 C8                 call    j_diskDriver
169+  CCBC 24                       inc     h                           ; cледующий блок файла в памяти (TODO: это работает только для кластера 256 байт)
170+  CCBD
171+  CCBD                          ; Находим следующий кластер в fat
172+  CCBD CD 04 CC                 call    fatReadCluster              ; de = номер следующего кластера
173+  CCC0
174+  CCC0 0D                       dec     c                           ; счётчик записанных кластеров
175+  CCC1 C2 B9 CC                 jp nz,  writeFileLoop               ; повтор цикла
176+  CCC4
177+  CCC4              ; ---------------------------------------------------------------------------
178+  CCC4              ; Расчет однобайтовой контрольной суммы
179+  CCC4
180+  CCC4 2A 45 CF                 ld      hl, (v_input_end)   ; hl = размер файла - 1 из v_input_end
181+  CCC7 23                       inc     hl                  ; hl = размер файла
182+  CCC8 EB                       ex      de, hl              ; de = размер файла
183+  CCC9 2A 3F CF                 ld      hl, (v_input_start) ; hl = адрес загрузки файла из v_input_start
184+  CCCC 06 00                    ld      b, 0                ; тут будет накапливаться сумма
185+  CCCE              fileCreateCRCLoop:
186+  CCCE 7A                       ld      a, d
187+  CCCF B3                       or      e
188+  CCD0 CA DB CC                 jp z,   fileCreateExit      ; если счетчик досчитал до нуля, выходим
189+  CCD3 7E                       ld  a,  (hl)                ; читаем байт файла
190+  CCD4 80                       add     a, b                ; накапливаем сумму
191+  CCD5 47                       ld      b, a
192+  CCD6 23                       inc     hl                  ; следующий байт
193+  CCD7 1B                       dec     de                  ; уменьшаем счетчик
194+  CCD8 C3 CE CC                 jp      fileCreateCRCLoop
195+  CCDB
196+  CCDB              ; ------------------------------------------------------------------------------------------------------------------------
197+  CCDB              ; Сохранение и выход
198+  CCDB
199+  CCDB              fileCreateExit:
200+  CCDB                          ; Сохраняем контрольную сумму в дескриптор файла
201+  CCDB 78                       ld      a, b                ; a = посчитанная контрольная сумма
202+  CCDC 2A 41 CF                 ld      hl, (v_createdFile)
203+  CCDF 01 0C 00                 ld      bc, FILE_DESCRIPTOR.checkSum
204+  CCE2 09                       add     hl, bc              ; hl = адрес поля checkSum в дескрипторе файла
205+  CCE3 77                       ld      (hl), a             ; сохраняем контрльную сумму
206+  CCE4
207+  CCE4 CD B1 CB                 call    saveFatDir          ; сохраняем fat и каталог на диск
208+  CCE7 B7                       or      a                   ; выходим с флагом cf = 0
209+  CCE8 C3 4B CC                 jp      popDBH_ret
210+  CCEB
142   CCEB              	INCLUDE "fileFind.inc"
  1+  CCEB              ;+---------------------------------------------------------------------------
  2+  CCEB              ; MXOS
  3+  CCEB              ; Найти файл
  4+  CCEB              ;
  5+  CCEB              ; На входе
  6+  CCEB              ;  hl - имя
  7+  CCEB              ;
  8+  CCEB              ; На выходе
  9+  CCEB              ;  bc, de, hl - сохраняются
 10+  CCEB              ;  cf - ошибка
 11+  CCEB              ;  v_foundedFile - найденный файл
 12+  CCEB              ;
 13+  CCEB              ; 2013-12-12 Дизассемблировано vinxru
 14+  CCEB              ;----------------------------------------------------------------------------
 15+  CCEB
 16+  CCEB              fileFind:   ; Загрузка FAT и корневого каталога в память
 17+  CCEB CD B8 CB                 call    loadFatDir
 18+  CCEE
 19+  CCEE              fileFind2:  ; Сохраняем регистры
 20+  CCEE C5                       push    bc
 21+  CCEF D5                       push    de
 22+  CCF0
 23+  CCF0                          ; Начало каталога
 24+  CCF0 11 00 7C                 ld      de, DIR_BUFFER
 25+  CCF3
 26+  CCF3                          ; Кол-во файлов в каталоге
 27+  CCF3 06 20                    ld      b, DIR_MAX_FILES
 28+  CCF5
 29+  CCF5              fileFind_loop:
 30+  CCF5                          ; Сохраняем адрес начала имени в каталоге и образец
 31+  CCF5 E5                       push    hl
 32+  CCF6 D5                       push    de
 33+  CCF7
 34+  CCF7                          ; Если первый символ имени 0FFh, переходим к следующем файлу
 35+  CCF7 1A                       ld      a, (de)
 36+  CCF8 3C                       inc     a
 37+  CCF9 CA 12 CD                 jp z,   fileFind_next
 38+  CCFC
 39+  CCFC                          ; Длина имени + расширения
 40+  CCFC 0E 0B                    ld      c, DIR_NAME_LENGTH + 3
 41+  CCFE
 42+  CCFE              fileFind_name:
 43+  CCFE                          ; Если символы не равны, переходим к следующему файлу
 44+  CCFE 1A                       ld      a, (de)
 45+  CCFF BE                       cp      (hl)
 46+  CD00 C2 12 CD                 jp nz,  fileFind_next
 47+  CD03 23                       inc     hl
 48+  CD04 13                       inc     de
 49+  CD05
 50+  CD05                          ; Цикл
 51+  CD05 0D                       dec     c
 52+  CD06 C2 FE CC                 jp nz,  fileFind_name
 53+  CD09
 54+  CD09                          ; Сохраняем адрес найденного файла
 55+  CD09 E1                       pop     hl
 56+  CD0A 22 43 CF                 ld      (v_foundedFile), hl
 57+  CD0D
 58+  CD0D                          ; Восстаналиваем регистры и выходим с CF=0
 59+  CD0D E1                       pop     hl
 60+  CD0E B7                       or      a     ; для выхода с флагом
 61+  CD0F D1                       pop     de
 62+  CD10 C1                       pop     bc
 63+  CD11 C9                       ret
 64+  CD12
 65+  CD12              ; ---------------------------------------------------------------------------
 66+  CD12
 67+  CD12              fileFind_next:    ; Вычисляем адрес следующего файла
 68+  CD12 D1                       pop   de
 69+  CD13 21 20 00                 ld    hl, DIR_DESCR_SIZE
 70+  CD16 19                       add   hl, de
 71+  CD17 EB                       ex    de, hl
 72+  CD18
 73+  CD18                          ; Восстанавливаем образец
 74+  CD18 E1                       pop   hl
 75+  CD19
 76+  CD19                          ; Еще остались файлы?
 77+  CD19 05                       dec   b
 78+  CD1A C2 F5 CC                 jp nz,  fileFind_loop
 79+  CD1D
 80+  CD1D                          ; Восстаналиваем регистры и выходим с CF=1 и a=3
 81+  CD1D D1                       pop   de
 82+  CD1E C1                       pop   bc
 83+  CD1F 3E 03                    ld    a, 3
 84+  CD21 37                       scf
 85+  CD22 C9                       ret
 86+  CD23
143   CD23              	INCLUDE "fileLoad.inc"
  1+  CD23              ;+---------------------------------------------------------------------------
  2+  CD23              ; MXOS
  3+  CD23              ; Загрузить файл
  4+  CD23              ;
  5+  CD23              ; На входе
  6+  CD23              ;  hl - имя
  7+  CD23              ;  de - адрес загрузки
  8+  CD23              ;
  9+  CD23              ; На выходе
 10+  CD23              ;  bc, de, hl - сохраняются
 11+  CD23              ;  v_foundedFile - найденный файл
 12+  CD23              ;  cf - ошибка
 13+  CD23              ;
 14+  CD23              ; 2013-12-12 Дизассемблировано vinxru
 15+  CD23              ; 2022-02-04 Переработано SpaceEngineer
 16+  CD23              ;----------------------------------------------------------------------------
 17+  CD23
 18+  CD23              fileLoad2:  ; Ищем файл с именем в hl
 19+  CD23
 20+  CD23                          ; SpaceEngineer: функция fileFind2 пропускает обновление буфера fat и
 21+  CD23                          ; каталога текущего диска. Из-за этого fileLoad2 некорректно работает
 22+  CD23                          ; с файлами на ром-диске (A:, без поддержки записи - потому что изменение
 23+  CD23                          ; адреса загрузки программы сделано несколько костыльно, через патчинг
 24+  CD23                          ; этого адреса в структуре каталога).
 25+  CD23                          ; Вызывающая программа могла бы сама вызвать loadFatDir перед вызовом
 26+  CD23                          ; fileLoad2, но, к сожалению, loadFatDir не числится в списке стандартных
 27+  CD23                          ; точек вызова.
 28+  CD23
 29+  CD23                          ;call    fileFind2
 30+  CD23 CD EB CC                 call    fileFind
 31+  CD26 D8                       ret c
 32+  CD27
 33+  CD27                          ; Сохранить регистры
 34+  CD27 E5                       push    hl
 35+  CD28 C5                       push    bc
 36+  CD29 D5                       push    de
 37+  CD2A
 38+  CD2A C3 3E CD                 jp      fileLoadStep2
 39+  CD2D
 40+  CD2D              ;----------------------------------------------------------------------------
 41+  CD2D              ; Загрузить файл по адресу указанному в заголовке
 42+  CD2D              ;
 43+  CD2D              ; На входе
 44+  CD2D              ;  hl - имя
 45+  CD2D              ;
 46+  CD2D              ; На выходе
 47+  CD2D              ;  bc, de, hl - сохраняются
 48+  CD2D              ;  v_foundedFile - найденный файл
 49+  CD2D              ;  cf - ошибка
 50+  CD2D              ;----------------------------------------------------------------------------
 51+  CD2D
 52+  CD2D              fileLoad:   ; Ищем файл с именем в hl
 53+  CD2D CD EB CC                 call    fileFind
 54+  CD30 D8                       ret c
 55+  CD31
 56+  CD31                          ; Сохраняем регистры
 57+  CD31 E5                       push    hl
 58+  CD32 C5                       push    bc
 59+  CD33 D5                       push    de
 60+  CD34
 61+  CD34                          ; hl = указатель на адрес загрузки
 62+  CD34 2A 43 CF                 ld      hl, (v_foundedFile)
 63+  CD37 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 64+  CD3A 19                       add     hl, de
 65+  CD3B
 66+  CD3B                          ; de = адрес загрузки
 67+  CD3B 5E                       ld      e, (hl)
 68+  CD3C 23                       inc     hl
 69+  CD3D 56                       ld      d, (hl)
 70+  CD3E
 71+  CD3E              fileLoadStep2:
 72+  CD3E                          ; Сохраним адрес загрузки
 73+  CD3E D5                       push    de
 74+  CD3F
 75+  CD3F                          ; hl = указатель на номер первого кластера файла
 76+  CD3F 2A 43 CF                 ld      hl, (v_foundedFile)
 77+  CD42 01 1A 00                 ld      bc, FILE_DESCRIPTOR.firstCluster
 78+  CD45 09                       add     hl, bc
 79+  CD46
 80+  CD46                          ; de = первый кластер файла
 81+  CD46 5E                       ld      e, (hl)
 82+  CD47 23                       inc     hl
 83+  CD48 56                       ld      d, (hl)
 84+  CD49
 85+  CD49                          ; hl = указатель на длину найденного файла
 86+  CD49 2A 43 CF                 ld      hl, (v_foundedFile)
 87+  CD4C 01 1D 00                 ld      bc, FILE_DESCRIPTOR.size + 1
 88+  CD4F 09                       add     hl, bc
 89+  CD50
 90+  CD50                          ; c = количество кластеров файла. Просто читаем старший байт
 91+  CD50                          ; размера, т.к. кластер размером 256 байт.
 92+  CD50                          ; TODO: это не будет работать с другим размером кластера!
 93+  CD50 4E                       ld      c, (hl)
 94+  CD51 0C                       inc     c
 95+  CD52
 96+  CD52                          ; hl = адрес загрузки
 97+  CD52 E1                       pop     hl
 98+  CD53
 99+  CD53              fileLoadLoop:
100+  CD53                          ; Читаем кластер в память
101+  CD53 06 02                    ld      b, 2            ; b = 2 - режим чтения
102+  CD55 CD 63 C8                 call    j_diskDriver    ; de = номер кластера, hl = адрес куда читать
103+  CD58
104+  CD58 24                       inc     h               ; следующий блок в памяти (TODO: это работает только для кластера 256 байт)
105+  CD59
106+  CD59                          ; Вычисляем следующий кластер в fat
107+  CD59 CD 04 CC                 call    fatReadCluster  ; de = номер следующего кластера
108+  CD5C
109+  CD5C 0D                       dec     c               ; счётчик записанных кластеров
110+  CD5D C2 53 CD                 jp nz,  fileLoadLoop    ; повтор цикла
111+  CD60
112+  CD60                          ; Восстанавливаем регистры
113+  CD60 D1                       pop     de
114+  CD61 C1                       pop     bc
115+  CD62 E1                       pop     hl
116+  CD63
117+  CD63 C3 6A CD                 jp      fileLoadExit
118+  CD66
119+  CD66              ; ---------------------------------------------------------------------------
120+  CD66
121+  CD66              fileLoadInfo:
122+  CD66                          ; Ищем файл с именем в hl
123+  CD66 CD EB CC                 call    fileFind
124+  CD69 D8                       ret c
125+  CD6A
126+  CD6A              fileLoadExit:
127+  CD6A                          ; Сохраняем регистры
128+  CD6A E5                       push    hl
129+  CD6B C5                       push    bc
130+  CD6C D5                       push    de
131+  CD6D
132+  CD6D                          ; de = указатель на первое поле после расширения
133+  CD6D 01 0B 00                 ld      bc, FILE_DESCRIPTOR.ext + 3
134+  CD70 09                       add     hl, bc
135+  CD71 EB                       ex      de, hl
136+  CD72
137+  CD72                          ; Информация о файле, исключая имя
138+  CD72 2A 43 CF                 ld      hl, (v_foundedFile)
139+  CD75 09                       add     hl, bc
140+  CD76
141+  CD76                          ; Копируем дескриптор из hl в de, исключая имя и расширение
142+  CD76 06 15                    ld      b, DIR_DESCR_SIZE - DIR_NAME_LENGTH - 3
143+  CD78              fileLoadCDLoop:
144+  CD78 7E                       ld      a, (hl)
145+  CD79 12                       ld      (de), a
146+  CD7A 23                       inc     hl
147+  CD7B 13                       inc     de
148+  CD7C 05                       dec     b
149+  CD7D C2 78 CD                 jp nz,  fileLoadCDLoop
150+  CD80
151+  CD80                          ; Выход CF=0
152+  CD80 B7                       or      a
153+  CD81 C3 4B CC                 jp      popDBH_ret
154+  CD84
144   CD84              	INCLUDE "fileDelete.inc"
  1+  CD84              ;+---------------------------------------------------------------------------
  2+  CD84              ; MXOS
  3+  CD84              ; Удаление файла
  4+  CD84              ;
  5+  CD84              ; На входе
  6+  CD84              ;  hl - имя файла
  7+  CD84              ;
  8+  CD84              ; На выходе
  9+  CD84              ;  cf - ошибка
 10+  CD84              ;  bc, de, hl - сохраняются
 11+  CD84              ;
 12+  CD84              ; 2013-12-12 Дизассемблировано vinxru
 13+  CD84              ;----------------------------------------------------------------------------
 14+  CD84
 15+  CD84              fileDelete: ; Найти файл с именем из hl
 16+  CD84 CD EB CC                 call    fileFind
 17+  CD87 D8                       ret     c
 18+  CD88
 19+  CD88                          ; Удалить файл
 20+  CD88 CD 90 CD                 call    deleteFileInt
 21+  CD8B
 22+  CD8B                          ; Сохранить изменения на диск
 23+  CD8B CD B1 CB                 call    saveFatDir
 24+  CD8E
 25+  CD8E                          ; Результат
 26+  CD8E B7                       or      a
 27+  CD8F C9                       ret
 28+  CD90
 29+  CD90              ; ---------------------------------------------------------------------------
 30+  CD90
 31+  CD90              deleteFileInt:
 32+  CD90                          ; Сохраняем регистры
 33+  CD90 E5                       push    hl
 34+  CD91 C5                       push    bc
 35+  CD92 D5                       push    de
 36+  CD93
 37+  CD93                          ; Помечаем файл, как удаленный заменяя его первую букву его имени на 0FFh
 38+  CD93 2A 43 CF                 ld      hl, (v_foundedFile)
 39+  CD96 36 FF                    ld      (hl), 0FFh
 40+  CD98
 41+  CD98                          ; Получаем первый кластер файла в de
 42+  CD98 11 1A 00                 ld      de, FILE_DESCRIPTOR.firstCluster
 43+  CD9B 19                       add     hl, de
 44+  CD9C 5E                       ld      e, (hl)
 45+  CD9D 23                       inc     hl
 46+  CD9E 56                       ld      d, (hl)
 47+  CD9F
 48+  CD9F              deleteFileLoop:
 49+  CD9F 62                       ld      h, d
 50+  CDA0 6B                       ld      l, e
 51+  CDA1
 52+  CDA1                          ; Обнуляем класте номер de и получаем номер
 53+  CDA1                          ; следующиего кластера файла в de
 54+  CDA1 CD 1C CC                 call    fatFreeCluster
 55+  CDA4
 56+  CDA4                          ; Если это был не последний кластер, продолжаем.
 57+  CDA4 7A                       ld      a, d
 58+  CDA5 BC                       cp      h
 59+  CDA6 C2 9F CD                 jp nz,  deleteFileLoop
 60+  CDA9 7B                       ld      a, e
 61+  CDAA BD                       cp      l
 62+  CDAB C2 9F CD                 jp nz,  deleteFileLoop
 63+  CDAE
 64+  CDAE                          ; Восстаналиваем регистры и выходим
 65+  CDAE C3 4B CC                 jp      popDBH_ret
 66+  CDB1
145   CDB1              	INCLUDE "fileRename.inc"
  1+  CDB1              ;+---------------------------------------------------------------------------
  2+  CDB1              ; MXOS
  3+  CDB1              ; Переименовать файл
  4+  CDB1              ;
  5+  CDB1              ; На входе
  6+  CDB1              ;  hl - исходное имя
  7+  CDB1              ;  de - новое имя
  8+  CDB1              ;
  9+  CDB1              ; На выходе
 10+  CDB1              ;  cf - ошибка
 11+  CDB1              ;  bc, de, hl - сохраняются
 12+  CDB1              ;
 13+  CDB1              ; 2013-12-12 Дизассемблировано vinxru
 14+  CDB1              ;----------------------------------------------------------------------------
 15+  CDB1
 16+  CDB1              fileRename: ; Найти файл с именем из hl
 17+  CDB1 CD EB CC                 call    fileFind
 18+  CDB4 D8                       ret c
 19+  CDB5
 20+  CDB5                          ; Сохранить регистры
 21+  CDB5 E5                       push    hl
 22+  CDB6 C5                       push    bc
 23+  CDB7 D5                       push    de
 24+  CDB8
 25+  CDB8                          ;
 26+  CDB8 2A 43 CF                 ld      hl, (v_foundedFile)
 27+  CDBB
 28+  CDBB                          ; Попытаться найти файл с новым именем
 29+  CDBB EB                       ex      de, hl
 30+  CDBC CD EE CC                 call    fileFind2
 31+  CDBF
 32+  CDBF                          ; Если такой файл есть, то удалить
 33+  CDBF D4 90 CD                 call nc,deleteFileInt
 34+  CDC2
 35+  CDC2                          ; Заменяем имя
 36+  CDC2 0E 0B                    ld      c, DIR_NAME_LENGTH + 3
 37+  CDC4 7E           loc_CD2C:   ld      a, (hl)
 38+  CDC5 12                       ld      (de),a
 39+  CDC6 23                       inc     hl
 40+  CDC7 13                       inc     de
 41+  CDC8 0D                       dec     c
 42+  CDC9 C2 C4 CD                 jp nz,  loc_CD2C
 43+  CDCC
 44+  CDCC                          ; Сохраняем изменения
 45+  CDCC CD B1 CB                 call    saveFatDir
 46+  CDCF
 47+  CDCF                          ; Выход
 48+  CDCF B7                       or      a
 49+  CDD0 C3 4B CC                 jp      popDBH_ret
 50+  CDD3
146   CDD3              	INCLUDE "fileGetSetAttr.inc"
  1+  CDD3              ;+---------------------------------------------------------------------------
  2+  CDD3              ; MXOS
  3+  CDD3              ; Получение/изменение атрибутов файла
  4+  CDD3              ;
  5+  CDD3              ; На входе
  6+  CDD3              ;   hl - имя файла
  7+  CDD3              ;   с  - 0=чтение, 1=изменение
  8+  CDD3              ;   b  - новые атрибуты (если c==1)
  9+  CDD3              ;
 10+  CDD3              ; На выходе
 11+  CDD3              ;   cf - ошибка
 12+  CDD3              ;   a  - атрибуты
 13+  CDD3              ;   bc, de, hl - сохраняются
 14+  CDD3              ;
 15+  CDD3              ; 2013-12-12 Дизассемблировано vinxru
 16+  CDD3              ; 2022-01-31 Доработано SpaceEngineer
 17+  CDD3              ;----------------------------------------------------------------------------
 18+  CDD3
 19+  CDD3              fileGetSetAttr:
 20+  CDD3 C5                       push    bc
 21+  CDD4 47                       ld      b, a
 22+  CDD5
 23+  CDD5                          ; Ищем файл с именем в hl. Если найден, то переходим
 24+  CDD5 CD EB CC                 call    fileFind
 25+  CDD8 D2 DD CD                 jp nc,  fileGetSetAt_0
 26+  CDDB
 27+  CDDB                          ; Ошибка, выходим
 28+  CDDB C1                       pop     bc
 29+  CDDC C9                       ret
 30+  CDDD
 31+  CDDD              ; ---------------------------------------------------------------------------
 32+  CDDD
 33+  CDDD              fileGetSetAt_0:
 34+  CDDD E5                       push    hl
 35+  CDDE
 36+  CDDE                          ; Получаем адрес байта атрибутов
 37+  CDDE D5                       push    de
 38+  CDDF 2A 43 CF                 ld      hl, (v_foundedFile)
 39+  CDE2 11 0B 00                 ld      de, FILE_DESCRIPTOR.attrib
 40+  CDE5 19                       add     hl, de
 41+  CDE6 D1                       pop     de
 42+  CDE7
 43+  CDE7                          ; Проверяем режим
 44+  CDE7 79                       ld      a, c
 45+  CDE8 0D                       dec     c ; ZF=1 если режим 1
 46+  CDE9 C2 ED CD                 jp nz,  fileGetSetAt_1
 47+  CDEC
 48+  CDEC                          ; Устанавливаем атрибуты
 49+  CDEC 70                       ld      (hl), b
 50+  CDED
 51+  CDED              fileGetSetAt_1:
 52+  CDED                          ; Читаем атрибуты
 53+  CDED 7E                       ld      a, (hl)
 54+  CDEE
 55+  CDEE                          ; Сохраняем изменения (хотя для чтения это не нужно делать)
 56+  CDEE CD B1 CB                 call    saveFatDir
 57+  CDF1
 58+  CDF1                          ; Восстанавливаем регистры и выходим ;! А тут точно CF==0 будет?
 59+  CDF1 B7                       or      a
 60+  CDF2 E1                       pop     hl
 61+  CDF3 C1                       pop     bc
 62+  CDF4 C9                       ret
 63+  CDF5
147   CDF5              	INCLUDE "fileGetSetAddr.inc"
  1+  CDF5              ;+---------------------------------------------------------------------------
  2+  CDF5              ; MXOS
  3+  CDF5              ; Получение/изменение адреса загрузки файла
  4+  CDF5              ;
  5+  CDF5              ; На входе
  6+  CDF5              ;   hl - имя файла
  7+  CDF5              ;   с  - 0=чтение, 1=изменение
  8+  CDF5              ;   de - адрес
  9+  CDF5              ;
 10+  CDF5              ; На выходе
 11+  CDF5              ;   de - адрес
 12+  CDF5              ;   bc, hl - сохраняются
 13+  CDF5              ;
 14+  CDF5              ; 2013-12-12 Дизассемблировано vinxru
 15+  CDF5              ; 2022-01-31 Доработано SpaceEngineer
 16+  CDF5              ;----------------------------------------------------------------------------
 17+  CDF5
 18+  CDF5              fileGetSetAddr:   ; Ищем файл с именем в hl
 19+  CDF5 CD EB CC                 call    fileFind
 20+  CDF8 D8                       ret c
 21+  CDF9
 22+  CDF9 E5                       push    hl
 23+  CDFA
 24+  CDFA                          ; Получаем адрес длины файла
 25+  CDFA D5                       push    de
 26+  CDFB 2A 43 CF                 ld      hl, (v_foundedFile)
 27+  CDFE 11 12 00                 ld      de, FILE_DESCRIPTOR.loadAddress
 28+  CE01 19                       add     hl, de
 29+  CE02 D1                       pop     de
 30+  CE03
 31+  CE03                          ; Проверяем режим
 32+  CE03 79                       ld      a, c
 33+  CE04 0D                       dec     c ; ZF=1 если режим 1
 34+  CE05 C2 11 CE                 jp nz,  fileGetSetAd_0
 35+  CE08
 36+  CE08                          ; Заменяем адрес загрузки
 37+  CE08 73                       ld      (hl), e
 38+  CE09 23                       inc     hl
 39+  CE0A 72                       ld      (hl), d
 40+  CE0B
 41+  CE0B                          ; Сохраняем изменения
 42+  CE0B CD B1 CB                 call    saveFatDir
 43+  CE0E
 44+  CE0E                          ; Выходим
 45+  CE0E E1                       pop     hl
 46+  CE0F B7                       or      a
 47+  CE10 C9                       ret
 48+  CE11
 49+  CE11              fileGetSetAd_0:
 50+  CE11                          ; Читаем адрес загрузки
 51+  CE11 5E                       ld      e, (hl)
 52+  CE12 23                       inc     hl
 53+  CE13 56                       ld      d, (hl)
 54+  CE14
 55+  CE14                          ; Выходим
 56+  CE14 E1                       pop     hl
 57+  CE15 B7                       or      a
 58+  CE16 C9                       ret
 59+  CE17
148   CE17              	INCLUDE "fileGetInfoAddr.inc"
  1+  CE17              ;+---------------------------------------------------------------------------
  2+  CE17              ; MXOS
  3+  CE17              ; Получить указатель на информацию о a==1
  4+  CE17              ;
  5+  CE17              ; На входе
  6+  CE17              ;   c - любое число
  7+  CE17              ;
  8+  CE17              ; На выходе
  9+  CE17              ;   b, de - сохраняются
 10+  CE17              ;   hl - указатель на дескриптор после расширения
 11+  CE17              ;   zf - если a==1
 12+  CE17              ;   a = c
 13+  CE17              ;   c = c-1
 14+  CE17              ;
 15+  CE17              ; 2013-12-12 Дизассемблировано vinxru
 16+  CE17              ;----------------------------------------------------------------------------
 17+  CE17
 18+  CE17              ;fileGetInfoAddr:
 19+  CE17              ;            push de
 20+  CE17              ;
 21+  CE17              ;            ; Помещаем в hl адрес информации о файле
 22+  CE17              ;            ld    hl, (v_foundedFile)
 23+  CE17              ;            ld    de, FILE_DESCRIPTOR.attrib
 24+  CE17              ;            add   scf
 25+  CE17              ;
 26+  CE17              ;            ; Помещаем в a режим
 27+  CE17              ;            ld    a, c
 28+  CE17              ;
 29+  CE17              ;            ; ZF=1 если режим 1
 30+  CE17              ;            dec c
 31+  CE17              ;
 32+  CE17              ;            pop de
 33+  CE17              ;            ret
 34+  CE17              ;
 35+  CE17
149   CE17              	INCLUDE "fileList.inc"
  1+  CE17              ;+---------------------------------------------------------------------------
  2+  CE17              ; MXOS
  3+  CE17              ; Получить список файлов каталога.
  4+  CE17              ; Функция копирует в буфер непустые дескрипторы файлов.
  5+  CE17              ;
  6+  CE17              ; На входе
  7+  CE17              ;  hl - адрес буфера
  8+  CE17              ;  b  - максимальное количество дескрипторов файлов для вывода
  9+  CE17              ;
 10+  CE17              ; На выходе
 11+  CE17              ;  bc, de, hl - сохраняются
 12+  CE17              ;
 13+  CE17              ; 2013-12-12 Дизассемблировано vinxru
 14+  CE17              ;----------------------------------------------------------------------------
 15+  CE17
 16+  CE17              fileList:   ; Загрузка FAT и каталога
 17+  CE17 CD B8 CB                 call    loadFatDir
 18+  CE1A
 19+  CE1A                          ; Сохранение регистров
 20+  CE1A E5                       push    hl
 21+  CE1B C5                       push    bc
 22+  CE1C D5                       push    de
 23+  CE1D
 24+  CE1D                          ; Адрес первого файла
 25+  CE1D 11 00 7C                 ld      de, DIR_BUFFER
 26+  CE20
 27+  CE20                          ; Максимум файлов уже в b
 28+  CE20                          ; Но надо ограничить разером каталога устройства
 29+  CE20 3E 20                    ld      a, DIR_MAX_FILES
 30+  CE22 B8                       cp      b
 31+  CE23 D2 27 CE                 jp nc,  fileList_loop
 32+  CE26 47                       ld      b, a    ; b = max(b, DIR_MAX_FILES)
 33+  CE27
 34+  CE27              fileList_loop:
 35+  CE27                          ; Если первый символ не FFh, копируем дескриптор
 36+  CE27 1A                       ld      a, (de)
 37+  CE28 3C                       inc     a
 38+  CE29 C2 3C CE                 jp nz,  fileList_copy
 39+  CE2C
 40+  CE2C                          ; Вычисляем адрес следующего файла
 41+  CE2C E5                       push    hl
 42+  CE2D 21 20 00                 ld      hl, DIR_DESCR_SIZE
 43+  CE30 19                       add     hl, de
 44+  CE31 EB                       ex      de, hl
 45+  CE32 E1                       pop     hl
 46+  CE33
 47+  CE33              fileList_next:
 48+  CE33                          ; Цикл
 49+  CE33 05                       dec     b
 50+  CE34 C2 27 CE                 jp nz,  fileList_loop
 51+  CE37
 52+  CE37                          ; В конце символ 0FFh
 53+  CE37 36 FF                    ld      (hl), 0FFh
 54+  CE39 C3 4B CC                 jp      popDBH_ret
 55+  CE3C
 56+  CE3C              ; ---------------------------------------------------------------------------
 57+  CE3C
 58+  CE3C              fileList_copy:
 59+  CE3C                          ; Копируем DIR_DESCR_SIZE байт из de в hl
 60+  CE3C 0E 20                    ld      c, DIR_DESCR_SIZE
 61+  CE3E 1A           fileList_copyl:     ld    a, (de)
 62+  CE3F 77                       ld      (hl), a
 63+  CE40 23                       inc     hl
 64+  CE41 13                       inc     de
 65+  CE42 0D                       dec     c
 66+  CE43 C2 3E CE                 jp nz,  fileList_copyl
 67+  CE46 C3 33 CE                 jp      fileList_next
 68+  CE49
150   CE49              	INCLUDE "fileNamePrepare.inc"
  1+  CE49              ;+---------------------------------------------------------------------------
  2+  CE49              ; MXOS
  3+  CE49              ; Подготовить имя файла для функций ОС
  4+  CE49              ;
  5+  CE49              ; На входе
  6+  CE49              ;  hl - исходное имя
  7+  CE49              ;  de - буфер для результата (P_INPUT_WIDTH + 3 байт)
  8+  CE49              ;
  9+  CE49              ; 2013-12-12 Дизассемблировано vinxru
 10+  CE49              ;----------------------------------------------------------------------------
 11+  CE49
 12+  CE49              fileNamePrepare:
 13+  CE49                          ; Сохраняем регистры
 14+  CE49 C5                       push    bc
 15+  CE4A D5                       push    de
 16+  CE4B
 17+  CE4B                          ; Если второй символ исходной строки ':', то меняем диск
 18+  CE4B 23                       inc     hl
 19+  CE4C 7E                       ld      a, (hl)
 20+  CE4D FE 3A                    cp      ':'
 21+  CE4F 2B                       dec     hl
 22+  CE50 C2 5B CE                 jp nz,  fileNamePr_1
 23+  CE53
 24+  CE53                          ; Меняем диск
 25+  CE53 7E                       ld      a, (hl)
 26+  CE54 D6 41                    sub     'A'
 27+  CE56 CD 97 CB                 call    fileSelectDrive
 28+  CE59
 29+  CE59                          ; Диск не входит в имя файла
 30+  CE59 23                       inc     hl
 31+  CE5A 23                       inc     hl
 32+  CE5B
 33+  CE5B              fileNamePr_1:
 34+  CE5B                          ; b = длина имени, c = 3 - длина расширения
 35+  CE5B 01 03 08                 ld      bc, (DIR_NAME_LENGTH << 8) + 3
 36+  CE5E
 37+  CE5E                          ; Копируем текст до точки, пробела или конца строки, не более DIR_NAME_LENGTH символов.
 38+  CE5E              fileNamePr_2:
 39+  CE5E 7E                       ld      a, (hl)
 40+  CE5F A7                       and     a
 41+  CE60 F2 65 CE                 jp p,   fileNamePr_3
 42+  CE63 D6 40                    sub     40h         ; проеобразование KOI?
 43+  CE65              fileNamePr_3:
 44+  CE65 FE 21                    cp      ' '+1
 45+  CE67 DA 85 CE                 jp c,   fileNamePr_5
 46+  CE6A 23                       inc     hl
 47+  CE6B FE 2E                    cp      '.'
 48+  CE6D CA 85 CE                 jp z,   fileNamePr_5
 49+  CE70 12                       ld      (de), a
 50+  CE71 13                       inc     de
 51+  CE72 05                       dec     b
 52+  CE73 C2 5E CE                 jp nz,  fileNamePr_2
 53+  CE76
 54+  CE76                          ; Пропускаем текст до точки, пробела или конца строки
 55+  CE76              fileNamePr_4:
 56+  CE76 7E                       ld      a, (hl)
 57+  CE77 FE 21                    cp      ' '+1
 58+  CE79 DA 88 CE                 jp c,   fileNamePr_6
 59+  CE7C 23                       inc     hl
 60+  CE7D FE 2E                    cp      '.'
 61+  CE7F C2 76 CE                 jp nz,  fileNamePr_4
 62+  CE82 C3 88 CE                 jp      fileNamePr_6
 63+  CE85
 64+  CE85              ; ---------------------------------------------------------------------------
 65+  CE85
 66+  CE85              fileNamePr_5:
 67+  CE85                          ; Имя короче DIR_NAME_LENGTH символов
 68+  CE85                          ; Заполняем недостающие символы имени пробелами
 69+  CE85 CD C7 C3                 call    memset_de_20_b
 70+  CE88
 71+  CE88                          ; Копируем текст до пробела или конца строки, не более 3 символов.
 72+  CE88              fileNamePr_6:
 73+  CE88 7E                       ld      a, (hl)
 74+  CE89 A7                       and     a
 75+  CE8A F2 8F CE                 jp p,   fileNamePr_7
 76+  CE8D D6 40                    sub     40h         ; проеобразование KOI?
 77+  CE8F              fileNamePr_7:
 78+  CE8F FE 21                    cp      ' '+1
 79+  CE91 DA A8 CE                 jp c,   fileNamePr_11
 80+  CE94 12                       ld      (de),a
 81+  CE95 23                       inc     hl
 82+  CE96 13                       inc     de
 83+  CE97 0D                       dec     c
 84+  CE98 C2 88 CE                 jp nz,  fileNamePr_6
 85+  CE9B
 86+  CE9B              fileNamePr_8:
 87+  CE9B                          ; Пропускаем текст до пробела или конца строки
 88+  CE9B 7E                       ld      a, (hl)
 89+  CE9C FE 20                    cp      ' '
 90+  CE9E DA A5 CE                 jp c,   fileNamePr_10
 91+  CEA1 23                       inc     hl
 92+  CEA2 C2 9B CE                 jp nz,  fileNamePr_8
 93+  CEA5
 94+  CEA5              ;fileNamePr_9:
 95+  CEA5              ;            ; Пропускаем текст до пробела или конца строки
 96+  CEA5              ;            ; Почему то дублируется код
 97+  CEA5              ;            ld      a, (hl)
 98+  CEA5              ;            cp      ' '
 99+  CEA5              ;            jp c,   fileNamePr_10
100+  CEA5              ;            inc     hl
101+  CEA5              ;            jp z,   fileNamePr_9
102+  CEA5              ;            dec     hl
103+  CEA5
104+  CEA5              fileNamePr_10:    ; Восстанавливаем регистры и выходим
105+  CEA5 D1                       pop     de
106+  CEA6 C1                       pop     bc
107+  CEA7 C9                       ret
108+  CEA8
109+  CEA8              ; ---------------------------------------------------------------------------
110+  CEA8
111+  CEA8              fileNamePr_11:
112+  CEA8                          ; Заполняем недостающие символы расширения пробелами
113+  CEA8 41                       ld      b, c
114+  CEA9 CD C7 C3                 call    memset_de_20_b
115+  CEAC
116+  CEAC                          ; Восстанавливаем регистры и выходим
117+  CEAC D1                       pop     de
118+  CEAD C1                       pop     bc
119+  CEAE C9                       ret
120+  CEAF
151   CEAF              	INCLUDE "printDecWord.inc"
  1+  CEAF              ;----------------------------------------------------------------------------
  2+  CEAF              ; MXOS DOS.SYS
  3+  CEAF              ; Вывод десятичного числа из de
  4+  CEAF              ; Перенесено из NC.COM
  5+  CEAF              ;
  6+  CEAF              ; вход:
  7+  CEAF              ;   de = число
  8+  CEAF              ;   b = дополнить ведущими символами: 20h - пробелами, 30h - нулями, 00h - не дополнять
  9+  CEAF              ;
 10+  CEAF              ; выход:
 11+  CEAF              ;   hl, de, bc - сохраняются
 12+  CEAF              ;
 13+  CEAF              ; 2013-12-18 Дизассемблировано vinxru
 14+  CEAF              ;----------------------------------------------------------------------------
 15+  CEAF
 16+  CEAF              printDecWord:
 17+  CEAF D5                       push  de
 18+  CEB0 C5                       push  bc
 19+  CEB1 E5                       push  hl
 20+  CEB2 EB                       ex    de, hl
 21+  CEB3                          ; ld    b,  20h  ; b = маска кода символа, заменяет ведущие нули на (код_символа and маска)
 22+  CEB3 11 F0 D8                 ld    de, -10000
 23+  CEB6 CD D6 CE                 call  printDec1
 24+  CEB9 11 18 FC                 ld    de, -1000
 25+  CEBC CD D6 CE                 call  printDec1
 26+  CEBF 11 9C FF                 ld    de, -100
 27+  CEC2 CD D6 CE                 call  printDec1
 28+  CEC5 11 F6 FF                 ld    de, -10
 29+  CEC8 CD D6 CE                 call  printDec1
 30+  CECB 7D                       ld    a, l
 31+  CECC C6 30                    add   a, '0'
 32+  CECE 4F                       ld    c, a
 33+  CECF CD 37 C0                 call  printChar
 34+  CED2 E1                       pop   hl
 35+  CED3 C1                       pop   bc
 36+  CED4 D1                       pop   de
 37+  CED5 C9                       ret
 38+  CED6
 39+  CED6              ; ---------------------------------------------------------------------------
 40+  CED6
 41+  CED6
 42+  CED6              printDec1:  ; c = '0' + (hl / de), hl /= de;
 43+  CED6 0E 2F                    ld    c, '0'-1
 44+  CED8
 45+  CED8 0C           loc_DB11:   inc   c
 46+  CED9 19                       add   hl, de
 47+  CEDA DA D8 CE                 jp c, loc_DB11
 48+  CEDD
 49+  CEDD 7A                       ld    a, d        ; hl -= de;
 50+  CEDE 2F                       cpl
 51+  CEDF 57                       ld    d, a
 52+  CEE0 7B                       ld    a, e
 53+  CEE1 2F                       cpl
 54+  CEE2 5F                       ld    e, a
 55+  CEE3 13                       inc   de
 56+  CEE4 19                       add   hl, de
 57+  CEE5 79                       ld    a, c
 58+  CEE6
 59+  CEE6                          ; if (c!='0') b=0xFF; c&=b;
 60+  CEE6 FE 30                    cp    '0'
 61+  CEE8 CA ED CE                 jp z, loc_DB26
 62+  CEEB 06 FF                    ld    b, 0FFh   ; первый не ноль, меняем маску кода символа на 0FFh
 63+  CEED A0           loc_DB26:   and   b
 64+  CEEE C8                       ret   z ; выходим если код символа 0
 65+  CEEF 4F                       ld    c, a
 66+  CEF0 C3 37 C0                 jp    printChar
 67+  CEF3
152   CEF3
153   CEF3              ;---------------------------------------------------------------------------
154   CEF3              ; Константы и Переменные
155   CEF3              ;---------------------------------------------------------------------------
156   CEF3
157   CEF3 0A 42 41 44  txtBadCommand:	    DB 0Ah,"BAD COMMAND OR FILE NAME",0
157   CEF7 20 43 4F 4D
157   CEFB 4D 41 4E 44
157   CEFF 20 4F 52 20
157   CF03 46 49 4C 45
157   CF07 20 4E 41 4D
157   CF0B 45 00
158   CF0D 0C 4D 58 4F  txtBiosVer:         DB 0Ch,"MXOS BIOS 5.00",0Ah, 0
158   CF11 53 20 42 49
158   CF15 4F 53 20 35
158   CF19 2E 30 30 0A
158   CF1D 00
159   CF1E 0A 52 41 4D  txtRAM:             DB 0Ah,"RAM: ",0
159   CF22 3A 20 00
160   CF25 20 4B 42 0A  txtKB:              DB " KB",0Ah, 0
160   CF29 00
161   CF2A
162   CF2A              ; Адреса драйверов для 8 устройств. Начальные значения:
163   CF2A              ; = diskDriver для устройств A: и B: (встроенный драйвер ROM и RAM диска),
164   CF2A              ; = diskDriverDummy для отальных (пустой драйвер).
165   CF2A F2 CA F2 CA  v_drives:			DW diskDriver, diskDriver      ; A:, B:
166   CF2E F2 CA F2 CA                      DW diskDriver, diskDriver      ; C:, D:
167   CF32 F2 CA F2 CA  					DW diskDriver, diskDriver      ; E:, F:
168   CF36 F2 CA F2 CA                      DW diskDriver, diskDriver      ; G:, H:
169   CF3A
170   CF3A 00 00        v_findCluster:		DW 0        ; Используется в fileFindClusterFirst/fileFindClusterNext
171   CF3C 00 00        v_fileFirstCluster: DW 0        ; Первый кластер созданного файла
172   CF3E 01           v_drive:			DB 1
173   CF3F 00 00        v_input_start:		DW 0
174   CF41 00 00        v_createdFile:		DW 0        ; Адрес дескриптора созданного файла
175   CF43 00 00        v_foundedFile:		DW 0
176   CF45 00 00        v_input_end:		DW 0
177   CF47 00 00        v_batPtr:			DW 0        ; Адрес буфра, где находится содержимое BAT файла
178   CF49 FF FA        v_memTop:			DW 0FAFFh   ; Максимальный доступный программам адрес в памяти
179   CF4B
180   CF4B 41 3A 46 4F  pathFontFnt:        DB "A:FONT.FNT",0
180   CF4F 4E 54 2E 46
180   CF53 4E 54 00
181   CF56 41 3A 4E 43  pathNcCom:			DB "A:NC.COM",0
181   CF5A 2E 43 4F 4D
181   CF5E 00
182   CF5F 41 3A 41 55  pathAutoexecBat:	DB "A:AUTOEX.BAT",0
182   CF63 54 4F 45 58
182   CF67 2E 42 41 54
182   CF6B 00
183   CF6C 41 3A 46 4F  pathFormatBat:      DB "A:FORMAT.BAT",0
183   CF70 52 4D 41 54
183   CF74 2E 42 41 54
183   CF78 00
184   CF79 42 41 54     aBat:               DB "BAT"
185   CF7C 43 4F 4D     aCom:               DB "COM"
186   CF7F 45 58 45     aExe:               DB "EXE"
187   CF82
188   CF82                  IF BOOT_FROM_TAPE
189   CF82 ~            aATape_com:         DB "A:TAPE.COM",0
190   CF82 ~            txtLoadingFromTape: DB 0Ah,"LOADING FROM TAPE...",0
191   CF82                  ENDIF
192   CF82
193   CF82 00 00 00 00  v_curFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего файла
193   CF86 00 00 00 00
193   CF8A 00 00 00 00
193   CF8E 00 00 00 00
193   CF92 00 00 00 00
193   CF96 00 00 00 00
193   CF9A 00 00 00 00
193   CF9E 00 00 00 00
194   CFA2 00 00 00 00  v_batFileDescr 		FILE_DESCRIPTOR ; Копия дескриптора текущего BAT файла
194   CFA6 00 00 00 00
194   CFAA 00 00 00 00
194   CFAE 00 00 00 00
194   CFB2 00 00 00 00
194   CFB6 00 00 00 00
194   CFBA 00 00 00 00
194   CFBE 00 00 00 00
195   CFC2
196   CFC2                  ; Проверка - DOS.SYS не должен вылезать за эти пределы
197   CFC2                  ASSERT_DONT_FIT 0D000h
197   CFC2             >         IF $ > 0D000h
197   CFC2 ~           >           ASSERT 0
197   CFC2 ~           >           DISPLAY /l, "Error! Image did not fit (", $, " > ", adr, ")"
197   CFC2             >         ENDIF
198   CFC2
199   CFC2                  IF LOAD_FONT
200   CFC2              	    INCLUDE "font.inc"
  1+  CFC2              ;+---------------------------------------------------------------------------
  2+  CFC2              ; MXOS
  3+  CFC2              ; Загрузка шрифта в память
  4+  CFC2              ;
  5+  CFC2              ; Разработано vinxru
  6+  CFC2              ; Доработано SpaceEngineer
  7+  CFC2              ;----------------------------------------------------------------------------
  8+  CFC2
  9+  CFC2              initFont:   ; Изменяем команду перехода сюда на reboot2
 10+  CFC2 21 38 C5                 ld      hl, reboot2
 11+  CFC5 22 75 C4                 ld      (onceInitFont+1), hl
 12+  CFC8 E5                       push    hl
 13+  CFC9
 14+  CFC9                  IF EMBED_FONT == 0
 15+  CFC9
 16+  CFC9                          ; Шрифт грузится из файла
 17+  CFC9                          ; Устанавливаем блочный драйвер ДОЗУ
 18+  CFC9 06 00                    ld      b, 0
 19+  CFCB CD 90 CA                 call    setRAMDDriver
 20+  CFCE
 21+  CFCE                          ; Ищем и загружаем файл A:FONT.FNT на адрес FONT_ADDR
 22+  CFCE 21 4B CF                 ld      hl, pathFontFnt
 23+  CFD1 11 82 CF                 ld      de, v_curFileDescr
 24+  CFD4 CD 49 CE                 call    fileNamePrepare   ; подготовка имени файла и переключение накопителя
 25+  CFD7 EB                       ex      de, hl
 26+  CFD8 11 00 E9                 ld      de, FONT_ADDR
 27+  CFDB C3 23 CD                 jp      fileLoad2
 28+  CFDE
 29+  CFDE                  ELSE
 30+  CFDE ~                        ; Шрифт встроен в хвост программы
 31+  CFDE ~                        ; Копируем его на адрес FONT_ADDR
 32+  CFDE ~                        ld      hl, font
 33+  CFDE ~                        ld      de, fontEnd
 34+  CFDE ~                        ld      bc, FONT_ADDR
 35+  CFDE ~                        jp      memcpy_bc_hl
 36+  CFDE ~
 37+  CFDE ~            font:
 38+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 0
 39+  CFDE ~                  DB 004h,00Eh,015h,004h,015h,00Eh,004h,000h ; 1
 40+  CFDE ~                  DB 000h,000h,004h,00Ah,01Fh,000h,01Fh,000h ; 2
 41+  CFDE ~                  DB 000h,000h,01Fh,00Ah,004h,000h,01Fh,000h ; 3
 42+  CFDE ~                  DB 009h,01Bh,02Dh,01Bh,009h,000h,000h,000h ; 4
 43+  CFDE ~                  DB 024h,036h,02Dh,036h,024h,000h,000h,000h ; 5
 44+  CFDE ~                  DB 01Eh,021h,02Dh,029h,02Dh,021h,01Eh,000h ; 6
 45+  CFDE ~                  DB 010h,018h,017h,015h,017h,018h,010h,000h ; 7
 46+  CFDE ~                  DB 000h,000h,004h,008h,01Fh,008h,004h,000h ; 8
 47+  CFDE ~                  DB 000h,000h,014h,012h,01Fh,012h,014h,000h ; 9
 48+  CFDE ~                  DB 013h,012h,013h,01Ah,000h,01Fh,000h,000h ; 10
 49+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 11
 50+  CFDE ~                  DB 01Ch,018h,014h,002h,001h,001h,001h,000h ; 12
 51+  CFDE ~                  DB 01Fh,001h,001h,005h,009h,01Fh,008h,004h ; 13
 52+  CFDE ~                  DB 003h,004h,004h,01Ch,03Ch,018h,000h,000h ; 14
 53+  CFDE ~                  DB 003h,009h,005h,03Fh,005h,009h,003h,000h ; 15
 54+  CFDE ~                  DB 003h,009h,011h,03Fh,011h,009h,003h,000h ; 16
 55+  CFDE ~                  DB 004h,00Ah,011h,00Ah,004h,000h,000h,000h ; 17
 56+  CFDE ~                  DB 011h,011h,011h,011h,011h,000h,011h,000h ; 18
 57+  CFDE ~                  DB 000h,000h,000h,000h,000h,011h,011h,000h ; 19
 58+  CFDE ~                  DB 000h,008h,000h,008h,000h,008h,000h,000h ; 20
 59+  CFDE ~                  DB 004h,004h,000h,01Fh,000h,004h,004h,000h ; 21
 60+  CFDE ~                  DB 00Fh,008h,008h,008h,008h,028h,010h,000h ; 22
 61+  CFDE ~                  DB 03Fh,000h,000h,000h,000h,000h,000h,000h ; 23
 62+  CFDE ~                  DB 000h,000h,004h,002h,01Fh,002h,004h,000h ; 24
 63+  CFDE ~                  DB 004h,00Eh,015h,004h,004h,004h,004h,000h ; 25
 64+  CFDE ~                  DB 004h,004h,004h,004h,015h,00Eh,004h,000h ; 26
 65+  CFDE ~                  DB 01Bh,012h,01Ah,012h,01Bh,000h,01Fh,000h ; 27
 66+  CFDE ~                  DB 03Fh,001h,000h,000h,000h,000h,000h,000h ; 28
 67+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 29
 68+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 30
 69+  CFDE ~                  DB 01Fh,011h,019h,015h,013h,011h,01Fh,000h ; 31
 70+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 32
 71+  CFDE ~                  DB 004h,004h,004h,004h,004h,000h,004h,000h ; 33
 72+  CFDE ~                  DB 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
 73+  CFDE ~                  DB 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
 74+  CFDE ~                  DB 004h,00Fh,014h,00Eh,005h,01Eh,004h,000h ; 36
 75+  CFDE ~                  DB 010h,011h,002h,004h,008h,011h,001h,000h ; 37
 76+  CFDE ~                  DB 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
 77+  CFDE ~                  DB 000h,002h,002h,004h,000h,000h,000h,000h ; 39
 78+  CFDE ~                  DB 002h,004h,008h,008h,008h,004h,002h,000h ; 40
 79+  CFDE ~                  DB 008h,004h,002h,002h,002h,004h,008h,000h ; 41
 80+  CFDE ~                  DB 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
 81+  CFDE ~                  DB 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
 82+  CFDE ~                  DB 000h,000h,000h,000h,000h,004h,004h,008h ; 44
 83+  CFDE ~                  DB 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
 84+  CFDE ~                  DB 000h,000h,000h,000h,000h,004h,004h,000h ; 46
 85+  CFDE ~                  DB 000h,001h,002h,004h,008h,010h,000h,000h ; 47
 86+  CFDE ~                  DB 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
 87+  CFDE ~                  DB 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
 88+  CFDE ~                  DB 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
 89+  CFDE ~                  DB 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
 90+  CFDE ~                  DB 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
 91+  CFDE ~                  DB 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
 92+  CFDE ~                  DB 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
 93+  CFDE ~                  DB 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
 94+  CFDE ~                  DB 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
 95+  CFDE ~                  DB 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
 96+  CFDE ~                  DB 000h,004h,004h,000h,000h,004h,004h,000h ; 58
 97+  CFDE ~                  DB 000h,004h,004h,000h,000h,004h,004h,008h ; 59
 98+  CFDE ~                  DB 002h,004h,008h,010h,008h,004h,002h,000h ; 60
 99+  CFDE ~                  DB 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
100+  CFDE ~                  DB 008h,004h,002h,001h,002h,004h,008h,000h ; 62
101+  CFDE ~                  DB 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
102+  CFDE ~                  DB 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
103+  CFDE ~                  DB 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
104+  CFDE ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
105+  CFDE ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
106+  CFDE ~                  DB 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
107+  CFDE ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
108+  CFDE ~                  DB 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
109+  CFDE ~                  DB 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
110+  CFDE ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
111+  CFDE ~                  DB 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
112+  CFDE ~                  DB 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
113+  CFDE ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 75
114+  CFDE ~                  DB 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
115+  CFDE ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
116+  CFDE ~                  DB 011h,011h,019h,015h,013h,011h,011h,000h ; 78
117+  CFDE ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
118+  CFDE ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
119+  CFDE ~                  DB 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
120+  CFDE ~                  DB 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
121+  CFDE ~                  DB 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
122+  CFDE ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
123+  CFDE ~                  DB 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
124+  CFDE ~                  DB 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
125+  CFDE ~                  DB 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
126+  CFDE ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
127+  CFDE ~                  DB 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
128+  CFDE ~                  DB 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
129+  CFDE ~                  DB 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
130+  CFDE ~                  DB 000h,010h,008h,004h,002h,001h,000h,000h ; 92
131+  CFDE ~                  DB 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
132+  CFDE ~                  DB 004h,00Ah,011h,000h,000h,000h,000h,000h ; 94
133+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 95
134+  CFDE ~                  DB 000h,00Fh,000h,006h,009h,009h,006h,000h ; 96
135+  CFDE ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 97
136+  CFDE ~                  DB 008h,008h,008h,00Eh,009h,009h,016h,000h ; 98
137+  CFDE ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 99
138+  CFDE ~                  DB 002h,002h,002h,00Eh,012h,012h,00Dh,000h ; 100
139+  CFDE ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 101
140+  CFDE ~                  DB 006h,009h,008h,01Ch,008h,008h,008h,000h ; 102
141+  CFDE ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,01Ch ; 103
142+  CFDE ~                  DB 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
143+  CFDE ~                  DB 000h,010h,000h,010h,010h,011h,00Eh,000h ; 105
144+  CFDE ~                  DB 000h,001h,000h,001h,001h,001h,011h,00Eh ; 106
145+  CFDE ~                  DB 010h,010h,011h,012h,01Ch,012h,011h,000h ; 107
146+  CFDE ~                  DB 010h,010h,010h,010h,010h,011h,00Eh,000h ; 108
147+  CFDE ~                  DB 000h,000h,01Ah,015h,015h,015h,015h,000h ; 109
148+  CFDE ~                  DB 000h,000h,016h,019h,011h,011h,011h,000h ; 110
149+  CFDE ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
150+  CFDE ~                  DB 000h,000h,016h,009h,009h,00Eh,008h,008h ; 112
151+  CFDE ~                  DB 000h,000h,00Dh,012h,012h,00Eh,002h,002h ; 113
152+  CFDE ~                  DB 000h,000h,016h,009h,008h,008h,008h,000h ; 114
153+  CFDE ~                  DB 000h,000h,00Eh,010h,00Eh,001h,00Eh,000h ; 115
154+  CFDE ~                  DB 008h,008h,01Ch,008h,008h,009h,006h,000h ; 116
155+  CFDE ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 117
156+  CFDE ~                  DB 000h,000h,011h,011h,011h,00Ah,004h,000h ; 118
157+  CFDE ~                  DB 000h,000h,015h,015h,015h,015h,00Ah,000h ; 119
158+  CFDE ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
159+  CFDE ~                  DB 000h,000h,011h,011h,011h,00Fh,001h,00Eh ; 121
160+  CFDE ~                  DB 000h,000h,01Fh,001h,00Eh,010h,01Fh,000h ; 122
161+  CFDE ~                  DB 003h,004h,004h,018h,004h,004h,003h,000h ; 123
162+  CFDE ~                  DB 01Fh,011h,011h,011h,011h,011h,01Fh,000h ; 124
163+  CFDE ~                  DB 018h,004h,004h,003h,004h,004h,018h,000h ; 125
164+  CFDE ~                  DB 000h,000h,008h,015h,002h,000h,000h,000h ; 126
165+  CFDE ~                  DB 001h,003h,007h,00Fh,007h,003h,001h,000h ; 127
166+  CFDE ~                  DB 000h,000h,00Ah,01Fh,01Fh,00Eh,004h,000h ; 128
167+  CFDE ~                  DB 000h,004h,004h,01Fh,004h,004h,01Bh,000h ; 129
168+  CFDE ~                  DB 004h,00Eh,01Fh,01Fh,00Ah,004h,01Bh,000h ; 130
169+  CFDE ~                  DB 000h,000h,004h,00Eh,01Fh,00Eh,004h,000h ; 131
170+  CFDE ~                  DB 002h,004h,00Ah,015h,011h,011h,00Eh,000h ; 132
171+  CFDE ~                  DB 00Eh,004h,01Fh,015h,004h,00Ah,011h,000h ; 133
172+  CFDE ~                  DB 003h,004h,006h,009h,006h,002h,00Ch,000h ; 134
173+  CFDE ~                  DB 007h,003h,005h,00Ch,012h,012h,00Ch,000h ; 135
174+  CFDE ~                  DB 00Eh,011h,011h,00Eh,004h,00Eh,004h,000h ; 136
175+  CFDE ~                  DB 000h,017h,014h,01Fh,005h,01Dh,000h,000h ; 137
176+  CFDE ~                  DB 004h,004h,01Fh,004h,014h,00Ch,006h,005h ; 138
177+  CFDE ~                  DB 004h,01Fh,004h,00Ah,011h,01Fh,004h,000h ; 139
178+  CFDE ~                  DB 004h,01Fh,005h,00Ah,011h,01Fh,004h,000h ; 140
179+  CFDE ~                  DB 004h,004h,01Fh,000h,01Fh,004h,004h,000h ; 141
180+  CFDE ~                  DB 004h,00Eh,00Ah,00Ah,00Ah,00Eh,004h,000h ; 142
181+  CFDE ~                  DB 004h,006h,001h,006h,001h,006h,004h,000h ; 143
182+  CFDE ~                  DB 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 144
183+  CFDE ~                  DB 030h,030h,030h,030h,030h,030h,030h,030h ; 145
184+  CFDE ~                  DB 003h,003h,003h,003h,003h,003h,003h,003h ; 146
185+  CFDE ~                  DB 030h,030h,030h,03Fh,03Fh,030h,030h,030h ; 147
186+  CFDE ~                  DB 003h,003h,003h,03Fh,03Fh,003h,003h,003h ; 148
187+  CFDE ~                  DB 000h,000h,000h,03Fh,03Fh,030h,030h,030h ; 149
188+  CFDE ~                  DB 000h,000h,000h,03Fh,03Fh,003h,003h,003h ; 150
189+  CFDE ~                  DB 003h,003h,003h,03Fh,03Fh,000h,000h,000h ; 151
190+  CFDE ~                  DB 030h,030h,030h,03Fh,03Fh,000h,000h,000h ; 152
191+  CFDE ~                  DB 000h,000h,000h,03Fh,03Fh,018h,018h,018h ; 153
192+  CFDE ~                  DB 018h,018h,018h,018h,018h,018h,018h,018h ; 154
193+  CFDE ~                  DB 018h,018h,018h,03Fh,03Fh,000h,000h,000h ; 155
194+  CFDE ~                  DB 018h,018h,018h,03Fh,03Fh,018h,018h,018h ; 156
195+  CFDE ~                  DB 000h,000h,001h,002h,014h,008h,000h,000h ; 157
196+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 158
197+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,000h ; 159
198+  CFDE ~                  DB 002h,002h,00Ah,016h,012h,012h,00Dh,000h ; 160
199+  CFDE ~                  DB 006h,009h,00Eh,009h,00Eh,008h,010h,000h ; 161
200+  CFDE ~                  DB 01Fh,011h,011h,010h,010h,010h,010h,000h ; 162
201+  CFDE ~                  DB 00Fh,010h,012h,00Ah,00Ah,00Ah,011h,000h ; 163
202+  CFDE ~                  DB 01Fh,008h,004h,002h,004h,008h,01Fh,000h ; 164
203+  CFDE ~                  DB 005h,00Ah,010h,01Eh,011h,011h,00Eh,000h ; 165
204+  CFDE ~                  DB 009h,009h,009h,009h,00Fh,009h,010h,000h ; 166
205+  CFDE ~                  DB 008h,014h,004h,002h,006h,009h,011h,000h ; 167
206+  CFDE ~                  DB 015h,015h,015h,00Eh,004h,004h,004h,000h ; 168
207+  CFDE ~                  DB 00Eh,011h,01Bh,01Fh,01Bh,011h,00Eh,000h ; 169
208+  CFDE ~                  DB 00Eh,011h,011h,00Eh,004h,015h,01Bh,000h ; 170
209+  CFDE ~                  DB 006h,009h,009h,006h,000h,000h,000h,000h ; 171
210+  CFDE ~                  DB 00Eh,013h,015h,019h,00Eh,000h,000h,000h ; 172
211+  CFDE ~                  DB 002h,006h,002h,002h,007h,000h,000h,000h ; 173
212+  CFDE ~                  DB 006h,009h,002h,004h,00Fh,000h,000h,000h ; 174
213+  CFDE ~                  DB 00Fh,001h,002h,009h,006h,000h,000h,000h ; 175
214+  CFDE ~                  DB 00Ah,00Ah,00Fh,002h,002h,000h,000h,000h ; 176
215+  CFDE ~                  DB 00Eh,008h,00Eh,001h,00Eh,000h,000h,000h ; 177
216+  CFDE ~                  DB 006h,008h,00Eh,009h,006h,000h,000h,000h ; 178
217+  CFDE ~                  DB 00Fh,001h,002h,004h,004h,000h,000h,000h ; 179
218+  CFDE ~                  DB 006h,009h,006h,009h,006h,000h,000h,000h ; 180
219+  CFDE ~                  DB 006h,009h,007h,001h,006h,000h,000h,000h ; 181
220+  CFDE ~                  DB 000h,000h,00Eh,013h,015h,019h,00Eh,000h ; 182
221+  CFDE ~                  DB 000h,000h,002h,006h,002h,002h,007h,000h ; 183
222+  CFDE ~                  DB 000h,000h,006h,009h,002h,004h,00Fh,000h ; 184
223+  CFDE ~                  DB 000h,000h,00Fh,001h,002h,009h,006h,000h ; 185
224+  CFDE ~                  DB 000h,000h,00Ah,00Ah,00Fh,002h,002h,000h ; 186
225+  CFDE ~                  DB 000h,000h,00Eh,008h,00Eh,001h,00Eh,000h ; 187
226+  CFDE ~                  DB 000h,000h,006h,008h,00Eh,009h,006h,000h ; 188
227+  CFDE ~                  DB 000h,000h,00Fh,001h,002h,004h,004h,000h ; 189
228+  CFDE ~                  DB 000h,000h,006h,009h,006h,009h,006h,000h ; 190
229+  CFDE ~                  DB 000h,000h,006h,009h,007h,001h,006h,000h ; 191
230+  CFDE ~                  DB 000h,000h,012h,015h,01Dh,015h,012h,000h ; 192
231+  CFDE ~                  DB 000h,000h,00Ch,002h,00Eh,012h,00Dh,000h ; 193
232+  CFDE ~                  DB 001h,00Eh,010h,01Eh,011h,011h,00Eh,000h ; 194
233+  CFDE ~                  DB 000h,000h,012h,012h,012h,012h,00Fh,001h ; 195
234+  CFDE ~                  DB 00Eh,001h,001h,00Fh,011h,011h,00Eh,000h ; 196
235+  CFDE ~                  DB 000h,000h,00Eh,011h,01Fh,010h,00Eh,000h ; 197
236+  CFDE ~                  DB 000h,000h,00Eh,015h,015h,00Eh,004h,004h ; 198
237+  CFDE ~                  DB 000h,000h,00Ch,012h,004h,009h,006h,000h ; 199
238+  CFDE ~                  DB 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 200
239+  CFDE ~                  DB 000h,000h,012h,012h,012h,012h,00Dh,000h ; 201
240+  CFDE ~                  DB 00Ch,000h,012h,012h,012h,012h,00Dh,000h ; 202
241+  CFDE ~                  DB 000h,000h,011h,012h,01Ch,012h,011h,000h ; 203
242+  CFDE ~                  DB 000h,000h,007h,009h,009h,009h,011h,000h ; 204
243+  CFDE ~                  DB 000h,000h,011h,01Bh,015h,011h,011h,000h ; 205
244+  CFDE ~                  DB 000h,000h,011h,011h,01Fh,011h,011h,000h ; 206
245+  CFDE ~                  DB 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 207
246+  CFDE ~                  DB 000h,000h,01Fh,011h,011h,011h,011h,000h ; 208
247+  CFDE ~                  DB 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 209
248+  CFDE ~                  DB 000h,000h,01Eh,011h,011h,01Eh,010h,000h ; 210
249+  CFDE ~                  DB 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 211
250+  CFDE ~                  DB 000h,000h,01Fh,004h,004h,004h,004h,000h ; 212
251+  CFDE ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,00Eh ; 213
252+  CFDE ~                  DB 000h,000h,015h,015h,00Eh,015h,015h,000h ; 214
253+  CFDE ~                  DB 00Ch,014h,018h,01Eh,011h,011h,00Eh,000h ; 215
254+  CFDE ~                  DB 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 216
255+  CFDE ~                  DB 000h,000h,011h,011h,01Dh,013h,01Dh,000h ; 217
256+  CFDE ~                  DB 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 218
257+  CFDE ~                  DB 000h,000h,011h,015h,015h,015h,01Fh,000h ; 219
258+  CFDE ~                  DB 000h,000h,01Eh,001h,007h,001h,01Eh,000h ; 220
259+  CFDE ~                  DB 000h,000h,015h,015h,015h,015h,01Fh,001h ; 221
260+  CFDE ~                  DB 000h,000h,011h,011h,00Fh,001h,001h,000h ; 222
261+  CFDE ~                  DB 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 223
262+  CFDE ~                  DB 012h,015h,015h,01Dh,015h,015h,012h,000h ; 224
263+  CFDE ~                  DB 00Eh,011h,011h,011h,01Fh,011h,011h,000h ; 225
264+  CFDE ~                  DB 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 226
265+  CFDE ~                  DB 012h,012h,012h,012h,012h,012h,01Fh,001h ; 227
266+  CFDE ~                  DB 006h,00Ah,00Ah,00Ah,00Ah,01Fh,011h,000h ; 228
267+  CFDE ~                  DB 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 229
268+  CFDE ~                  DB 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 230
269+  CFDE ~                  DB 01Fh,011h,010h,010h,010h,010h,010h,000h ; 231
270+  CFDE ~                  DB 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 232
271+  CFDE ~                  DB 011h,011h,013h,015h,019h,011h,011h,000h ; 233
272+  CFDE ~                  DB 015h,011h,013h,015h,019h,011h,011h,000h ; 234
273+  CFDE ~                  DB 011h,012h,014h,018h,014h,012h,011h,000h ; 235
274+  CFDE ~                  DB 007h,009h,009h,009h,009h,009h,019h,000h ; 236
275+  CFDE ~                  DB 011h,01Bh,015h,015h,011h,011h,011h,000h ; 237
276+  CFDE ~                  DB 011h,011h,011h,01Fh,011h,011h,011h,000h ; 238
277+  CFDE ~                  DB 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 239
278+  CFDE ~                  DB 01Fh,011h,011h,011h,011h,011h,011h,000h ; 240
279+  CFDE ~                  DB 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 241
280+  CFDE ~                  DB 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 242
281+  CFDE ~                  DB 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 243
282+  CFDE ~                  DB 01Fh,004h,004h,004h,004h,004h,004h,000h ; 244
283+  CFDE ~                  DB 011h,011h,011h,00Ah,004h,008h,010h,000h ; 245
284+  CFDE ~                  DB 011h,015h,015h,00Eh,015h,015h,011h,000h ; 246
285+  CFDE ~                  DB 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 247
286+  CFDE ~                  DB 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 248
287+  CFDE ~                  DB 011h,011h,011h,019h,015h,015h,019h,000h ; 249
288+  CFDE ~                  DB 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 250
289+  CFDE ~                  DB 011h,015h,015h,015h,015h,015h,01Fh,000h ; 251
290+  CFDE ~                  DB 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 252
291+  CFDE ~                  DB 015h,015h,015h,015h,015h,015h,01Fh,001h ; 253
292+  CFDE ~                  DB 011h,011h,011h,00Fh,001h,001h,001h,000h ; 254
293+  CFDE ~                  DB 000h,000h,000h,000h,000h,000h,000h,01Fh ; 255
294+  CFDE ~            fontEnd:
295+  CFDE ~
296+  CFDE                  ENDIF
297+  CFDE
201   CFDE                  ENDIF
202   CFDE
203   CFDE                  END
