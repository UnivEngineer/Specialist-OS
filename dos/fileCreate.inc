;----------------------------------------------------------------------------
; MXOS
; Создать файл
;
; На входе
;  hl - адрес дескриптора файла в формате FAT (имя, фтрибуты, размер и т.д.)
;
; На выходе
;  сf - ошибка
;
; 2013-12-12 Дизассемблировано vinxru
;----------------------------------------------------------------------------

fileCreate: ; Сохраняем регистры
            push    hl
            push    bc
            push    de

            ; Если файл существует, то удаляем его
            call    fileFind
            call nc,deleteFileInt

            ; Сохраняем готовый дескриптор файла
            push    hl

            ; Ищем свободную запись в каталоге
            ld      hl, diskDirectory     ; Адрес каталога
            ld      de, DIR_DESCR_SIZE    ; Размер записи в каталоге
            ld      b,  DIR_MAX_FILES     ; Максимум файлов
fileCreate_0:
            ld      a, (hl)
            inc     a
            jp z,   fileCreate_1          ; Свободная запись найдена
            add     hl, de
            dec     b
            jp nz,  fileCreate_0

            ; Свободных записей нет

            ; Освобождаем стек
            pop     hl

            ; Установка a=0, ZF=1
            xor     a           

stc_popDBh_ret:
            ; Установка флага CF=1
            scf

popDBh_ret: ; Восстановление регистров и выход
            pop     de
            pop     bc
            pop     hl
            ret

; ---------------------------------------------------------------------------
; Свободная запись найдена

fileCreate_1:
            ; Сохраняем адрес дескриптора создаваемого файла в буфере каталога
            ld      (v_createdFile), hl

            ; Копируем в de
            ex      de, hl

            ; Адрес готового дескриптора файла в hl
            pop     hl

            ; Копируем готовый дескриптор файла в каталог (из hl в de)
            ld      c, DIR_DESCR_SIZE
fileCreate_2:
            ld      a, (hl)
            ld      (de),a
            inc     hl
            inc     de
            dec     c
            jp nz,  fileCreate_2

            ; Ищем свободный кластер (результат - в A)
            call    fileFindClusterFirst
            jp c,   stc_popDBh_ret ; если нет свободных кластеров - выходим с ошибкой

            push    af

            ; Сохраняем в каталог адрес первого кластера
            ld      hl, (v_createdFile)
            ld      bc, FILE_DESCRIPTOR.firstCluster
            add     hl, bc  ; hl = адрес поля firstCluster в дескрипторе файла
            ld      (hl), a

		    ; Читаем адрес загрузки файла
            ; de = адрес загрузки файла
            ld      hl, (v_createdFile)
            ld      bc, FILE_DESCRIPTOR.loadAddress
            add     hl, bc  ; hl = адрес поля loadAddress (мл. байт) в дескрипторе файла
            ld      e, (hl)
            inc     hl      ; hl = адрес поля loadAddress (ст. байт) в дескрипторе файла
            ld      d, (hl) ; b = старший байт адреса загрузки

            ; Сохраняем адрес загрузки в переменную v_input_start
            ex      de, hl
            ld      (v_input_start), hl ; v_input_start = адрес загрузки файла

            ; Читаем размер файла
            ; de = размер файла
            ld      hl, (v_createdFile)
            ld      bc, FILE_DESCRIPTOR.size
            add     hl, bc  ; hl = адрес поля size (мл. байт) в дескрипторе файла
            ld      e, (hl)
            inc     hl      ; hl = адрес поля size (ст. байт) в дескрипторе файла
            ld      d, (hl)

            ; Сохраняем размер файла в переменную v_input_end
            ex      de, hl
            ld      (v_input_end), hl   ; v_input_end = размер файла

            ; Подготавливаем необходимые регистры
            ld      b, h        ; b = старший байт размера = количество кластеров файла - 1, т.к. кластер размером 256 байт.
            inc     b           ; b = количество кластеров файла. TODO: это не будет работать с другим размером кластера!
            pop     af          ; a = первый кластер файла
            ld      c, a        ; с = первый кластер файла
            ld      h, fat>>8   ; h = старший адрес таблицы fat в памяти
            ld      l, a        ; hl = указатель на первый кластер файла в таблице fat

            jp      writeFirstCluster

; ---------------------------------------------------------------------------
; Записываем кластеры файла в таблицу fat в памяти

allocClusters:
            call    fileFindClusterNext
            jp c,   stc_popDBh_ret  ; если больше нет свободных кластеров - выходим с ошибкой
writeFirstCluster:
            ld      (hl), a         ; записываем номер кластера в fat
            ld      l, a            ; прыгем на следующий кластер (hl = указатель на следующий кластер файла в таблице fat)
            dec     b               ; счётчик записанных кластеров
            jp nz,  allocClusters
            ld      (hl), l         ; конец, последний кластер файла указывает сам на себя

; ---------------------------------------------------------------------------
; Сохраняем файл на диск

            ld      hl, (v_input_start) ;hl = адрес загрузки файла из v_input_start
            ld      b, fat>>8       ; bc = адрес первого кластера файла в таблице fat
            ld      e, 1            ; режим драйвера 1 - запись
writeFileLoop:
            ld      d, c            ; номер кластера на диске (изначально c = первый кластер файла)
            call    j_diskDriver
            inc     h               ; cледующий блок файла в памяти (!!! TODO: адрес файла обязательно выровнен по 256 байтам?)
            ld      a, (bc)         ; a = номер следующего кластера файла из таблицы fat
            cp      c               ; сравниваем с номером только что записанного кластера
            ld      c, a            ; c = номер следующего кластера
            jp nz,  writeFileLoop   ; если номер следующего кластера = номер только что записанного, это был последний

; ---------------------------------------------------------------------------
; Расчет однобайтовой контрольной суммы

            ld      hl, (v_input_end)   ; hl = размер файла - 1 из v_input_end
            inc     hl                  ; hl = размер файла
            ex      de, hl              ; de = размер файла
            ld      hl, (v_input_start) ; hl = адрес загрузки файла из v_input_start
            ld      b, 0                ; тут будет накапливаться сумма
fileCreateCRCLoop:
            ld      a, d
            or      e
            jp z,   fileCreateExit      ; если счетчик досчитал до нуля, выходим
            ld  a,  (hl)                ; читаем байт файла
            add     a, b                ; накапливаем сумму
            ld      b, a
            inc     hl                  ; следующий байт
            dec     de                  ; уменьшаем счетчик
            jp      fileCreateCRCLoop

; ------------------------------------------------------------------------------------------------------------------------
; Сохранение и выход

fileCreateExit:
            ; Сохраняем контрольную сумму в дескриптор файла
            ld      a, b                ; a = посчитанная контрольная сумма
            ld      hl, (v_createdFile)
            ld      bc, FILE_DESCRIPTOR.checkSum
            add     hl, bc              ; hl = адрес поля checkSum в дескрипторе файла
            ld      (hl), a             ; сохраняем контрльную сумму

            call    saveFatDir          ; сохраняем fat и каталог на диск
            or      a                   ; выходим с флагом cf = 0
            jp      popDBh_ret

